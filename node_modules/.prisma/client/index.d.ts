
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model bills
 * 
 */
export type bills = $Result.DefaultSelection<Prisma.$billsPayload>
/**
 * Model consumer_documents
 * 
 */
export type consumer_documents = $Result.DefaultSelection<Prisma.$consumer_documentsPayload>
/**
 * Model consumers
 * 
 */
export type consumers = $Result.DefaultSelection<Prisma.$consumersPayload>
/**
 * Model current_transformers
 * 
 */
export type current_transformers = $Result.DefaultSelection<Prisma.$current_transformersPayload>
/**
 * Model departments
 * 
 */
export type departments = $Result.DefaultSelection<Prisma.$departmentsPayload>
/**
 * Model dtr_faults
 * 
 */
export type dtr_faults = $Result.DefaultSelection<Prisma.$dtr_faultsPayload>
/**
 * Model dtr_maintenance
 * 
 */
export type dtr_maintenance = $Result.DefaultSelection<Prisma.$dtr_maintenancePayload>
/**
 * Model dtr_readings
 * 
 */
export type dtr_readings = $Result.DefaultSelection<Prisma.$dtr_readingsPayload>
/**
 * Model dtrs
 * 
 */
export type dtrs = $Result.DefaultSelection<Prisma.$dtrsPayload>
/**
 * Model location_types
 * 
 */
export type location_types = $Result.DefaultSelection<Prisma.$location_typesPayload>
/**
 * Model locations
 * 
 */
export type locations = $Result.DefaultSelection<Prisma.$locationsPayload>
/**
 * Model login_history
 * 
 */
export type login_history = $Result.DefaultSelection<Prisma.$login_historyPayload>
/**
 * Model meter_configurations
 * 
 */
export type meter_configurations = $Result.DefaultSelection<Prisma.$meter_configurationsPayload>
/**
 * Model meter_readings
 * 
 */
export type meter_readings = $Result.DefaultSelection<Prisma.$meter_readingsPayload>
/**
 * Model meters
 * 
 */
export type meters = $Result.DefaultSelection<Prisma.$metersPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model permissions
 * 
 */
export type permissions = $Result.DefaultSelection<Prisma.$permissionsPayload>
/**
 * Model potential_transformers
 * 
 */
export type potential_transformers = $Result.DefaultSelection<Prisma.$potential_transformersPayload>
/**
 * Model role_permissions
 * 
 */
export type role_permissions = $Result.DefaultSelection<Prisma.$role_permissionsPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model tickets
 * 
 */
export type tickets = $Result.DefaultSelection<Prisma.$ticketsPayload>
/**
 * Model user_activity_logs
 * 
 */
export type user_activity_logs = $Result.DefaultSelection<Prisma.$user_activity_logsPayload>
/**
 * Model user_permissions
 * 
 */
export type user_permissions = $Result.DefaultSelection<Prisma.$user_permissionsPayload>
/**
 * Model user_sessions
 * 
 */
export type user_sessions = $Result.DefaultSelection<Prisma.$user_sessionsPayload>
/**
 * Model refresh_tokens
 * 
 */
export type refresh_tokens = $Result.DefaultSelection<Prisma.$refresh_tokensPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model raw_xml_import
 * 
 */
export type raw_xml_import = $Result.DefaultSelection<Prisma.$raw_xml_importPayload>
/**
 * Model prepaid_accounts
 * 
 */
export type prepaid_accounts = $Result.DefaultSelection<Prisma.$prepaid_accountsPayload>
/**
 * Model prepaid_alerts
 * 
 */
export type prepaid_alerts = $Result.DefaultSelection<Prisma.$prepaid_alertsPayload>
/**
 * Model prepaid_recharges
 * 
 */
export type prepaid_recharges = $Result.DefaultSelection<Prisma.$prepaid_rechargesPayload>
/**
 * Model prepaid_transactions
 * 
 */
export type prepaid_transactions = $Result.DefaultSelection<Prisma.$prepaid_transactionsPayload>
/**
 * Model tamper_code_desc
 * 
 */
export type tamper_code_desc = $Result.DefaultSelection<Prisma.$tamper_code_descPayload>
/**
 * Model tamper_events
 * 
 */
export type tamper_events = $Result.DefaultSelection<Prisma.$tamper_eventsPayload>
/**
 * Model tariff
 * 
 */
export type tariff = $Result.DefaultSelection<Prisma.$tariffPayload>
/**
 * Model tariff_slabs
 * 
 */
export type tariff_slabs = $Result.DefaultSelection<Prisma.$tariff_slabsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BillStatus: {
  GENERATED: 'GENERATED',
  VERIFIED: 'VERIFIED',
  APPROVED: 'APPROVED',
  DISPUTED: 'DISPUTED',
  CANCELLED: 'CANCELLED'
};

export type BillStatus = (typeof BillStatus)[keyof typeof BillStatus]


export const DocumentType: {
  ID_PROOF: 'ID_PROOF',
  ADDRESS_PROOF: 'ADDRESS_PROOF',
  OWNERSHIP_PROOF: 'OWNERSHIP_PROOF',
  NOC: 'NOC',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const VerificationStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const IdType: {
  PASSPORT: 'PASSPORT',
  DRIVING_LICENSE: 'DRIVING_LICENSE',
  NATIONAL_ID: 'NATIONAL_ID',
  VOTER_ID: 'VOTER_ID',
  TAX_ID: 'TAX_ID'
};

export type IdType = (typeof IdType)[keyof typeof IdType]


export const ConnectionType: {
  RESIDENTIAL: 'RESIDENTIAL',
  COMMERCIAL: 'COMMERCIAL',
  INDUSTRIAL: 'INDUSTRIAL',
  AGRICULTURAL: 'AGRICULTURAL'
};

export type ConnectionType = (typeof ConnectionType)[keyof typeof ConnectionType]


export const ConsumerCategory: {
  DOMESTIC: 'DOMESTIC',
  SMALL_COMMERCIAL: 'SMALL_COMMERCIAL',
  LARGE_COMMERCIAL: 'LARGE_COMMERCIAL',
  INDUSTRIAL: 'INDUSTRIAL',
  AGRICULTURAL: 'AGRICULTURAL',
  GOVERNMENT: 'GOVERNMENT'
};

export type ConsumerCategory = (typeof ConsumerCategory)[keyof typeof ConsumerCategory]


export const BillingCycle: {
  MONTHLY: 'MONTHLY',
  BIMONTHLY: 'BIMONTHLY',
  QUARTERLY: 'QUARTERLY'
};

export type BillingCycle = (typeof BillingCycle)[keyof typeof BillingCycle]


export const PaymentMethod: {
  CASH: 'CASH',
  CHEQUE: 'CHEQUE',
  CARD: 'CARD',
  UPI: 'UPI',
  NETBANKING: 'NETBANKING',
  WALLET: 'WALLET'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const BillDeliveryMode: {
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  WHATSAPP: 'WHATSAPP',
  PHYSICAL: 'PHYSICAL'
};

export type BillDeliveryMode = (typeof BillDeliveryMode)[keyof typeof BillDeliveryMode]


export const FaultType: {
  OVERLOAD: 'OVERLOAD',
  SHORT_CIRCUIT: 'SHORT_CIRCUIT',
  EARTH_FAULT: 'EARTH_FAULT',
  OIL_LEAK: 'OIL_LEAK',
  HIGH_TEMPERATURE: 'HIGH_TEMPERATURE',
  LOW_OIL: 'LOW_OIL',
  BUSHING_FAILURE: 'BUSHING_FAILURE',
  WINDING_FAILURE: 'WINDING_FAILURE',
  OTHER: 'OTHER'
};

export type FaultType = (typeof FaultType)[keyof typeof FaultType]


export const FaultSeverity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type FaultSeverity = (typeof FaultSeverity)[keyof typeof FaultSeverity]


export const FaultStatus: {
  DETECTED: 'DETECTED',
  ANALYZING: 'ANALYZING',
  REPAIRING: 'REPAIRING',
  RESOLVED: 'RESOLVED',
  UNRESOLVED: 'UNRESOLVED'
};

export type FaultStatus = (typeof FaultStatus)[keyof typeof FaultStatus]


export const MaintenanceType: {
  ROUTINE: 'ROUTINE',
  PREVENTIVE: 'PREVENTIVE',
  CORRECTIVE: 'CORRECTIVE',
  EMERGENCY: 'EMERGENCY',
  OIL_TEST: 'OIL_TEST',
  INSPECTION: 'INSPECTION'
};

export type MaintenanceType = (typeof MaintenanceType)[keyof typeof MaintenanceType]


export const MaintenanceStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  DEFERRED: 'DEFERRED'
};

export type MaintenanceStatus = (typeof MaintenanceStatus)[keyof typeof MaintenanceStatus]


export const DTRReadingType: {
  REGULAR: 'REGULAR',
  SPECIAL: 'SPECIAL',
  ALARM: 'ALARM',
  FAULT: 'FAULT'
};

export type DTRReadingType = (typeof DTRReadingType)[keyof typeof DTRReadingType]


export const DTRType: {
  DISTRIBUTION: 'DISTRIBUTION',
  POWER: 'POWER',
  AUTO: 'AUTO',
  SPECIAL_PURPOSE: 'SPECIAL_PURPOSE'
};

export type DTRType = (typeof DTRType)[keyof typeof DTRType]


export const CoolingType: {
  ONAN: 'ONAN',
  ONAF: 'ONAF',
  OFAF: 'OFAF',
  ODAF: 'ODAF'
};

export type CoolingType = (typeof CoolingType)[keyof typeof CoolingType]


export const OilType: {
  MINERAL: 'MINERAL',
  SYNTHETIC: 'SYNTHETIC',
  BIO_BASED: 'BIO_BASED',
  SILICONE: 'SILICONE'
};

export type OilType = (typeof OilType)[keyof typeof OilType]


export const DTRStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  MAINTENANCE: 'MAINTENANCE',
  FAULTY: 'FAULTY',
  OVERLOADED: 'OVERLOADED',
  DECOMMISSIONED: 'DECOMMISSIONED'
};

export type DTRStatus = (typeof DTRStatus)[keyof typeof DTRStatus]


export const ReadingType: {
  REGULAR: 'REGULAR',
  SPECIAL: 'SPECIAL',
  PROVISIONAL: 'PROVISIONAL',
  FINAL: 'FINAL'
};

export type ReadingType = (typeof ReadingType)[keyof typeof ReadingType]


export const ReadingSource: {
  AMR: 'AMR',
  MANUAL: 'MANUAL',
  MOBILE_APP: 'MOBILE_APP',
  ESTIMATED: 'ESTIMATED'
};

export type ReadingSource = (typeof ReadingSource)[keyof typeof ReadingSource]


export const MeterType: {
  PREPAID: 'PREPAID',
  POSTPAID: 'POSTPAID'
};

export type MeterType = (typeof MeterType)[keyof typeof MeterType]


export const MeterStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  FAULTY: 'FAULTY',
  DISCONNECTED: 'DISCONNECTED'
};

export type MeterStatus = (typeof MeterStatus)[keyof typeof MeterStatus]


export const NotificationType: {
  BILL_GENERATED: 'BILL_GENERATED',
  PAYMENT_DUE: 'PAYMENT_DUE',
  PAYMENT_RECEIVED: 'PAYMENT_RECEIVED',
  LOW_BALANCE: 'LOW_BALANCE',
  METER_DISCONNECTED: 'METER_DISCONNECTED'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type NotificationPriority = (typeof NotificationPriority)[keyof typeof NotificationPriority]


export const NotificationStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  FAILED: 'FAILED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const NotificationChannel: {
  SMS: 'SMS',
  EMAIL: 'EMAIL',
  PUSH: 'PUSH',
  WHATSAPP: 'WHATSAPP'
};

export type NotificationChannel = (typeof NotificationChannel)[keyof typeof NotificationChannel]


export const PaymentStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const AccessLevel: {
  RESTRICTED: 'RESTRICTED',
  NORMAL: 'NORMAL',
  ELEVATED: 'ELEVATED',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type AccessLevel = (typeof AccessLevel)[keyof typeof AccessLevel]


export const TicketType: {
  COMPLAINT: 'COMPLAINT',
  SERVICE_REQUEST: 'SERVICE_REQUEST',
  INQUIRY: 'INQUIRY'
};

export type TicketType = (typeof TicketType)[keyof typeof TicketType]


export const TicketCategory: {
  BILLING: 'BILLING',
  METER: 'METER',
  CONNECTION: 'CONNECTION',
  TECHNICAL: 'TECHNICAL',
  OTHER: 'OTHER'
};

export type TicketCategory = (typeof TicketCategory)[keyof typeof TicketCategory]


export const TicketPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const TicketStatus: {
  OPEN: 'OPEN',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const PrepaidAlertType: {
  LOW_BALANCE: 'LOW_BALANCE',
  EMERGENCY_LOW: 'EMERGENCY_LOW',
  CONSUMPTION_HIGH: 'CONSUMPTION_HIGH',
  RECHARGE_SUCCESS: 'RECHARGE_SUCCESS',
  RECHARGE_FAILED: 'RECHARGE_FAILED',
  DISCONNECTION_WARNING: 'DISCONNECTION_WARNING',
  DISCONNECTED: 'DISCONNECTED',
  RECONNECTED: 'RECONNECTED'
};

export type PrepaidAlertType = (typeof PrepaidAlertType)[keyof typeof PrepaidAlertType]


export const PrepaidAlertLevel: {
  INFO: 'INFO',
  WARNING: 'WARNING',
  CRITICAL: 'CRITICAL',
  EMERGENCY: 'EMERGENCY'
};

export type PrepaidAlertLevel = (typeof PrepaidAlertLevel)[keyof typeof PrepaidAlertLevel]


export const PrepaidRechargeType: {
  MANUAL: 'MANUAL',
  AUTO: 'AUTO',
  PROMOTIONAL: 'PROMOTIONAL',
  REFUND: 'REFUND',
  ADMIN: 'ADMIN'
};

export type PrepaidRechargeType = (typeof PrepaidRechargeType)[keyof typeof PrepaidRechargeType]


export const PrepaidRechargeSource: {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  MOBILE_APP: 'MOBILE_APP',
  SMS: 'SMS',
  USSD: 'USSD',
  AGENT: 'AGENT'
};

export type PrepaidRechargeSource = (typeof PrepaidRechargeSource)[keyof typeof PrepaidRechargeSource]


export const PrepaidTransactionType: {
  RECHARGE: 'RECHARGE',
  CONSUMPTION: 'CONSUMPTION',
  ADJUSTMENT: 'ADJUSTMENT',
  REFUND: 'REFUND',
  PENALTY: 'PENALTY',
  BONUS: 'BONUS',
  EXPIRY: 'EXPIRY',
  TRANSFER: 'TRANSFER'
};

export type PrepaidTransactionType = (typeof PrepaidTransactionType)[keyof typeof PrepaidTransactionType]


export const PrepaidTransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REVERSED: 'REVERSED'
};

export type PrepaidTransactionStatus = (typeof PrepaidTransactionStatus)[keyof typeof PrepaidTransactionStatus]


export const TamperType: {
  METER_BYPASS: 'METER_BYPASS',
  MAGNETIC_TAMPER: 'MAGNETIC_TAMPER',
  COVER_OPEN: 'COVER_OPEN',
  TERMINAL_TAMPER: 'TERMINAL_TAMPER',
  REVERSE_POLARITY: 'REVERSE_POLARITY',
  PHASE_MISMATCH: 'PHASE_MISMATCH',
  CURRENT_SHUNT: 'CURRENT_SHUNT',
  VOLTAGE_SHUNT: 'VOLTAGE_SHUNT',
  POWER_FAILURE: 'POWER_FAILURE',
  NO_LOAD: 'NO_LOAD',
  OTHER: 'OTHER'
};

export type TamperType = (typeof TamperType)[keyof typeof TamperType]


export const TamperStatus: {
  DETECTED: 'DETECTED',
  CONFIRMED: 'CONFIRMED',
  RESOLVED: 'RESOLVED',
  FALSE_ALARM: 'FALSE_ALARM',
  INVESTIGATING: 'INVESTIGATING'
};

export type TamperStatus = (typeof TamperStatus)[keyof typeof TamperStatus]

}

export type BillStatus = $Enums.BillStatus

export const BillStatus: typeof $Enums.BillStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type IdType = $Enums.IdType

export const IdType: typeof $Enums.IdType

export type ConnectionType = $Enums.ConnectionType

export const ConnectionType: typeof $Enums.ConnectionType

export type ConsumerCategory = $Enums.ConsumerCategory

export const ConsumerCategory: typeof $Enums.ConsumerCategory

export type BillingCycle = $Enums.BillingCycle

export const BillingCycle: typeof $Enums.BillingCycle

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type BillDeliveryMode = $Enums.BillDeliveryMode

export const BillDeliveryMode: typeof $Enums.BillDeliveryMode

export type FaultType = $Enums.FaultType

export const FaultType: typeof $Enums.FaultType

export type FaultSeverity = $Enums.FaultSeverity

export const FaultSeverity: typeof $Enums.FaultSeverity

export type FaultStatus = $Enums.FaultStatus

export const FaultStatus: typeof $Enums.FaultStatus

export type MaintenanceType = $Enums.MaintenanceType

export const MaintenanceType: typeof $Enums.MaintenanceType

export type MaintenanceStatus = $Enums.MaintenanceStatus

export const MaintenanceStatus: typeof $Enums.MaintenanceStatus

export type DTRReadingType = $Enums.DTRReadingType

export const DTRReadingType: typeof $Enums.DTRReadingType

export type DTRType = $Enums.DTRType

export const DTRType: typeof $Enums.DTRType

export type CoolingType = $Enums.CoolingType

export const CoolingType: typeof $Enums.CoolingType

export type OilType = $Enums.OilType

export const OilType: typeof $Enums.OilType

export type DTRStatus = $Enums.DTRStatus

export const DTRStatus: typeof $Enums.DTRStatus

export type ReadingType = $Enums.ReadingType

export const ReadingType: typeof $Enums.ReadingType

export type ReadingSource = $Enums.ReadingSource

export const ReadingSource: typeof $Enums.ReadingSource

export type MeterType = $Enums.MeterType

export const MeterType: typeof $Enums.MeterType

export type MeterStatus = $Enums.MeterStatus

export const MeterStatus: typeof $Enums.MeterStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationPriority = $Enums.NotificationPriority

export const NotificationPriority: typeof $Enums.NotificationPriority

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type NotificationChannel = $Enums.NotificationChannel

export const NotificationChannel: typeof $Enums.NotificationChannel

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type AccessLevel = $Enums.AccessLevel

export const AccessLevel: typeof $Enums.AccessLevel

export type TicketType = $Enums.TicketType

export const TicketType: typeof $Enums.TicketType

export type TicketCategory = $Enums.TicketCategory

export const TicketCategory: typeof $Enums.TicketCategory

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type PrepaidAlertType = $Enums.PrepaidAlertType

export const PrepaidAlertType: typeof $Enums.PrepaidAlertType

export type PrepaidAlertLevel = $Enums.PrepaidAlertLevel

export const PrepaidAlertLevel: typeof $Enums.PrepaidAlertLevel

export type PrepaidRechargeType = $Enums.PrepaidRechargeType

export const PrepaidRechargeType: typeof $Enums.PrepaidRechargeType

export type PrepaidRechargeSource = $Enums.PrepaidRechargeSource

export const PrepaidRechargeSource: typeof $Enums.PrepaidRechargeSource

export type PrepaidTransactionType = $Enums.PrepaidTransactionType

export const PrepaidTransactionType: typeof $Enums.PrepaidTransactionType

export type PrepaidTransactionStatus = $Enums.PrepaidTransactionStatus

export const PrepaidTransactionStatus: typeof $Enums.PrepaidTransactionStatus

export type TamperType = $Enums.TamperType

export const TamperType: typeof $Enums.TamperType

export type TamperStatus = $Enums.TamperStatus

export const TamperStatus: typeof $Enums.TamperStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bills
 * const bills = await prisma.bills.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bills
   * const bills = await prisma.bills.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.bills`: Exposes CRUD operations for the **bills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bills.findMany()
    * ```
    */
  get bills(): Prisma.billsDelegate<ExtArgs>;

  /**
   * `prisma.consumer_documents`: Exposes CRUD operations for the **consumer_documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consumer_documents
    * const consumer_documents = await prisma.consumer_documents.findMany()
    * ```
    */
  get consumer_documents(): Prisma.consumer_documentsDelegate<ExtArgs>;

  /**
   * `prisma.consumers`: Exposes CRUD operations for the **consumers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consumers
    * const consumers = await prisma.consumers.findMany()
    * ```
    */
  get consumers(): Prisma.consumersDelegate<ExtArgs>;

  /**
   * `prisma.current_transformers`: Exposes CRUD operations for the **current_transformers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Current_transformers
    * const current_transformers = await prisma.current_transformers.findMany()
    * ```
    */
  get current_transformers(): Prisma.current_transformersDelegate<ExtArgs>;

  /**
   * `prisma.departments`: Exposes CRUD operations for the **departments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.departments.findMany()
    * ```
    */
  get departments(): Prisma.departmentsDelegate<ExtArgs>;

  /**
   * `prisma.dtr_faults`: Exposes CRUD operations for the **dtr_faults** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dtr_faults
    * const dtr_faults = await prisma.dtr_faults.findMany()
    * ```
    */
  get dtr_faults(): Prisma.dtr_faultsDelegate<ExtArgs>;

  /**
   * `prisma.dtr_maintenance`: Exposes CRUD operations for the **dtr_maintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dtr_maintenances
    * const dtr_maintenances = await prisma.dtr_maintenance.findMany()
    * ```
    */
  get dtr_maintenance(): Prisma.dtr_maintenanceDelegate<ExtArgs>;

  /**
   * `prisma.dtr_readings`: Exposes CRUD operations for the **dtr_readings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dtr_readings
    * const dtr_readings = await prisma.dtr_readings.findMany()
    * ```
    */
  get dtr_readings(): Prisma.dtr_readingsDelegate<ExtArgs>;

  /**
   * `prisma.dtrs`: Exposes CRUD operations for the **dtrs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dtrs
    * const dtrs = await prisma.dtrs.findMany()
    * ```
    */
  get dtrs(): Prisma.dtrsDelegate<ExtArgs>;

  /**
   * `prisma.location_types`: Exposes CRUD operations for the **location_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Location_types
    * const location_types = await prisma.location_types.findMany()
    * ```
    */
  get location_types(): Prisma.location_typesDelegate<ExtArgs>;

  /**
   * `prisma.locations`: Exposes CRUD operations for the **locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.locations.findMany()
    * ```
    */
  get locations(): Prisma.locationsDelegate<ExtArgs>;

  /**
   * `prisma.login_history`: Exposes CRUD operations for the **login_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Login_histories
    * const login_histories = await prisma.login_history.findMany()
    * ```
    */
  get login_history(): Prisma.login_historyDelegate<ExtArgs>;

  /**
   * `prisma.meter_configurations`: Exposes CRUD operations for the **meter_configurations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meter_configurations
    * const meter_configurations = await prisma.meter_configurations.findMany()
    * ```
    */
  get meter_configurations(): Prisma.meter_configurationsDelegate<ExtArgs>;

  /**
   * `prisma.meter_readings`: Exposes CRUD operations for the **meter_readings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meter_readings
    * const meter_readings = await prisma.meter_readings.findMany()
    * ```
    */
  get meter_readings(): Prisma.meter_readingsDelegate<ExtArgs>;

  /**
   * `prisma.meters`: Exposes CRUD operations for the **meters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meters
    * const meters = await prisma.meters.findMany()
    * ```
    */
  get meters(): Prisma.metersDelegate<ExtArgs>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.permissionsDelegate<ExtArgs>;

  /**
   * `prisma.potential_transformers`: Exposes CRUD operations for the **potential_transformers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Potential_transformers
    * const potential_transformers = await prisma.potential_transformers.findMany()
    * ```
    */
  get potential_transformers(): Prisma.potential_transformersDelegate<ExtArgs>;

  /**
   * `prisma.role_permissions`: Exposes CRUD operations for the **role_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Role_permissions
    * const role_permissions = await prisma.role_permissions.findMany()
    * ```
    */
  get role_permissions(): Prisma.role_permissionsDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs>;

  /**
   * `prisma.tickets`: Exposes CRUD operations for the **tickets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.tickets.findMany()
    * ```
    */
  get tickets(): Prisma.ticketsDelegate<ExtArgs>;

  /**
   * `prisma.user_activity_logs`: Exposes CRUD operations for the **user_activity_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_activity_logs
    * const user_activity_logs = await prisma.user_activity_logs.findMany()
    * ```
    */
  get user_activity_logs(): Prisma.user_activity_logsDelegate<ExtArgs>;

  /**
   * `prisma.user_permissions`: Exposes CRUD operations for the **user_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_permissions
    * const user_permissions = await prisma.user_permissions.findMany()
    * ```
    */
  get user_permissions(): Prisma.user_permissionsDelegate<ExtArgs>;

  /**
   * `prisma.user_sessions`: Exposes CRUD operations for the **user_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_sessions
    * const user_sessions = await prisma.user_sessions.findMany()
    * ```
    */
  get user_sessions(): Prisma.user_sessionsDelegate<ExtArgs>;

  /**
   * `prisma.refresh_tokens`: Exposes CRUD operations for the **refresh_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refresh_tokens
    * const refresh_tokens = await prisma.refresh_tokens.findMany()
    * ```
    */
  get refresh_tokens(): Prisma.refresh_tokensDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.raw_xml_import`: Exposes CRUD operations for the **raw_xml_import** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Raw_xml_imports
    * const raw_xml_imports = await prisma.raw_xml_import.findMany()
    * ```
    */
  get raw_xml_import(): Prisma.raw_xml_importDelegate<ExtArgs>;

  /**
   * `prisma.prepaid_accounts`: Exposes CRUD operations for the **prepaid_accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prepaid_accounts
    * const prepaid_accounts = await prisma.prepaid_accounts.findMany()
    * ```
    */
  get prepaid_accounts(): Prisma.prepaid_accountsDelegate<ExtArgs>;

  /**
   * `prisma.prepaid_alerts`: Exposes CRUD operations for the **prepaid_alerts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prepaid_alerts
    * const prepaid_alerts = await prisma.prepaid_alerts.findMany()
    * ```
    */
  get prepaid_alerts(): Prisma.prepaid_alertsDelegate<ExtArgs>;

  /**
   * `prisma.prepaid_recharges`: Exposes CRUD operations for the **prepaid_recharges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prepaid_recharges
    * const prepaid_recharges = await prisma.prepaid_recharges.findMany()
    * ```
    */
  get prepaid_recharges(): Prisma.prepaid_rechargesDelegate<ExtArgs>;

  /**
   * `prisma.prepaid_transactions`: Exposes CRUD operations for the **prepaid_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prepaid_transactions
    * const prepaid_transactions = await prisma.prepaid_transactions.findMany()
    * ```
    */
  get prepaid_transactions(): Prisma.prepaid_transactionsDelegate<ExtArgs>;

  /**
   * `prisma.tamper_code_desc`: Exposes CRUD operations for the **tamper_code_desc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tamper_code_descs
    * const tamper_code_descs = await prisma.tamper_code_desc.findMany()
    * ```
    */
  get tamper_code_desc(): Prisma.tamper_code_descDelegate<ExtArgs>;

  /**
   * `prisma.tamper_events`: Exposes CRUD operations for the **tamper_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tamper_events
    * const tamper_events = await prisma.tamper_events.findMany()
    * ```
    */
  get tamper_events(): Prisma.tamper_eventsDelegate<ExtArgs>;

  /**
   * `prisma.tariff`: Exposes CRUD operations for the **tariff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tariffs
    * const tariffs = await prisma.tariff.findMany()
    * ```
    */
  get tariff(): Prisma.tariffDelegate<ExtArgs>;

  /**
   * `prisma.tariff_slabs`: Exposes CRUD operations for the **tariff_slabs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tariff_slabs
    * const tariff_slabs = await prisma.tariff_slabs.findMany()
    * ```
    */
  get tariff_slabs(): Prisma.tariff_slabsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    bills: 'bills',
    consumer_documents: 'consumer_documents',
    consumers: 'consumers',
    current_transformers: 'current_transformers',
    departments: 'departments',
    dtr_faults: 'dtr_faults',
    dtr_maintenance: 'dtr_maintenance',
    dtr_readings: 'dtr_readings',
    dtrs: 'dtrs',
    location_types: 'location_types',
    locations: 'locations',
    login_history: 'login_history',
    meter_configurations: 'meter_configurations',
    meter_readings: 'meter_readings',
    meters: 'meters',
    notifications: 'notifications',
    payments: 'payments',
    permissions: 'permissions',
    potential_transformers: 'potential_transformers',
    role_permissions: 'role_permissions',
    roles: 'roles',
    tickets: 'tickets',
    user_activity_logs: 'user_activity_logs',
    user_permissions: 'user_permissions',
    user_sessions: 'user_sessions',
    refresh_tokens: 'refresh_tokens',
    users: 'users',
    raw_xml_import: 'raw_xml_import',
    prepaid_accounts: 'prepaid_accounts',
    prepaid_alerts: 'prepaid_alerts',
    prepaid_recharges: 'prepaid_recharges',
    prepaid_transactions: 'prepaid_transactions',
    tamper_code_desc: 'tamper_code_desc',
    tamper_events: 'tamper_events',
    tariff: 'tariff',
    tariff_slabs: 'tariff_slabs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "bills" | "consumer_documents" | "consumers" | "current_transformers" | "departments" | "dtr_faults" | "dtr_maintenance" | "dtr_readings" | "dtrs" | "location_types" | "locations" | "login_history" | "meter_configurations" | "meter_readings" | "meters" | "notifications" | "payments" | "permissions" | "potential_transformers" | "role_permissions" | "roles" | "tickets" | "user_activity_logs" | "user_permissions" | "user_sessions" | "refresh_tokens" | "users" | "raw_xml_import" | "prepaid_accounts" | "prepaid_alerts" | "prepaid_recharges" | "prepaid_transactions" | "tamper_code_desc" | "tamper_events" | "tariff" | "tariff_slabs"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      bills: {
        payload: Prisma.$billsPayload<ExtArgs>
        fields: Prisma.billsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.billsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.billsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billsPayload>
          }
          findFirst: {
            args: Prisma.billsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.billsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billsPayload>
          }
          findMany: {
            args: Prisma.billsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billsPayload>[]
          }
          create: {
            args: Prisma.billsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billsPayload>
          }
          createMany: {
            args: Prisma.billsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.billsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billsPayload>[]
          }
          delete: {
            args: Prisma.billsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billsPayload>
          }
          update: {
            args: Prisma.billsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billsPayload>
          }
          deleteMany: {
            args: Prisma.billsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.billsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.billsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billsPayload>
          }
          aggregate: {
            args: Prisma.BillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBills>
          }
          groupBy: {
            args: Prisma.billsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.billsCountArgs<ExtArgs>
            result: $Utils.Optional<BillsCountAggregateOutputType> | number
          }
        }
      }
      consumer_documents: {
        payload: Prisma.$consumer_documentsPayload<ExtArgs>
        fields: Prisma.consumer_documentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consumer_documentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumer_documentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consumer_documentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumer_documentsPayload>
          }
          findFirst: {
            args: Prisma.consumer_documentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumer_documentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consumer_documentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumer_documentsPayload>
          }
          findMany: {
            args: Prisma.consumer_documentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumer_documentsPayload>[]
          }
          create: {
            args: Prisma.consumer_documentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumer_documentsPayload>
          }
          createMany: {
            args: Prisma.consumer_documentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.consumer_documentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumer_documentsPayload>[]
          }
          delete: {
            args: Prisma.consumer_documentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumer_documentsPayload>
          }
          update: {
            args: Prisma.consumer_documentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumer_documentsPayload>
          }
          deleteMany: {
            args: Prisma.consumer_documentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consumer_documentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.consumer_documentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumer_documentsPayload>
          }
          aggregate: {
            args: Prisma.Consumer_documentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsumer_documents>
          }
          groupBy: {
            args: Prisma.consumer_documentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Consumer_documentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.consumer_documentsCountArgs<ExtArgs>
            result: $Utils.Optional<Consumer_documentsCountAggregateOutputType> | number
          }
        }
      }
      consumers: {
        payload: Prisma.$consumersPayload<ExtArgs>
        fields: Prisma.consumersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consumersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consumersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumersPayload>
          }
          findFirst: {
            args: Prisma.consumersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consumersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumersPayload>
          }
          findMany: {
            args: Prisma.consumersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumersPayload>[]
          }
          create: {
            args: Prisma.consumersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumersPayload>
          }
          createMany: {
            args: Prisma.consumersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.consumersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumersPayload>[]
          }
          delete: {
            args: Prisma.consumersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumersPayload>
          }
          update: {
            args: Prisma.consumersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumersPayload>
          }
          deleteMany: {
            args: Prisma.consumersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consumersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.consumersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consumersPayload>
          }
          aggregate: {
            args: Prisma.ConsumersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsumers>
          }
          groupBy: {
            args: Prisma.consumersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsumersGroupByOutputType>[]
          }
          count: {
            args: Prisma.consumersCountArgs<ExtArgs>
            result: $Utils.Optional<ConsumersCountAggregateOutputType> | number
          }
        }
      }
      current_transformers: {
        payload: Prisma.$current_transformersPayload<ExtArgs>
        fields: Prisma.current_transformersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.current_transformersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$current_transformersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.current_transformersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$current_transformersPayload>
          }
          findFirst: {
            args: Prisma.current_transformersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$current_transformersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.current_transformersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$current_transformersPayload>
          }
          findMany: {
            args: Prisma.current_transformersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$current_transformersPayload>[]
          }
          create: {
            args: Prisma.current_transformersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$current_transformersPayload>
          }
          createMany: {
            args: Prisma.current_transformersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.current_transformersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$current_transformersPayload>[]
          }
          delete: {
            args: Prisma.current_transformersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$current_transformersPayload>
          }
          update: {
            args: Prisma.current_transformersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$current_transformersPayload>
          }
          deleteMany: {
            args: Prisma.current_transformersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.current_transformersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.current_transformersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$current_transformersPayload>
          }
          aggregate: {
            args: Prisma.Current_transformersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrent_transformers>
          }
          groupBy: {
            args: Prisma.current_transformersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Current_transformersGroupByOutputType>[]
          }
          count: {
            args: Prisma.current_transformersCountArgs<ExtArgs>
            result: $Utils.Optional<Current_transformersCountAggregateOutputType> | number
          }
        }
      }
      departments: {
        payload: Prisma.$departmentsPayload<ExtArgs>
        fields: Prisma.departmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.departmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.departmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          findFirst: {
            args: Prisma.departmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.departmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          findMany: {
            args: Prisma.departmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>[]
          }
          create: {
            args: Prisma.departmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          createMany: {
            args: Prisma.departmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.departmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>[]
          }
          delete: {
            args: Prisma.departmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          update: {
            args: Prisma.departmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          deleteMany: {
            args: Prisma.departmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.departmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.departmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          aggregate: {
            args: Prisma.DepartmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartments>
          }
          groupBy: {
            args: Prisma.departmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.departmentsCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentsCountAggregateOutputType> | number
          }
        }
      }
      dtr_faults: {
        payload: Prisma.$dtr_faultsPayload<ExtArgs>
        fields: Prisma.dtr_faultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dtr_faultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_faultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dtr_faultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_faultsPayload>
          }
          findFirst: {
            args: Prisma.dtr_faultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_faultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dtr_faultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_faultsPayload>
          }
          findMany: {
            args: Prisma.dtr_faultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_faultsPayload>[]
          }
          create: {
            args: Prisma.dtr_faultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_faultsPayload>
          }
          createMany: {
            args: Prisma.dtr_faultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.dtr_faultsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_faultsPayload>[]
          }
          delete: {
            args: Prisma.dtr_faultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_faultsPayload>
          }
          update: {
            args: Prisma.dtr_faultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_faultsPayload>
          }
          deleteMany: {
            args: Prisma.dtr_faultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dtr_faultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dtr_faultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_faultsPayload>
          }
          aggregate: {
            args: Prisma.Dtr_faultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDtr_faults>
          }
          groupBy: {
            args: Prisma.dtr_faultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Dtr_faultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.dtr_faultsCountArgs<ExtArgs>
            result: $Utils.Optional<Dtr_faultsCountAggregateOutputType> | number
          }
        }
      }
      dtr_maintenance: {
        payload: Prisma.$dtr_maintenancePayload<ExtArgs>
        fields: Prisma.dtr_maintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dtr_maintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_maintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dtr_maintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_maintenancePayload>
          }
          findFirst: {
            args: Prisma.dtr_maintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_maintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dtr_maintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_maintenancePayload>
          }
          findMany: {
            args: Prisma.dtr_maintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_maintenancePayload>[]
          }
          create: {
            args: Prisma.dtr_maintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_maintenancePayload>
          }
          createMany: {
            args: Prisma.dtr_maintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.dtr_maintenanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_maintenancePayload>[]
          }
          delete: {
            args: Prisma.dtr_maintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_maintenancePayload>
          }
          update: {
            args: Prisma.dtr_maintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_maintenancePayload>
          }
          deleteMany: {
            args: Prisma.dtr_maintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dtr_maintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dtr_maintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_maintenancePayload>
          }
          aggregate: {
            args: Prisma.Dtr_maintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDtr_maintenance>
          }
          groupBy: {
            args: Prisma.dtr_maintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Dtr_maintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.dtr_maintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<Dtr_maintenanceCountAggregateOutputType> | number
          }
        }
      }
      dtr_readings: {
        payload: Prisma.$dtr_readingsPayload<ExtArgs>
        fields: Prisma.dtr_readingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dtr_readingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_readingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dtr_readingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_readingsPayload>
          }
          findFirst: {
            args: Prisma.dtr_readingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_readingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dtr_readingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_readingsPayload>
          }
          findMany: {
            args: Prisma.dtr_readingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_readingsPayload>[]
          }
          create: {
            args: Prisma.dtr_readingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_readingsPayload>
          }
          createMany: {
            args: Prisma.dtr_readingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.dtr_readingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_readingsPayload>[]
          }
          delete: {
            args: Prisma.dtr_readingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_readingsPayload>
          }
          update: {
            args: Prisma.dtr_readingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_readingsPayload>
          }
          deleteMany: {
            args: Prisma.dtr_readingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dtr_readingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dtr_readingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtr_readingsPayload>
          }
          aggregate: {
            args: Prisma.Dtr_readingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDtr_readings>
          }
          groupBy: {
            args: Prisma.dtr_readingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Dtr_readingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.dtr_readingsCountArgs<ExtArgs>
            result: $Utils.Optional<Dtr_readingsCountAggregateOutputType> | number
          }
        }
      }
      dtrs: {
        payload: Prisma.$dtrsPayload<ExtArgs>
        fields: Prisma.dtrsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dtrsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtrsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dtrsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtrsPayload>
          }
          findFirst: {
            args: Prisma.dtrsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtrsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dtrsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtrsPayload>
          }
          findMany: {
            args: Prisma.dtrsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtrsPayload>[]
          }
          create: {
            args: Prisma.dtrsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtrsPayload>
          }
          createMany: {
            args: Prisma.dtrsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.dtrsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtrsPayload>[]
          }
          delete: {
            args: Prisma.dtrsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtrsPayload>
          }
          update: {
            args: Prisma.dtrsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtrsPayload>
          }
          deleteMany: {
            args: Prisma.dtrsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dtrsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dtrsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dtrsPayload>
          }
          aggregate: {
            args: Prisma.DtrsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDtrs>
          }
          groupBy: {
            args: Prisma.dtrsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DtrsGroupByOutputType>[]
          }
          count: {
            args: Prisma.dtrsCountArgs<ExtArgs>
            result: $Utils.Optional<DtrsCountAggregateOutputType> | number
          }
        }
      }
      location_types: {
        payload: Prisma.$location_typesPayload<ExtArgs>
        fields: Prisma.location_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.location_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.location_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_typesPayload>
          }
          findFirst: {
            args: Prisma.location_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.location_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_typesPayload>
          }
          findMany: {
            args: Prisma.location_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_typesPayload>[]
          }
          create: {
            args: Prisma.location_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_typesPayload>
          }
          createMany: {
            args: Prisma.location_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.location_typesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_typesPayload>[]
          }
          delete: {
            args: Prisma.location_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_typesPayload>
          }
          update: {
            args: Prisma.location_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_typesPayload>
          }
          deleteMany: {
            args: Prisma.location_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.location_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.location_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$location_typesPayload>
          }
          aggregate: {
            args: Prisma.Location_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation_types>
          }
          groupBy: {
            args: Prisma.location_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Location_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.location_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Location_typesCountAggregateOutputType> | number
          }
        }
      }
      locations: {
        payload: Prisma.$locationsPayload<ExtArgs>
        fields: Prisma.locationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.locationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.locationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          findFirst: {
            args: Prisma.locationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.locationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          findMany: {
            args: Prisma.locationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>[]
          }
          create: {
            args: Prisma.locationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          createMany: {
            args: Prisma.locationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.locationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>[]
          }
          delete: {
            args: Prisma.locationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          update: {
            args: Prisma.locationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          deleteMany: {
            args: Prisma.locationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.locationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.locationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          aggregate: {
            args: Prisma.LocationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocations>
          }
          groupBy: {
            args: Prisma.locationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.locationsCountArgs<ExtArgs>
            result: $Utils.Optional<LocationsCountAggregateOutputType> | number
          }
        }
      }
      login_history: {
        payload: Prisma.$login_historyPayload<ExtArgs>
        fields: Prisma.login_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.login_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.login_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          findFirst: {
            args: Prisma.login_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.login_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          findMany: {
            args: Prisma.login_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>[]
          }
          create: {
            args: Prisma.login_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          createMany: {
            args: Prisma.login_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.login_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>[]
          }
          delete: {
            args: Prisma.login_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          update: {
            args: Prisma.login_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          deleteMany: {
            args: Prisma.login_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.login_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.login_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          aggregate: {
            args: Prisma.Login_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogin_history>
          }
          groupBy: {
            args: Prisma.login_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Login_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.login_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Login_historyCountAggregateOutputType> | number
          }
        }
      }
      meter_configurations: {
        payload: Prisma.$meter_configurationsPayload<ExtArgs>
        fields: Prisma.meter_configurationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.meter_configurationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_configurationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.meter_configurationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_configurationsPayload>
          }
          findFirst: {
            args: Prisma.meter_configurationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_configurationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.meter_configurationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_configurationsPayload>
          }
          findMany: {
            args: Prisma.meter_configurationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_configurationsPayload>[]
          }
          create: {
            args: Prisma.meter_configurationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_configurationsPayload>
          }
          createMany: {
            args: Prisma.meter_configurationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.meter_configurationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_configurationsPayload>[]
          }
          delete: {
            args: Prisma.meter_configurationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_configurationsPayload>
          }
          update: {
            args: Prisma.meter_configurationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_configurationsPayload>
          }
          deleteMany: {
            args: Prisma.meter_configurationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.meter_configurationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.meter_configurationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_configurationsPayload>
          }
          aggregate: {
            args: Prisma.Meter_configurationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeter_configurations>
          }
          groupBy: {
            args: Prisma.meter_configurationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Meter_configurationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.meter_configurationsCountArgs<ExtArgs>
            result: $Utils.Optional<Meter_configurationsCountAggregateOutputType> | number
          }
        }
      }
      meter_readings: {
        payload: Prisma.$meter_readingsPayload<ExtArgs>
        fields: Prisma.meter_readingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.meter_readingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_readingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.meter_readingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_readingsPayload>
          }
          findFirst: {
            args: Prisma.meter_readingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_readingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.meter_readingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_readingsPayload>
          }
          findMany: {
            args: Prisma.meter_readingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_readingsPayload>[]
          }
          create: {
            args: Prisma.meter_readingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_readingsPayload>
          }
          createMany: {
            args: Prisma.meter_readingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.meter_readingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_readingsPayload>[]
          }
          delete: {
            args: Prisma.meter_readingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_readingsPayload>
          }
          update: {
            args: Prisma.meter_readingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_readingsPayload>
          }
          deleteMany: {
            args: Prisma.meter_readingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.meter_readingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.meter_readingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meter_readingsPayload>
          }
          aggregate: {
            args: Prisma.Meter_readingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeter_readings>
          }
          groupBy: {
            args: Prisma.meter_readingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Meter_readingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.meter_readingsCountArgs<ExtArgs>
            result: $Utils.Optional<Meter_readingsCountAggregateOutputType> | number
          }
        }
      }
      meters: {
        payload: Prisma.$metersPayload<ExtArgs>
        fields: Prisma.metersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.metersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.metersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          findFirst: {
            args: Prisma.metersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.metersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          findMany: {
            args: Prisma.metersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>[]
          }
          create: {
            args: Prisma.metersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          createMany: {
            args: Prisma.metersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.metersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>[]
          }
          delete: {
            args: Prisma.metersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          update: {
            args: Prisma.metersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          deleteMany: {
            args: Prisma.metersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.metersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.metersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metersPayload>
          }
          aggregate: {
            args: Prisma.MetersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeters>
          }
          groupBy: {
            args: Prisma.metersGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetersGroupByOutputType>[]
          }
          count: {
            args: Prisma.metersCountArgs<ExtArgs>
            result: $Utils.Optional<MetersCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      permissions: {
        payload: Prisma.$permissionsPayload<ExtArgs>
        fields: Prisma.permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findFirst: {
            args: Prisma.permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findMany: {
            args: Prisma.permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[]
          }
          create: {
            args: Prisma.permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          createMany: {
            args: Prisma.permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.permissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[]
          }
          delete: {
            args: Prisma.permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          update: {
            args: Prisma.permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          deleteMany: {
            args: Prisma.permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissions>
          }
          groupBy: {
            args: Prisma.permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionsCountAggregateOutputType> | number
          }
        }
      }
      potential_transformers: {
        payload: Prisma.$potential_transformersPayload<ExtArgs>
        fields: Prisma.potential_transformersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.potential_transformersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$potential_transformersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.potential_transformersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$potential_transformersPayload>
          }
          findFirst: {
            args: Prisma.potential_transformersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$potential_transformersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.potential_transformersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$potential_transformersPayload>
          }
          findMany: {
            args: Prisma.potential_transformersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$potential_transformersPayload>[]
          }
          create: {
            args: Prisma.potential_transformersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$potential_transformersPayload>
          }
          createMany: {
            args: Prisma.potential_transformersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.potential_transformersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$potential_transformersPayload>[]
          }
          delete: {
            args: Prisma.potential_transformersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$potential_transformersPayload>
          }
          update: {
            args: Prisma.potential_transformersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$potential_transformersPayload>
          }
          deleteMany: {
            args: Prisma.potential_transformersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.potential_transformersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.potential_transformersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$potential_transformersPayload>
          }
          aggregate: {
            args: Prisma.Potential_transformersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePotential_transformers>
          }
          groupBy: {
            args: Prisma.potential_transformersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Potential_transformersGroupByOutputType>[]
          }
          count: {
            args: Prisma.potential_transformersCountArgs<ExtArgs>
            result: $Utils.Optional<Potential_transformersCountAggregateOutputType> | number
          }
        }
      }
      role_permissions: {
        payload: Prisma.$role_permissionsPayload<ExtArgs>
        fields: Prisma.role_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.role_permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.role_permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          findFirst: {
            args: Prisma.role_permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.role_permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          findMany: {
            args: Prisma.role_permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>[]
          }
          create: {
            args: Prisma.role_permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          createMany: {
            args: Prisma.role_permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.role_permissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>[]
          }
          delete: {
            args: Prisma.role_permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          update: {
            args: Prisma.role_permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.role_permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.role_permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.role_permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Role_permissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole_permissions>
          }
          groupBy: {
            args: Prisma.role_permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Role_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.role_permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Role_permissionsCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      tickets: {
        payload: Prisma.$ticketsPayload<ExtArgs>
        fields: Prisma.ticketsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ticketsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ticketsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          findFirst: {
            args: Prisma.ticketsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ticketsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          findMany: {
            args: Prisma.ticketsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>[]
          }
          create: {
            args: Prisma.ticketsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          createMany: {
            args: Prisma.ticketsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ticketsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>[]
          }
          delete: {
            args: Prisma.ticketsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          update: {
            args: Prisma.ticketsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          deleteMany: {
            args: Prisma.ticketsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ticketsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ticketsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          aggregate: {
            args: Prisma.TicketsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTickets>
          }
          groupBy: {
            args: Prisma.ticketsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ticketsCountArgs<ExtArgs>
            result: $Utils.Optional<TicketsCountAggregateOutputType> | number
          }
        }
      }
      user_activity_logs: {
        payload: Prisma.$user_activity_logsPayload<ExtArgs>
        fields: Prisma.user_activity_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_activity_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activity_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_activity_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activity_logsPayload>
          }
          findFirst: {
            args: Prisma.user_activity_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activity_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_activity_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activity_logsPayload>
          }
          findMany: {
            args: Prisma.user_activity_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activity_logsPayload>[]
          }
          create: {
            args: Prisma.user_activity_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activity_logsPayload>
          }
          createMany: {
            args: Prisma.user_activity_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_activity_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activity_logsPayload>[]
          }
          delete: {
            args: Prisma.user_activity_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activity_logsPayload>
          }
          update: {
            args: Prisma.user_activity_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activity_logsPayload>
          }
          deleteMany: {
            args: Prisma.user_activity_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_activity_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_activity_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activity_logsPayload>
          }
          aggregate: {
            args: Prisma.User_activity_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_activity_logs>
          }
          groupBy: {
            args: Prisma.user_activity_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_activity_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_activity_logsCountArgs<ExtArgs>
            result: $Utils.Optional<User_activity_logsCountAggregateOutputType> | number
          }
        }
      }
      user_permissions: {
        payload: Prisma.$user_permissionsPayload<ExtArgs>
        fields: Prisma.user_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          findFirst: {
            args: Prisma.user_permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          findMany: {
            args: Prisma.user_permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>[]
          }
          create: {
            args: Prisma.user_permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          createMany: {
            args: Prisma.user_permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_permissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>[]
          }
          delete: {
            args: Prisma.user_permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          update: {
            args: Prisma.user_permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.user_permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          aggregate: {
            args: Prisma.User_permissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_permissions>
          }
          groupBy: {
            args: Prisma.user_permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<User_permissionsCountAggregateOutputType> | number
          }
        }
      }
      user_sessions: {
        payload: Prisma.$user_sessionsPayload<ExtArgs>
        fields: Prisma.user_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionsPayload>
          }
          findFirst: {
            args: Prisma.user_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionsPayload>
          }
          findMany: {
            args: Prisma.user_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionsPayload>[]
          }
          create: {
            args: Prisma.user_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionsPayload>
          }
          createMany: {
            args: Prisma.user_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionsPayload>[]
          }
          delete: {
            args: Prisma.user_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionsPayload>
          }
          update: {
            args: Prisma.user_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.user_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_sessionsPayload>
          }
          aggregate: {
            args: Prisma.User_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_sessions>
          }
          groupBy: {
            args: Prisma.user_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<User_sessionsCountAggregateOutputType> | number
          }
        }
      }
      refresh_tokens: {
        payload: Prisma.$refresh_tokensPayload<ExtArgs>
        fields: Prisma.refresh_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.refresh_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.refresh_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          findFirst: {
            args: Prisma.refresh_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.refresh_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          findMany: {
            args: Prisma.refresh_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>[]
          }
          create: {
            args: Prisma.refresh_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          createMany: {
            args: Prisma.refresh_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.refresh_tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>[]
          }
          delete: {
            args: Prisma.refresh_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          update: {
            args: Prisma.refresh_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          deleteMany: {
            args: Prisma.refresh_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.refresh_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.refresh_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refresh_tokensPayload>
          }
          aggregate: {
            args: Prisma.Refresh_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefresh_tokens>
          }
          groupBy: {
            args: Prisma.refresh_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Refresh_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.refresh_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Refresh_tokensCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      raw_xml_import: {
        payload: Prisma.$raw_xml_importPayload<ExtArgs>
        fields: Prisma.raw_xml_importFieldRefs
        operations: {
          findUnique: {
            args: Prisma.raw_xml_importFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_xml_importPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.raw_xml_importFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_xml_importPayload>
          }
          findFirst: {
            args: Prisma.raw_xml_importFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_xml_importPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.raw_xml_importFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_xml_importPayload>
          }
          findMany: {
            args: Prisma.raw_xml_importFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_xml_importPayload>[]
          }
          create: {
            args: Prisma.raw_xml_importCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_xml_importPayload>
          }
          createMany: {
            args: Prisma.raw_xml_importCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.raw_xml_importCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_xml_importPayload>[]
          }
          delete: {
            args: Prisma.raw_xml_importDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_xml_importPayload>
          }
          update: {
            args: Prisma.raw_xml_importUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_xml_importPayload>
          }
          deleteMany: {
            args: Prisma.raw_xml_importDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.raw_xml_importUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.raw_xml_importUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raw_xml_importPayload>
          }
          aggregate: {
            args: Prisma.Raw_xml_importAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaw_xml_import>
          }
          groupBy: {
            args: Prisma.raw_xml_importGroupByArgs<ExtArgs>
            result: $Utils.Optional<Raw_xml_importGroupByOutputType>[]
          }
          count: {
            args: Prisma.raw_xml_importCountArgs<ExtArgs>
            result: $Utils.Optional<Raw_xml_importCountAggregateOutputType> | number
          }
        }
      }
      prepaid_accounts: {
        payload: Prisma.$prepaid_accountsPayload<ExtArgs>
        fields: Prisma.prepaid_accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prepaid_accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prepaid_accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_accountsPayload>
          }
          findFirst: {
            args: Prisma.prepaid_accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prepaid_accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_accountsPayload>
          }
          findMany: {
            args: Prisma.prepaid_accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_accountsPayload>[]
          }
          create: {
            args: Prisma.prepaid_accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_accountsPayload>
          }
          createMany: {
            args: Prisma.prepaid_accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.prepaid_accountsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_accountsPayload>[]
          }
          delete: {
            args: Prisma.prepaid_accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_accountsPayload>
          }
          update: {
            args: Prisma.prepaid_accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_accountsPayload>
          }
          deleteMany: {
            args: Prisma.prepaid_accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prepaid_accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.prepaid_accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_accountsPayload>
          }
          aggregate: {
            args: Prisma.Prepaid_accountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrepaid_accounts>
          }
          groupBy: {
            args: Prisma.prepaid_accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Prepaid_accountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.prepaid_accountsCountArgs<ExtArgs>
            result: $Utils.Optional<Prepaid_accountsCountAggregateOutputType> | number
          }
        }
      }
      prepaid_alerts: {
        payload: Prisma.$prepaid_alertsPayload<ExtArgs>
        fields: Prisma.prepaid_alertsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prepaid_alertsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_alertsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prepaid_alertsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_alertsPayload>
          }
          findFirst: {
            args: Prisma.prepaid_alertsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_alertsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prepaid_alertsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_alertsPayload>
          }
          findMany: {
            args: Prisma.prepaid_alertsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_alertsPayload>[]
          }
          create: {
            args: Prisma.prepaid_alertsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_alertsPayload>
          }
          createMany: {
            args: Prisma.prepaid_alertsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.prepaid_alertsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_alertsPayload>[]
          }
          delete: {
            args: Prisma.prepaid_alertsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_alertsPayload>
          }
          update: {
            args: Prisma.prepaid_alertsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_alertsPayload>
          }
          deleteMany: {
            args: Prisma.prepaid_alertsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prepaid_alertsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.prepaid_alertsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_alertsPayload>
          }
          aggregate: {
            args: Prisma.Prepaid_alertsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrepaid_alerts>
          }
          groupBy: {
            args: Prisma.prepaid_alertsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Prepaid_alertsGroupByOutputType>[]
          }
          count: {
            args: Prisma.prepaid_alertsCountArgs<ExtArgs>
            result: $Utils.Optional<Prepaid_alertsCountAggregateOutputType> | number
          }
        }
      }
      prepaid_recharges: {
        payload: Prisma.$prepaid_rechargesPayload<ExtArgs>
        fields: Prisma.prepaid_rechargesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prepaid_rechargesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_rechargesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prepaid_rechargesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_rechargesPayload>
          }
          findFirst: {
            args: Prisma.prepaid_rechargesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_rechargesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prepaid_rechargesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_rechargesPayload>
          }
          findMany: {
            args: Prisma.prepaid_rechargesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_rechargesPayload>[]
          }
          create: {
            args: Prisma.prepaid_rechargesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_rechargesPayload>
          }
          createMany: {
            args: Prisma.prepaid_rechargesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.prepaid_rechargesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_rechargesPayload>[]
          }
          delete: {
            args: Prisma.prepaid_rechargesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_rechargesPayload>
          }
          update: {
            args: Prisma.prepaid_rechargesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_rechargesPayload>
          }
          deleteMany: {
            args: Prisma.prepaid_rechargesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prepaid_rechargesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.prepaid_rechargesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_rechargesPayload>
          }
          aggregate: {
            args: Prisma.Prepaid_rechargesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrepaid_recharges>
          }
          groupBy: {
            args: Prisma.prepaid_rechargesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Prepaid_rechargesGroupByOutputType>[]
          }
          count: {
            args: Prisma.prepaid_rechargesCountArgs<ExtArgs>
            result: $Utils.Optional<Prepaid_rechargesCountAggregateOutputType> | number
          }
        }
      }
      prepaid_transactions: {
        payload: Prisma.$prepaid_transactionsPayload<ExtArgs>
        fields: Prisma.prepaid_transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prepaid_transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prepaid_transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_transactionsPayload>
          }
          findFirst: {
            args: Prisma.prepaid_transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prepaid_transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_transactionsPayload>
          }
          findMany: {
            args: Prisma.prepaid_transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_transactionsPayload>[]
          }
          create: {
            args: Prisma.prepaid_transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_transactionsPayload>
          }
          createMany: {
            args: Prisma.prepaid_transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.prepaid_transactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_transactionsPayload>[]
          }
          delete: {
            args: Prisma.prepaid_transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_transactionsPayload>
          }
          update: {
            args: Prisma.prepaid_transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_transactionsPayload>
          }
          deleteMany: {
            args: Prisma.prepaid_transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prepaid_transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.prepaid_transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prepaid_transactionsPayload>
          }
          aggregate: {
            args: Prisma.Prepaid_transactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrepaid_transactions>
          }
          groupBy: {
            args: Prisma.prepaid_transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Prepaid_transactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.prepaid_transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<Prepaid_transactionsCountAggregateOutputType> | number
          }
        }
      }
      tamper_code_desc: {
        payload: Prisma.$tamper_code_descPayload<ExtArgs>
        fields: Prisma.tamper_code_descFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tamper_code_descFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_code_descPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tamper_code_descFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_code_descPayload>
          }
          findFirst: {
            args: Prisma.tamper_code_descFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_code_descPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tamper_code_descFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_code_descPayload>
          }
          findMany: {
            args: Prisma.tamper_code_descFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_code_descPayload>[]
          }
          create: {
            args: Prisma.tamper_code_descCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_code_descPayload>
          }
          createMany: {
            args: Prisma.tamper_code_descCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tamper_code_descCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_code_descPayload>[]
          }
          delete: {
            args: Prisma.tamper_code_descDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_code_descPayload>
          }
          update: {
            args: Prisma.tamper_code_descUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_code_descPayload>
          }
          deleteMany: {
            args: Prisma.tamper_code_descDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tamper_code_descUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tamper_code_descUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_code_descPayload>
          }
          aggregate: {
            args: Prisma.Tamper_code_descAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTamper_code_desc>
          }
          groupBy: {
            args: Prisma.tamper_code_descGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tamper_code_descGroupByOutputType>[]
          }
          count: {
            args: Prisma.tamper_code_descCountArgs<ExtArgs>
            result: $Utils.Optional<Tamper_code_descCountAggregateOutputType> | number
          }
        }
      }
      tamper_events: {
        payload: Prisma.$tamper_eventsPayload<ExtArgs>
        fields: Prisma.tamper_eventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tamper_eventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tamper_eventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_eventsPayload>
          }
          findFirst: {
            args: Prisma.tamper_eventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tamper_eventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_eventsPayload>
          }
          findMany: {
            args: Prisma.tamper_eventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_eventsPayload>[]
          }
          create: {
            args: Prisma.tamper_eventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_eventsPayload>
          }
          createMany: {
            args: Prisma.tamper_eventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tamper_eventsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_eventsPayload>[]
          }
          delete: {
            args: Prisma.tamper_eventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_eventsPayload>
          }
          update: {
            args: Prisma.tamper_eventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_eventsPayload>
          }
          deleteMany: {
            args: Prisma.tamper_eventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tamper_eventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tamper_eventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tamper_eventsPayload>
          }
          aggregate: {
            args: Prisma.Tamper_eventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTamper_events>
          }
          groupBy: {
            args: Prisma.tamper_eventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tamper_eventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tamper_eventsCountArgs<ExtArgs>
            result: $Utils.Optional<Tamper_eventsCountAggregateOutputType> | number
          }
        }
      }
      tariff: {
        payload: Prisma.$tariffPayload<ExtArgs>
        fields: Prisma.tariffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tariffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tariffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariffPayload>
          }
          findFirst: {
            args: Prisma.tariffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tariffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariffPayload>
          }
          findMany: {
            args: Prisma.tariffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariffPayload>[]
          }
          create: {
            args: Prisma.tariffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariffPayload>
          }
          createMany: {
            args: Prisma.tariffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tariffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariffPayload>[]
          }
          delete: {
            args: Prisma.tariffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariffPayload>
          }
          update: {
            args: Prisma.tariffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariffPayload>
          }
          deleteMany: {
            args: Prisma.tariffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tariffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tariffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariffPayload>
          }
          aggregate: {
            args: Prisma.TariffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTariff>
          }
          groupBy: {
            args: Prisma.tariffGroupByArgs<ExtArgs>
            result: $Utils.Optional<TariffGroupByOutputType>[]
          }
          count: {
            args: Prisma.tariffCountArgs<ExtArgs>
            result: $Utils.Optional<TariffCountAggregateOutputType> | number
          }
        }
      }
      tariff_slabs: {
        payload: Prisma.$tariff_slabsPayload<ExtArgs>
        fields: Prisma.tariff_slabsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tariff_slabsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariff_slabsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tariff_slabsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariff_slabsPayload>
          }
          findFirst: {
            args: Prisma.tariff_slabsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariff_slabsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tariff_slabsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariff_slabsPayload>
          }
          findMany: {
            args: Prisma.tariff_slabsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariff_slabsPayload>[]
          }
          create: {
            args: Prisma.tariff_slabsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariff_slabsPayload>
          }
          createMany: {
            args: Prisma.tariff_slabsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tariff_slabsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariff_slabsPayload>[]
          }
          delete: {
            args: Prisma.tariff_slabsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariff_slabsPayload>
          }
          update: {
            args: Prisma.tariff_slabsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariff_slabsPayload>
          }
          deleteMany: {
            args: Prisma.tariff_slabsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tariff_slabsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tariff_slabsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tariff_slabsPayload>
          }
          aggregate: {
            args: Prisma.Tariff_slabsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTariff_slabs>
          }
          groupBy: {
            args: Prisma.tariff_slabsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tariff_slabsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tariff_slabsCountArgs<ExtArgs>
            result: $Utils.Optional<Tariff_slabsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BillsCountOutputType
   */

  export type BillsCountOutputType = {
    meter_readings: number
    payments: number
  }

  export type BillsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meter_readings?: boolean | BillsCountOutputTypeCountMeter_readingsArgs
    payments?: boolean | BillsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * BillsCountOutputType without action
   */
  export type BillsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillsCountOutputType
     */
    select?: BillsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillsCountOutputType without action
   */
  export type BillsCountOutputTypeCountMeter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meter_readingsWhereInput
  }

  /**
   * BillsCountOutputType without action
   */
  export type BillsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type ConsumersCountOutputType
   */

  export type ConsumersCountOutputType = {
    bills: number
    consumer_documents: number
    notifications: number
  }

  export type ConsumersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | ConsumersCountOutputTypeCountBillsArgs
    consumer_documents?: boolean | ConsumersCountOutputTypeCountConsumer_documentsArgs
    notifications?: boolean | ConsumersCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * ConsumersCountOutputType without action
   */
  export type ConsumersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumersCountOutputType
     */
    select?: ConsumersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConsumersCountOutputType without action
   */
  export type ConsumersCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: billsWhereInput
  }

  /**
   * ConsumersCountOutputType without action
   */
  export type ConsumersCountOutputTypeCountConsumer_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consumer_documentsWhereInput
  }

  /**
   * ConsumersCountOutputType without action
   */
  export type ConsumersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }


  /**
   * Count Type DepartmentsCountOutputType
   */

  export type DepartmentsCountOutputType = {
    children: number
    users: number
  }

  export type DepartmentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | DepartmentsCountOutputTypeCountChildrenArgs
    users?: boolean | DepartmentsCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * DepartmentsCountOutputType without action
   */
  export type DepartmentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentsCountOutputType
     */
    select?: DepartmentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentsCountOutputType without action
   */
  export type DepartmentsCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentsWhereInput
  }

  /**
   * DepartmentsCountOutputType without action
   */
  export type DepartmentsCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type DtrsCountOutputType
   */

  export type DtrsCountOutputType = {
    dtr_faults: number
    dtr_maintenance: number
    dtr_readings: number
    meters: number
    tickets: number
  }

  export type DtrsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dtr_faults?: boolean | DtrsCountOutputTypeCountDtr_faultsArgs
    dtr_maintenance?: boolean | DtrsCountOutputTypeCountDtr_maintenanceArgs
    dtr_readings?: boolean | DtrsCountOutputTypeCountDtr_readingsArgs
    meters?: boolean | DtrsCountOutputTypeCountMetersArgs
    tickets?: boolean | DtrsCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * DtrsCountOutputType without action
   */
  export type DtrsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtrsCountOutputType
     */
    select?: DtrsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DtrsCountOutputType without action
   */
  export type DtrsCountOutputTypeCountDtr_faultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dtr_faultsWhereInput
  }

  /**
   * DtrsCountOutputType without action
   */
  export type DtrsCountOutputTypeCountDtr_maintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dtr_maintenanceWhereInput
  }

  /**
   * DtrsCountOutputType without action
   */
  export type DtrsCountOutputTypeCountDtr_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dtr_readingsWhereInput
  }

  /**
   * DtrsCountOutputType without action
   */
  export type DtrsCountOutputTypeCountMetersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: metersWhereInput
  }

  /**
   * DtrsCountOutputType without action
   */
  export type DtrsCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ticketsWhereInput
  }


  /**
   * Count Type Location_typesCountOutputType
   */

  export type Location_typesCountOutputType = {
    locations: number
  }

  export type Location_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | Location_typesCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes
  /**
   * Location_typesCountOutputType without action
   */
  export type Location_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location_typesCountOutputType
     */
    select?: Location_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Location_typesCountOutputType without action
   */
  export type Location_typesCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationsWhereInput
  }


  /**
   * Count Type LocationsCountOutputType
   */

  export type LocationsCountOutputType = {
    dtrs: number
    other_locations: number
    meters: number
    users: number
  }

  export type LocationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dtrs?: boolean | LocationsCountOutputTypeCountDtrsArgs
    other_locations?: boolean | LocationsCountOutputTypeCountOther_locationsArgs
    meters?: boolean | LocationsCountOutputTypeCountMetersArgs
    users?: boolean | LocationsCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * LocationsCountOutputType without action
   */
  export type LocationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationsCountOutputType
     */
    select?: LocationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationsCountOutputType without action
   */
  export type LocationsCountOutputTypeCountDtrsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dtrsWhereInput
  }

  /**
   * LocationsCountOutputType without action
   */
  export type LocationsCountOutputTypeCountOther_locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationsWhereInput
  }

  /**
   * LocationsCountOutputType without action
   */
  export type LocationsCountOutputTypeCountMetersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: metersWhereInput
  }

  /**
   * LocationsCountOutputType without action
   */
  export type LocationsCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type Meter_readingsCountOutputType
   */

  export type Meter_readingsCountOutputType = {
    prepaid_transactions: number
  }

  export type Meter_readingsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prepaid_transactions?: boolean | Meter_readingsCountOutputTypeCountPrepaid_transactionsArgs
  }

  // Custom InputTypes
  /**
   * Meter_readingsCountOutputType without action
   */
  export type Meter_readingsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meter_readingsCountOutputType
     */
    select?: Meter_readingsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Meter_readingsCountOutputType without action
   */
  export type Meter_readingsCountOutputTypeCountPrepaid_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prepaid_transactionsWhereInput
  }


  /**
   * Count Type MetersCountOutputType
   */

  export type MetersCountOutputType = {
    bills: number
    current_transformers: number
    meter_readings: number
    potential_transformers: number
    tamper_events: number
  }

  export type MetersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | MetersCountOutputTypeCountBillsArgs
    current_transformers?: boolean | MetersCountOutputTypeCountCurrent_transformersArgs
    meter_readings?: boolean | MetersCountOutputTypeCountMeter_readingsArgs
    potential_transformers?: boolean | MetersCountOutputTypeCountPotential_transformersArgs
    tamper_events?: boolean | MetersCountOutputTypeCountTamper_eventsArgs
  }

  // Custom InputTypes
  /**
   * MetersCountOutputType without action
   */
  export type MetersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetersCountOutputType
     */
    select?: MetersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MetersCountOutputType without action
   */
  export type MetersCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: billsWhereInput
  }

  /**
   * MetersCountOutputType without action
   */
  export type MetersCountOutputTypeCountCurrent_transformersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: current_transformersWhereInput
  }

  /**
   * MetersCountOutputType without action
   */
  export type MetersCountOutputTypeCountMeter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meter_readingsWhereInput
  }

  /**
   * MetersCountOutputType without action
   */
  export type MetersCountOutputTypeCountPotential_transformersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: potential_transformersWhereInput
  }

  /**
   * MetersCountOutputType without action
   */
  export type MetersCountOutputTypeCountTamper_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tamper_eventsWhereInput
  }


  /**
   * Count Type PermissionsCountOutputType
   */

  export type PermissionsCountOutputType = {
    user_permissions: number
  }

  export type PermissionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_permissions?: boolean | PermissionsCountOutputTypeCountUser_permissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionsCountOutputType
     */
    select?: PermissionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeCountUser_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_permissionsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    role_permissions: number
    users: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role_permissions?: boolean | RolesCountOutputTypeCountRole_permissionsArgs
    users?: boolean | RolesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountRole_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_permissionsWhereInput
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    login_history: number
    tickets_tickets_assignedToIdTousers: number
    tickets_tickets_raisedByIdTousers: number
    user_activity_logs: number
    user_permissions: number
    user_sessions: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    login_history?: boolean | UsersCountOutputTypeCountLogin_historyArgs
    tickets_tickets_assignedToIdTousers?: boolean | UsersCountOutputTypeCountTickets_tickets_assignedToIdTousersArgs
    tickets_tickets_raisedByIdTousers?: boolean | UsersCountOutputTypeCountTickets_tickets_raisedByIdTousersArgs
    user_activity_logs?: boolean | UsersCountOutputTypeCountUser_activity_logsArgs
    user_permissions?: boolean | UsersCountOutputTypeCountUser_permissionsArgs
    user_sessions?: boolean | UsersCountOutputTypeCountUser_sessionsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLogin_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: login_historyWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTickets_tickets_assignedToIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ticketsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTickets_tickets_raisedByIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ticketsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_activity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_activity_logsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_permissionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_sessionsWhereInput
  }


  /**
   * Count Type Prepaid_accountsCountOutputType
   */

  export type Prepaid_accountsCountOutputType = {
    prepaid_alerts: number
    prepaid_recharges: number
    prepaid_transactions: number
  }

  export type Prepaid_accountsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prepaid_alerts?: boolean | Prepaid_accountsCountOutputTypeCountPrepaid_alertsArgs
    prepaid_recharges?: boolean | Prepaid_accountsCountOutputTypeCountPrepaid_rechargesArgs
    prepaid_transactions?: boolean | Prepaid_accountsCountOutputTypeCountPrepaid_transactionsArgs
  }

  // Custom InputTypes
  /**
   * Prepaid_accountsCountOutputType without action
   */
  export type Prepaid_accountsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prepaid_accountsCountOutputType
     */
    select?: Prepaid_accountsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Prepaid_accountsCountOutputType without action
   */
  export type Prepaid_accountsCountOutputTypeCountPrepaid_alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prepaid_alertsWhereInput
  }

  /**
   * Prepaid_accountsCountOutputType without action
   */
  export type Prepaid_accountsCountOutputTypeCountPrepaid_rechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prepaid_rechargesWhereInput
  }

  /**
   * Prepaid_accountsCountOutputType without action
   */
  export type Prepaid_accountsCountOutputTypeCountPrepaid_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prepaid_transactionsWhereInput
  }


  /**
   * Count Type TariffCountOutputType
   */

  export type TariffCountOutputType = {
    tariff_slabs: number
  }

  export type TariffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariff_slabs?: boolean | TariffCountOutputTypeCountTariff_slabsArgs
  }

  // Custom InputTypes
  /**
   * TariffCountOutputType without action
   */
  export type TariffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffCountOutputType
     */
    select?: TariffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TariffCountOutputType without action
   */
  export type TariffCountOutputTypeCountTariff_slabsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tariff_slabsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model bills
   */

  export type AggregateBills = {
    _count: BillsCountAggregateOutputType | null
    _avg: BillsAvgAggregateOutputType | null
    _sum: BillsSumAggregateOutputType | null
    _min: BillsMinAggregateOutputType | null
    _max: BillsMaxAggregateOutputType | null
  }

  export type BillsAvgAggregateOutputType = {
    id: number | null
    meterId: number | null
    consumerId: number | null
    billMonth: number | null
    billYear: number | null
    previousReading: number | null
    currentReading: number | null
    unitsConsumed: number | null
    fixedCharge: number | null
    energyCharge: number | null
    powerFactorCharge: number | null
    subTotal: number | null
    totalAmount: number | null
    paidAmount: number | null
  }

  export type BillsSumAggregateOutputType = {
    id: number | null
    meterId: number | null
    consumerId: number | null
    billMonth: number | null
    billYear: number | null
    previousReading: number | null
    currentReading: number | null
    unitsConsumed: number | null
    fixedCharge: number | null
    energyCharge: number | null
    powerFactorCharge: number | null
    subTotal: number | null
    totalAmount: number | null
    paidAmount: number | null
  }

  export type BillsMinAggregateOutputType = {
    id: number | null
    billNumber: string | null
    meterId: number | null
    consumerId: number | null
    billMonth: number | null
    billYear: number | null
    fromDate: Date | null
    toDate: Date | null
    dueDate: Date | null
    previousReading: number | null
    currentReading: number | null
    unitsConsumed: number | null
    fixedCharge: number | null
    energyCharge: number | null
    powerFactorCharge: number | null
    subTotal: number | null
    totalAmount: number | null
    status: $Enums.BillStatus | null
    isPaid: boolean | null
    paidAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillsMaxAggregateOutputType = {
    id: number | null
    billNumber: string | null
    meterId: number | null
    consumerId: number | null
    billMonth: number | null
    billYear: number | null
    fromDate: Date | null
    toDate: Date | null
    dueDate: Date | null
    previousReading: number | null
    currentReading: number | null
    unitsConsumed: number | null
    fixedCharge: number | null
    energyCharge: number | null
    powerFactorCharge: number | null
    subTotal: number | null
    totalAmount: number | null
    status: $Enums.BillStatus | null
    isPaid: boolean | null
    paidAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillsCountAggregateOutputType = {
    id: number
    billNumber: number
    meterId: number
    consumerId: number
    billMonth: number
    billYear: number
    fromDate: number
    toDate: number
    dueDate: number
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge: number
    otherCharges: number
    subTotal: number
    taxes: number
    totalAmount: number
    status: number
    isPaid: number
    paidAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillsAvgAggregateInputType = {
    id?: true
    meterId?: true
    consumerId?: true
    billMonth?: true
    billYear?: true
    previousReading?: true
    currentReading?: true
    unitsConsumed?: true
    fixedCharge?: true
    energyCharge?: true
    powerFactorCharge?: true
    subTotal?: true
    totalAmount?: true
    paidAmount?: true
  }

  export type BillsSumAggregateInputType = {
    id?: true
    meterId?: true
    consumerId?: true
    billMonth?: true
    billYear?: true
    previousReading?: true
    currentReading?: true
    unitsConsumed?: true
    fixedCharge?: true
    energyCharge?: true
    powerFactorCharge?: true
    subTotal?: true
    totalAmount?: true
    paidAmount?: true
  }

  export type BillsMinAggregateInputType = {
    id?: true
    billNumber?: true
    meterId?: true
    consumerId?: true
    billMonth?: true
    billYear?: true
    fromDate?: true
    toDate?: true
    dueDate?: true
    previousReading?: true
    currentReading?: true
    unitsConsumed?: true
    fixedCharge?: true
    energyCharge?: true
    powerFactorCharge?: true
    subTotal?: true
    totalAmount?: true
    status?: true
    isPaid?: true
    paidAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillsMaxAggregateInputType = {
    id?: true
    billNumber?: true
    meterId?: true
    consumerId?: true
    billMonth?: true
    billYear?: true
    fromDate?: true
    toDate?: true
    dueDate?: true
    previousReading?: true
    currentReading?: true
    unitsConsumed?: true
    fixedCharge?: true
    energyCharge?: true
    powerFactorCharge?: true
    subTotal?: true
    totalAmount?: true
    status?: true
    isPaid?: true
    paidAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillsCountAggregateInputType = {
    id?: true
    billNumber?: true
    meterId?: true
    consumerId?: true
    billMonth?: true
    billYear?: true
    fromDate?: true
    toDate?: true
    dueDate?: true
    previousReading?: true
    currentReading?: true
    unitsConsumed?: true
    fixedCharge?: true
    energyCharge?: true
    powerFactorCharge?: true
    otherCharges?: true
    subTotal?: true
    taxes?: true
    totalAmount?: true
    status?: true
    isPaid?: true
    paidAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bills to aggregate.
     */
    where?: billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bills to fetch.
     */
    orderBy?: billsOrderByWithRelationInput | billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bills
    **/
    _count?: true | BillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillsMaxAggregateInputType
  }

  export type GetBillsAggregateType<T extends BillsAggregateArgs> = {
        [P in keyof T & keyof AggregateBills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBills[P]>
      : GetScalarType<T[P], AggregateBills[P]>
  }




  export type billsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: billsWhereInput
    orderBy?: billsOrderByWithAggregationInput | billsOrderByWithAggregationInput[]
    by: BillsScalarFieldEnum[] | BillsScalarFieldEnum
    having?: billsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillsCountAggregateInputType | true
    _avg?: BillsAvgAggregateInputType
    _sum?: BillsSumAggregateInputType
    _min?: BillsMinAggregateInputType
    _max?: BillsMaxAggregateInputType
  }

  export type BillsGroupByOutputType = {
    id: number
    billNumber: string
    meterId: number
    consumerId: number
    billMonth: number
    billYear: number
    fromDate: Date
    toDate: Date
    dueDate: Date
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge: number | null
    otherCharges: JsonValue | null
    subTotal: number
    taxes: JsonValue
    totalAmount: number
    status: $Enums.BillStatus
    isPaid: boolean
    paidAmount: number
    createdAt: Date
    updatedAt: Date
    _count: BillsCountAggregateOutputType | null
    _avg: BillsAvgAggregateOutputType | null
    _sum: BillsSumAggregateOutputType | null
    _min: BillsMinAggregateOutputType | null
    _max: BillsMaxAggregateOutputType | null
  }

  type GetBillsGroupByPayload<T extends billsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillsGroupByOutputType[P]>
            : GetScalarType<T[P], BillsGroupByOutputType[P]>
        }
      >
    >


  export type billsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billNumber?: boolean
    meterId?: boolean
    consumerId?: boolean
    billMonth?: boolean
    billYear?: boolean
    fromDate?: boolean
    toDate?: boolean
    dueDate?: boolean
    previousReading?: boolean
    currentReading?: boolean
    unitsConsumed?: boolean
    fixedCharge?: boolean
    energyCharge?: boolean
    powerFactorCharge?: boolean
    otherCharges?: boolean
    subTotal?: boolean
    taxes?: boolean
    totalAmount?: boolean
    status?: boolean
    isPaid?: boolean
    paidAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
    meters?: boolean | metersDefaultArgs<ExtArgs>
    meter_readings?: boolean | bills$meter_readingsArgs<ExtArgs>
    payments?: boolean | bills$paymentsArgs<ExtArgs>
    _count?: boolean | BillsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bills"]>

  export type billsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billNumber?: boolean
    meterId?: boolean
    consumerId?: boolean
    billMonth?: boolean
    billYear?: boolean
    fromDate?: boolean
    toDate?: boolean
    dueDate?: boolean
    previousReading?: boolean
    currentReading?: boolean
    unitsConsumed?: boolean
    fixedCharge?: boolean
    energyCharge?: boolean
    powerFactorCharge?: boolean
    otherCharges?: boolean
    subTotal?: boolean
    taxes?: boolean
    totalAmount?: boolean
    status?: boolean
    isPaid?: boolean
    paidAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bills"]>

  export type billsSelectScalar = {
    id?: boolean
    billNumber?: boolean
    meterId?: boolean
    consumerId?: boolean
    billMonth?: boolean
    billYear?: boolean
    fromDate?: boolean
    toDate?: boolean
    dueDate?: boolean
    previousReading?: boolean
    currentReading?: boolean
    unitsConsumed?: boolean
    fixedCharge?: boolean
    energyCharge?: boolean
    powerFactorCharge?: boolean
    otherCharges?: boolean
    subTotal?: boolean
    taxes?: boolean
    totalAmount?: boolean
    status?: boolean
    isPaid?: boolean
    paidAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type billsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
    meters?: boolean | metersDefaultArgs<ExtArgs>
    meter_readings?: boolean | bills$meter_readingsArgs<ExtArgs>
    payments?: boolean | bills$paymentsArgs<ExtArgs>
    _count?: boolean | BillsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type billsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }

  export type $billsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bills"
    objects: {
      consumers: Prisma.$consumersPayload<ExtArgs>
      meters: Prisma.$metersPayload<ExtArgs>
      meter_readings: Prisma.$meter_readingsPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      billNumber: string
      meterId: number
      consumerId: number
      billMonth: number
      billYear: number
      fromDate: Date
      toDate: Date
      dueDate: Date
      previousReading: number
      currentReading: number
      unitsConsumed: number
      fixedCharge: number
      energyCharge: number
      powerFactorCharge: number | null
      otherCharges: Prisma.JsonValue | null
      subTotal: number
      taxes: Prisma.JsonValue
      totalAmount: number
      status: $Enums.BillStatus
      isPaid: boolean
      paidAmount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bills"]>
    composites: {}
  }

  type billsGetPayload<S extends boolean | null | undefined | billsDefaultArgs> = $Result.GetResult<Prisma.$billsPayload, S>

  type billsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<billsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillsCountAggregateInputType | true
    }

  export interface billsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bills'], meta: { name: 'bills' } }
    /**
     * Find zero or one Bills that matches the filter.
     * @param {billsFindUniqueArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends billsFindUniqueArgs>(args: SelectSubset<T, billsFindUniqueArgs<ExtArgs>>): Prisma__billsClient<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bills that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {billsFindUniqueOrThrowArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends billsFindUniqueOrThrowArgs>(args: SelectSubset<T, billsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__billsClient<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billsFindFirstArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends billsFindFirstArgs>(args?: SelectSubset<T, billsFindFirstArgs<ExtArgs>>): Prisma__billsClient<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billsFindFirstOrThrowArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends billsFindFirstOrThrowArgs>(args?: SelectSubset<T, billsFindFirstOrThrowArgs<ExtArgs>>): Prisma__billsClient<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bills.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billsWithIdOnly = await prisma.bills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends billsFindManyArgs>(args?: SelectSubset<T, billsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bills.
     * @param {billsCreateArgs} args - Arguments to create a Bills.
     * @example
     * // Create one Bills
     * const Bills = await prisma.bills.create({
     *   data: {
     *     // ... data to create a Bills
     *   }
     * })
     * 
     */
    create<T extends billsCreateArgs>(args: SelectSubset<T, billsCreateArgs<ExtArgs>>): Prisma__billsClient<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bills.
     * @param {billsCreateManyArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bills = await prisma.bills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends billsCreateManyArgs>(args?: SelectSubset<T, billsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bills and returns the data saved in the database.
     * @param {billsCreateManyAndReturnArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bills = await prisma.bills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bills and only return the `id`
     * const billsWithIdOnly = await prisma.bills.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends billsCreateManyAndReturnArgs>(args?: SelectSubset<T, billsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bills.
     * @param {billsDeleteArgs} args - Arguments to delete one Bills.
     * @example
     * // Delete one Bills
     * const Bills = await prisma.bills.delete({
     *   where: {
     *     // ... filter to delete one Bills
     *   }
     * })
     * 
     */
    delete<T extends billsDeleteArgs>(args: SelectSubset<T, billsDeleteArgs<ExtArgs>>): Prisma__billsClient<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bills.
     * @param {billsUpdateArgs} args - Arguments to update one Bills.
     * @example
     * // Update one Bills
     * const bills = await prisma.bills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends billsUpdateArgs>(args: SelectSubset<T, billsUpdateArgs<ExtArgs>>): Prisma__billsClient<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bills.
     * @param {billsDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends billsDeleteManyArgs>(args?: SelectSubset<T, billsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bills = await prisma.bills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends billsUpdateManyArgs>(args: SelectSubset<T, billsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bills.
     * @param {billsUpsertArgs} args - Arguments to update or create a Bills.
     * @example
     * // Update or create a Bills
     * const bills = await prisma.bills.upsert({
     *   create: {
     *     // ... data to create a Bills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bills we want to update
     *   }
     * })
     */
    upsert<T extends billsUpsertArgs>(args: SelectSubset<T, billsUpsertArgs<ExtArgs>>): Prisma__billsClient<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billsCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bills.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends billsCountArgs>(
      args?: Subset<T, billsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillsAggregateArgs>(args: Subset<T, BillsAggregateArgs>): Prisma.PrismaPromise<GetBillsAggregateType<T>>

    /**
     * Group by Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends billsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: billsGroupByArgs['orderBy'] }
        : { orderBy?: billsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, billsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bills model
   */
  readonly fields: billsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__billsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consumers<T extends consumersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, consumersDefaultArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    meters<T extends metersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, metersDefaultArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    meter_readings<T extends bills$meter_readingsArgs<ExtArgs> = {}>(args?: Subset<T, bills$meter_readingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends bills$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, bills$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bills model
   */ 
  interface billsFieldRefs {
    readonly id: FieldRef<"bills", 'Int'>
    readonly billNumber: FieldRef<"bills", 'String'>
    readonly meterId: FieldRef<"bills", 'Int'>
    readonly consumerId: FieldRef<"bills", 'Int'>
    readonly billMonth: FieldRef<"bills", 'Int'>
    readonly billYear: FieldRef<"bills", 'Int'>
    readonly fromDate: FieldRef<"bills", 'DateTime'>
    readonly toDate: FieldRef<"bills", 'DateTime'>
    readonly dueDate: FieldRef<"bills", 'DateTime'>
    readonly previousReading: FieldRef<"bills", 'Float'>
    readonly currentReading: FieldRef<"bills", 'Float'>
    readonly unitsConsumed: FieldRef<"bills", 'Float'>
    readonly fixedCharge: FieldRef<"bills", 'Float'>
    readonly energyCharge: FieldRef<"bills", 'Float'>
    readonly powerFactorCharge: FieldRef<"bills", 'Float'>
    readonly otherCharges: FieldRef<"bills", 'Json'>
    readonly subTotal: FieldRef<"bills", 'Float'>
    readonly taxes: FieldRef<"bills", 'Json'>
    readonly totalAmount: FieldRef<"bills", 'Float'>
    readonly status: FieldRef<"bills", 'BillStatus'>
    readonly isPaid: FieldRef<"bills", 'Boolean'>
    readonly paidAmount: FieldRef<"bills", 'Float'>
    readonly createdAt: FieldRef<"bills", 'DateTime'>
    readonly updatedAt: FieldRef<"bills", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bills findUnique
   */
  export type billsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    /**
     * Filter, which bills to fetch.
     */
    where: billsWhereUniqueInput
  }

  /**
   * bills findUniqueOrThrow
   */
  export type billsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    /**
     * Filter, which bills to fetch.
     */
    where: billsWhereUniqueInput
  }

  /**
   * bills findFirst
   */
  export type billsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    /**
     * Filter, which bills to fetch.
     */
    where?: billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bills to fetch.
     */
    orderBy?: billsOrderByWithRelationInput | billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bills.
     */
    cursor?: billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bills.
     */
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * bills findFirstOrThrow
   */
  export type billsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    /**
     * Filter, which bills to fetch.
     */
    where?: billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bills to fetch.
     */
    orderBy?: billsOrderByWithRelationInput | billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bills.
     */
    cursor?: billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bills.
     */
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * bills findMany
   */
  export type billsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    /**
     * Filter, which bills to fetch.
     */
    where?: billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bills to fetch.
     */
    orderBy?: billsOrderByWithRelationInput | billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bills.
     */
    cursor?: billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bills.
     */
    skip?: number
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * bills create
   */
  export type billsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    /**
     * The data needed to create a bills.
     */
    data: XOR<billsCreateInput, billsUncheckedCreateInput>
  }

  /**
   * bills createMany
   */
  export type billsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bills.
     */
    data: billsCreateManyInput | billsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bills createManyAndReturn
   */
  export type billsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many bills.
     */
    data: billsCreateManyInput | billsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bills update
   */
  export type billsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    /**
     * The data needed to update a bills.
     */
    data: XOR<billsUpdateInput, billsUncheckedUpdateInput>
    /**
     * Choose, which bills to update.
     */
    where: billsWhereUniqueInput
  }

  /**
   * bills updateMany
   */
  export type billsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bills.
     */
    data: XOR<billsUpdateManyMutationInput, billsUncheckedUpdateManyInput>
    /**
     * Filter which bills to update
     */
    where?: billsWhereInput
  }

  /**
   * bills upsert
   */
  export type billsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    /**
     * The filter to search for the bills to update in case it exists.
     */
    where: billsWhereUniqueInput
    /**
     * In case the bills found by the `where` argument doesn't exist, create a new bills with this data.
     */
    create: XOR<billsCreateInput, billsUncheckedCreateInput>
    /**
     * In case the bills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<billsUpdateInput, billsUncheckedUpdateInput>
  }

  /**
   * bills delete
   */
  export type billsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    /**
     * Filter which bills to delete.
     */
    where: billsWhereUniqueInput
  }

  /**
   * bills deleteMany
   */
  export type billsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bills to delete
     */
    where?: billsWhereInput
  }

  /**
   * bills.meter_readings
   */
  export type bills$meter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    where?: meter_readingsWhereInput
    orderBy?: meter_readingsOrderByWithRelationInput | meter_readingsOrderByWithRelationInput[]
    cursor?: meter_readingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Meter_readingsScalarFieldEnum | Meter_readingsScalarFieldEnum[]
  }

  /**
   * bills.payments
   */
  export type bills$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * bills without action
   */
  export type billsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
  }


  /**
   * Model consumer_documents
   */

  export type AggregateConsumer_documents = {
    _count: Consumer_documentsCountAggregateOutputType | null
    _avg: Consumer_documentsAvgAggregateOutputType | null
    _sum: Consumer_documentsSumAggregateOutputType | null
    _min: Consumer_documentsMinAggregateOutputType | null
    _max: Consumer_documentsMaxAggregateOutputType | null
  }

  export type Consumer_documentsAvgAggregateOutputType = {
    id: number | null
    consumerId: number | null
  }

  export type Consumer_documentsSumAggregateOutputType = {
    id: number | null
    consumerId: number | null
  }

  export type Consumer_documentsMinAggregateOutputType = {
    id: number | null
    consumerId: number | null
    type: $Enums.DocumentType | null
    number: string | null
    fileUrl: string | null
    verificationStatus: $Enums.VerificationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Consumer_documentsMaxAggregateOutputType = {
    id: number | null
    consumerId: number | null
    type: $Enums.DocumentType | null
    number: string | null
    fileUrl: string | null
    verificationStatus: $Enums.VerificationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Consumer_documentsCountAggregateOutputType = {
    id: number
    consumerId: number
    type: number
    number: number
    fileUrl: number
    verificationStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Consumer_documentsAvgAggregateInputType = {
    id?: true
    consumerId?: true
  }

  export type Consumer_documentsSumAggregateInputType = {
    id?: true
    consumerId?: true
  }

  export type Consumer_documentsMinAggregateInputType = {
    id?: true
    consumerId?: true
    type?: true
    number?: true
    fileUrl?: true
    verificationStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Consumer_documentsMaxAggregateInputType = {
    id?: true
    consumerId?: true
    type?: true
    number?: true
    fileUrl?: true
    verificationStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Consumer_documentsCountAggregateInputType = {
    id?: true
    consumerId?: true
    type?: true
    number?: true
    fileUrl?: true
    verificationStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Consumer_documentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consumer_documents to aggregate.
     */
    where?: consumer_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consumer_documents to fetch.
     */
    orderBy?: consumer_documentsOrderByWithRelationInput | consumer_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consumer_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consumer_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consumer_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consumer_documents
    **/
    _count?: true | Consumer_documentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Consumer_documentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Consumer_documentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Consumer_documentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Consumer_documentsMaxAggregateInputType
  }

  export type GetConsumer_documentsAggregateType<T extends Consumer_documentsAggregateArgs> = {
        [P in keyof T & keyof AggregateConsumer_documents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsumer_documents[P]>
      : GetScalarType<T[P], AggregateConsumer_documents[P]>
  }




  export type consumer_documentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consumer_documentsWhereInput
    orderBy?: consumer_documentsOrderByWithAggregationInput | consumer_documentsOrderByWithAggregationInput[]
    by: Consumer_documentsScalarFieldEnum[] | Consumer_documentsScalarFieldEnum
    having?: consumer_documentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Consumer_documentsCountAggregateInputType | true
    _avg?: Consumer_documentsAvgAggregateInputType
    _sum?: Consumer_documentsSumAggregateInputType
    _min?: Consumer_documentsMinAggregateInputType
    _max?: Consumer_documentsMaxAggregateInputType
  }

  export type Consumer_documentsGroupByOutputType = {
    id: number
    consumerId: number
    type: $Enums.DocumentType
    number: string
    fileUrl: string
    verificationStatus: $Enums.VerificationStatus
    createdAt: Date
    updatedAt: Date
    _count: Consumer_documentsCountAggregateOutputType | null
    _avg: Consumer_documentsAvgAggregateOutputType | null
    _sum: Consumer_documentsSumAggregateOutputType | null
    _min: Consumer_documentsMinAggregateOutputType | null
    _max: Consumer_documentsMaxAggregateOutputType | null
  }

  type GetConsumer_documentsGroupByPayload<T extends consumer_documentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Consumer_documentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Consumer_documentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Consumer_documentsGroupByOutputType[P]>
            : GetScalarType<T[P], Consumer_documentsGroupByOutputType[P]>
        }
      >
    >


  export type consumer_documentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consumerId?: boolean
    type?: boolean
    number?: boolean
    fileUrl?: boolean
    verificationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consumer_documents"]>

  export type consumer_documentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consumerId?: boolean
    type?: boolean
    number?: boolean
    fileUrl?: boolean
    verificationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consumer_documents"]>

  export type consumer_documentsSelectScalar = {
    id?: boolean
    consumerId?: boolean
    type?: boolean
    number?: boolean
    fileUrl?: boolean
    verificationStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type consumer_documentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
  }
  export type consumer_documentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
  }

  export type $consumer_documentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consumer_documents"
    objects: {
      consumers: Prisma.$consumersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      consumerId: number
      type: $Enums.DocumentType
      number: string
      fileUrl: string
      verificationStatus: $Enums.VerificationStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["consumer_documents"]>
    composites: {}
  }

  type consumer_documentsGetPayload<S extends boolean | null | undefined | consumer_documentsDefaultArgs> = $Result.GetResult<Prisma.$consumer_documentsPayload, S>

  type consumer_documentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<consumer_documentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Consumer_documentsCountAggregateInputType | true
    }

  export interface consumer_documentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consumer_documents'], meta: { name: 'consumer_documents' } }
    /**
     * Find zero or one Consumer_documents that matches the filter.
     * @param {consumer_documentsFindUniqueArgs} args - Arguments to find a Consumer_documents
     * @example
     * // Get one Consumer_documents
     * const consumer_documents = await prisma.consumer_documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consumer_documentsFindUniqueArgs>(args: SelectSubset<T, consumer_documentsFindUniqueArgs<ExtArgs>>): Prisma__consumer_documentsClient<$Result.GetResult<Prisma.$consumer_documentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Consumer_documents that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {consumer_documentsFindUniqueOrThrowArgs} args - Arguments to find a Consumer_documents
     * @example
     * // Get one Consumer_documents
     * const consumer_documents = await prisma.consumer_documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consumer_documentsFindUniqueOrThrowArgs>(args: SelectSubset<T, consumer_documentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consumer_documentsClient<$Result.GetResult<Prisma.$consumer_documentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Consumer_documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumer_documentsFindFirstArgs} args - Arguments to find a Consumer_documents
     * @example
     * // Get one Consumer_documents
     * const consumer_documents = await prisma.consumer_documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consumer_documentsFindFirstArgs>(args?: SelectSubset<T, consumer_documentsFindFirstArgs<ExtArgs>>): Prisma__consumer_documentsClient<$Result.GetResult<Prisma.$consumer_documentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Consumer_documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumer_documentsFindFirstOrThrowArgs} args - Arguments to find a Consumer_documents
     * @example
     * // Get one Consumer_documents
     * const consumer_documents = await prisma.consumer_documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consumer_documentsFindFirstOrThrowArgs>(args?: SelectSubset<T, consumer_documentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__consumer_documentsClient<$Result.GetResult<Prisma.$consumer_documentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Consumer_documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumer_documentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consumer_documents
     * const consumer_documents = await prisma.consumer_documents.findMany()
     * 
     * // Get first 10 Consumer_documents
     * const consumer_documents = await prisma.consumer_documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consumer_documentsWithIdOnly = await prisma.consumer_documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends consumer_documentsFindManyArgs>(args?: SelectSubset<T, consumer_documentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consumer_documentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Consumer_documents.
     * @param {consumer_documentsCreateArgs} args - Arguments to create a Consumer_documents.
     * @example
     * // Create one Consumer_documents
     * const Consumer_documents = await prisma.consumer_documents.create({
     *   data: {
     *     // ... data to create a Consumer_documents
     *   }
     * })
     * 
     */
    create<T extends consumer_documentsCreateArgs>(args: SelectSubset<T, consumer_documentsCreateArgs<ExtArgs>>): Prisma__consumer_documentsClient<$Result.GetResult<Prisma.$consumer_documentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Consumer_documents.
     * @param {consumer_documentsCreateManyArgs} args - Arguments to create many Consumer_documents.
     * @example
     * // Create many Consumer_documents
     * const consumer_documents = await prisma.consumer_documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consumer_documentsCreateManyArgs>(args?: SelectSubset<T, consumer_documentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consumer_documents and returns the data saved in the database.
     * @param {consumer_documentsCreateManyAndReturnArgs} args - Arguments to create many Consumer_documents.
     * @example
     * // Create many Consumer_documents
     * const consumer_documents = await prisma.consumer_documents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consumer_documents and only return the `id`
     * const consumer_documentsWithIdOnly = await prisma.consumer_documents.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends consumer_documentsCreateManyAndReturnArgs>(args?: SelectSubset<T, consumer_documentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consumer_documentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Consumer_documents.
     * @param {consumer_documentsDeleteArgs} args - Arguments to delete one Consumer_documents.
     * @example
     * // Delete one Consumer_documents
     * const Consumer_documents = await prisma.consumer_documents.delete({
     *   where: {
     *     // ... filter to delete one Consumer_documents
     *   }
     * })
     * 
     */
    delete<T extends consumer_documentsDeleteArgs>(args: SelectSubset<T, consumer_documentsDeleteArgs<ExtArgs>>): Prisma__consumer_documentsClient<$Result.GetResult<Prisma.$consumer_documentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Consumer_documents.
     * @param {consumer_documentsUpdateArgs} args - Arguments to update one Consumer_documents.
     * @example
     * // Update one Consumer_documents
     * const consumer_documents = await prisma.consumer_documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consumer_documentsUpdateArgs>(args: SelectSubset<T, consumer_documentsUpdateArgs<ExtArgs>>): Prisma__consumer_documentsClient<$Result.GetResult<Prisma.$consumer_documentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Consumer_documents.
     * @param {consumer_documentsDeleteManyArgs} args - Arguments to filter Consumer_documents to delete.
     * @example
     * // Delete a few Consumer_documents
     * const { count } = await prisma.consumer_documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consumer_documentsDeleteManyArgs>(args?: SelectSubset<T, consumer_documentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consumer_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumer_documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consumer_documents
     * const consumer_documents = await prisma.consumer_documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consumer_documentsUpdateManyArgs>(args: SelectSubset<T, consumer_documentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consumer_documents.
     * @param {consumer_documentsUpsertArgs} args - Arguments to update or create a Consumer_documents.
     * @example
     * // Update or create a Consumer_documents
     * const consumer_documents = await prisma.consumer_documents.upsert({
     *   create: {
     *     // ... data to create a Consumer_documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consumer_documents we want to update
     *   }
     * })
     */
    upsert<T extends consumer_documentsUpsertArgs>(args: SelectSubset<T, consumer_documentsUpsertArgs<ExtArgs>>): Prisma__consumer_documentsClient<$Result.GetResult<Prisma.$consumer_documentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Consumer_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumer_documentsCountArgs} args - Arguments to filter Consumer_documents to count.
     * @example
     * // Count the number of Consumer_documents
     * const count = await prisma.consumer_documents.count({
     *   where: {
     *     // ... the filter for the Consumer_documents we want to count
     *   }
     * })
    **/
    count<T extends consumer_documentsCountArgs>(
      args?: Subset<T, consumer_documentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Consumer_documentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consumer_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Consumer_documentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Consumer_documentsAggregateArgs>(args: Subset<T, Consumer_documentsAggregateArgs>): Prisma.PrismaPromise<GetConsumer_documentsAggregateType<T>>

    /**
     * Group by Consumer_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumer_documentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consumer_documentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consumer_documentsGroupByArgs['orderBy'] }
        : { orderBy?: consumer_documentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consumer_documentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsumer_documentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consumer_documents model
   */
  readonly fields: consumer_documentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consumer_documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consumer_documentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consumers<T extends consumersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, consumersDefaultArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consumer_documents model
   */ 
  interface consumer_documentsFieldRefs {
    readonly id: FieldRef<"consumer_documents", 'Int'>
    readonly consumerId: FieldRef<"consumer_documents", 'Int'>
    readonly type: FieldRef<"consumer_documents", 'DocumentType'>
    readonly number: FieldRef<"consumer_documents", 'String'>
    readonly fileUrl: FieldRef<"consumer_documents", 'String'>
    readonly verificationStatus: FieldRef<"consumer_documents", 'VerificationStatus'>
    readonly createdAt: FieldRef<"consumer_documents", 'DateTime'>
    readonly updatedAt: FieldRef<"consumer_documents", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * consumer_documents findUnique
   */
  export type consumer_documentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsInclude<ExtArgs> | null
    /**
     * Filter, which consumer_documents to fetch.
     */
    where: consumer_documentsWhereUniqueInput
  }

  /**
   * consumer_documents findUniqueOrThrow
   */
  export type consumer_documentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsInclude<ExtArgs> | null
    /**
     * Filter, which consumer_documents to fetch.
     */
    where: consumer_documentsWhereUniqueInput
  }

  /**
   * consumer_documents findFirst
   */
  export type consumer_documentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsInclude<ExtArgs> | null
    /**
     * Filter, which consumer_documents to fetch.
     */
    where?: consumer_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consumer_documents to fetch.
     */
    orderBy?: consumer_documentsOrderByWithRelationInput | consumer_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consumer_documents.
     */
    cursor?: consumer_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consumer_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consumer_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consumer_documents.
     */
    distinct?: Consumer_documentsScalarFieldEnum | Consumer_documentsScalarFieldEnum[]
  }

  /**
   * consumer_documents findFirstOrThrow
   */
  export type consumer_documentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsInclude<ExtArgs> | null
    /**
     * Filter, which consumer_documents to fetch.
     */
    where?: consumer_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consumer_documents to fetch.
     */
    orderBy?: consumer_documentsOrderByWithRelationInput | consumer_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consumer_documents.
     */
    cursor?: consumer_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consumer_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consumer_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consumer_documents.
     */
    distinct?: Consumer_documentsScalarFieldEnum | Consumer_documentsScalarFieldEnum[]
  }

  /**
   * consumer_documents findMany
   */
  export type consumer_documentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsInclude<ExtArgs> | null
    /**
     * Filter, which consumer_documents to fetch.
     */
    where?: consumer_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consumer_documents to fetch.
     */
    orderBy?: consumer_documentsOrderByWithRelationInput | consumer_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consumer_documents.
     */
    cursor?: consumer_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consumer_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consumer_documents.
     */
    skip?: number
    distinct?: Consumer_documentsScalarFieldEnum | Consumer_documentsScalarFieldEnum[]
  }

  /**
   * consumer_documents create
   */
  export type consumer_documentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsInclude<ExtArgs> | null
    /**
     * The data needed to create a consumer_documents.
     */
    data: XOR<consumer_documentsCreateInput, consumer_documentsUncheckedCreateInput>
  }

  /**
   * consumer_documents createMany
   */
  export type consumer_documentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consumer_documents.
     */
    data: consumer_documentsCreateManyInput | consumer_documentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consumer_documents createManyAndReturn
   */
  export type consumer_documentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many consumer_documents.
     */
    data: consumer_documentsCreateManyInput | consumer_documentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * consumer_documents update
   */
  export type consumer_documentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsInclude<ExtArgs> | null
    /**
     * The data needed to update a consumer_documents.
     */
    data: XOR<consumer_documentsUpdateInput, consumer_documentsUncheckedUpdateInput>
    /**
     * Choose, which consumer_documents to update.
     */
    where: consumer_documentsWhereUniqueInput
  }

  /**
   * consumer_documents updateMany
   */
  export type consumer_documentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consumer_documents.
     */
    data: XOR<consumer_documentsUpdateManyMutationInput, consumer_documentsUncheckedUpdateManyInput>
    /**
     * Filter which consumer_documents to update
     */
    where?: consumer_documentsWhereInput
  }

  /**
   * consumer_documents upsert
   */
  export type consumer_documentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsInclude<ExtArgs> | null
    /**
     * The filter to search for the consumer_documents to update in case it exists.
     */
    where: consumer_documentsWhereUniqueInput
    /**
     * In case the consumer_documents found by the `where` argument doesn't exist, create a new consumer_documents with this data.
     */
    create: XOR<consumer_documentsCreateInput, consumer_documentsUncheckedCreateInput>
    /**
     * In case the consumer_documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consumer_documentsUpdateInput, consumer_documentsUncheckedUpdateInput>
  }

  /**
   * consumer_documents delete
   */
  export type consumer_documentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsInclude<ExtArgs> | null
    /**
     * Filter which consumer_documents to delete.
     */
    where: consumer_documentsWhereUniqueInput
  }

  /**
   * consumer_documents deleteMany
   */
  export type consumer_documentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consumer_documents to delete
     */
    where?: consumer_documentsWhereInput
  }

  /**
   * consumer_documents without action
   */
  export type consumer_documentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsInclude<ExtArgs> | null
  }


  /**
   * Model consumers
   */

  export type AggregateConsumers = {
    _count: ConsumersCountAggregateOutputType | null
    _avg: ConsumersAvgAggregateOutputType | null
    _sum: ConsumersSumAggregateOutputType | null
    _min: ConsumersMinAggregateOutputType | null
    _max: ConsumersMaxAggregateOutputType | null
  }

  export type ConsumersAvgAggregateOutputType = {
    id: number | null
    sanctionedLoad: number | null
    locationId: number | null
    creditScore: number | null
  }

  export type ConsumersSumAggregateOutputType = {
    id: number | null
    sanctionedLoad: number | null
    locationId: number | null
    creditScore: number | null
  }

  export type ConsumersMinAggregateOutputType = {
    id: number | null
    consumerNumber: string | null
    name: string | null
    email: string | null
    primaryPhone: string | null
    alternatePhone: string | null
    idType: $Enums.IdType | null
    idNumber: string | null
    connectionType: $Enums.ConnectionType | null
    category: $Enums.ConsumerCategory | null
    sanctionedLoad: number | null
    connectionDate: Date | null
    locationId: number | null
    billingCycle: $Enums.BillingCycle | null
    defaultPaymentMethod: $Enums.PaymentMethod | null
    creditScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsumersMaxAggregateOutputType = {
    id: number | null
    consumerNumber: string | null
    name: string | null
    email: string | null
    primaryPhone: string | null
    alternatePhone: string | null
    idType: $Enums.IdType | null
    idNumber: string | null
    connectionType: $Enums.ConnectionType | null
    category: $Enums.ConsumerCategory | null
    sanctionedLoad: number | null
    connectionDate: Date | null
    locationId: number | null
    billingCycle: $Enums.BillingCycle | null
    defaultPaymentMethod: $Enums.PaymentMethod | null
    creditScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsumersCountAggregateOutputType = {
    id: number
    consumerNumber: number
    name: number
    email: number
    primaryPhone: number
    alternatePhone: number
    idType: number
    idNumber: number
    connectionType: number
    category: number
    sanctionedLoad: number
    connectionDate: number
    locationId: number
    billingCycle: number
    billDeliveryMode: number
    defaultPaymentMethod: number
    creditScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConsumersAvgAggregateInputType = {
    id?: true
    sanctionedLoad?: true
    locationId?: true
    creditScore?: true
  }

  export type ConsumersSumAggregateInputType = {
    id?: true
    sanctionedLoad?: true
    locationId?: true
    creditScore?: true
  }

  export type ConsumersMinAggregateInputType = {
    id?: true
    consumerNumber?: true
    name?: true
    email?: true
    primaryPhone?: true
    alternatePhone?: true
    idType?: true
    idNumber?: true
    connectionType?: true
    category?: true
    sanctionedLoad?: true
    connectionDate?: true
    locationId?: true
    billingCycle?: true
    defaultPaymentMethod?: true
    creditScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsumersMaxAggregateInputType = {
    id?: true
    consumerNumber?: true
    name?: true
    email?: true
    primaryPhone?: true
    alternatePhone?: true
    idType?: true
    idNumber?: true
    connectionType?: true
    category?: true
    sanctionedLoad?: true
    connectionDate?: true
    locationId?: true
    billingCycle?: true
    defaultPaymentMethod?: true
    creditScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsumersCountAggregateInputType = {
    id?: true
    consumerNumber?: true
    name?: true
    email?: true
    primaryPhone?: true
    alternatePhone?: true
    idType?: true
    idNumber?: true
    connectionType?: true
    category?: true
    sanctionedLoad?: true
    connectionDate?: true
    locationId?: true
    billingCycle?: true
    billDeliveryMode?: true
    defaultPaymentMethod?: true
    creditScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConsumersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consumers to aggregate.
     */
    where?: consumersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consumers to fetch.
     */
    orderBy?: consumersOrderByWithRelationInput | consumersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consumersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consumers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consumers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consumers
    **/
    _count?: true | ConsumersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsumersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsumersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsumersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsumersMaxAggregateInputType
  }

  export type GetConsumersAggregateType<T extends ConsumersAggregateArgs> = {
        [P in keyof T & keyof AggregateConsumers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsumers[P]>
      : GetScalarType<T[P], AggregateConsumers[P]>
  }




  export type consumersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consumersWhereInput
    orderBy?: consumersOrderByWithAggregationInput | consumersOrderByWithAggregationInput[]
    by: ConsumersScalarFieldEnum[] | ConsumersScalarFieldEnum
    having?: consumersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsumersCountAggregateInputType | true
    _avg?: ConsumersAvgAggregateInputType
    _sum?: ConsumersSumAggregateInputType
    _min?: ConsumersMinAggregateInputType
    _max?: ConsumersMaxAggregateInputType
  }

  export type ConsumersGroupByOutputType = {
    id: number
    consumerNumber: string
    name: string
    email: string | null
    primaryPhone: string
    alternatePhone: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date
    locationId: number
    billingCycle: $Enums.BillingCycle
    billDeliveryMode: $Enums.BillDeliveryMode[]
    defaultPaymentMethod: $Enums.PaymentMethod | null
    creditScore: number | null
    createdAt: Date
    updatedAt: Date
    _count: ConsumersCountAggregateOutputType | null
    _avg: ConsumersAvgAggregateOutputType | null
    _sum: ConsumersSumAggregateOutputType | null
    _min: ConsumersMinAggregateOutputType | null
    _max: ConsumersMaxAggregateOutputType | null
  }

  type GetConsumersGroupByPayload<T extends consumersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsumersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsumersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsumersGroupByOutputType[P]>
            : GetScalarType<T[P], ConsumersGroupByOutputType[P]>
        }
      >
    >


  export type consumersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consumerNumber?: boolean
    name?: boolean
    email?: boolean
    primaryPhone?: boolean
    alternatePhone?: boolean
    idType?: boolean
    idNumber?: boolean
    connectionType?: boolean
    category?: boolean
    sanctionedLoad?: boolean
    connectionDate?: boolean
    locationId?: boolean
    billingCycle?: boolean
    billDeliveryMode?: boolean
    defaultPaymentMethod?: boolean
    creditScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bills?: boolean | consumers$billsArgs<ExtArgs>
    consumer_documents?: boolean | consumers$consumer_documentsArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    notifications?: boolean | consumers$notificationsArgs<ExtArgs>
    prepaid_accounts?: boolean | consumers$prepaid_accountsArgs<ExtArgs>
    _count?: boolean | ConsumersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consumers"]>

  export type consumersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consumerNumber?: boolean
    name?: boolean
    email?: boolean
    primaryPhone?: boolean
    alternatePhone?: boolean
    idType?: boolean
    idNumber?: boolean
    connectionType?: boolean
    category?: boolean
    sanctionedLoad?: boolean
    connectionDate?: boolean
    locationId?: boolean
    billingCycle?: boolean
    billDeliveryMode?: boolean
    defaultPaymentMethod?: boolean
    creditScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locations?: boolean | locationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consumers"]>

  export type consumersSelectScalar = {
    id?: boolean
    consumerNumber?: boolean
    name?: boolean
    email?: boolean
    primaryPhone?: boolean
    alternatePhone?: boolean
    idType?: boolean
    idNumber?: boolean
    connectionType?: boolean
    category?: boolean
    sanctionedLoad?: boolean
    connectionDate?: boolean
    locationId?: boolean
    billingCycle?: boolean
    billDeliveryMode?: boolean
    defaultPaymentMethod?: boolean
    creditScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type consumersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | consumers$billsArgs<ExtArgs>
    consumer_documents?: boolean | consumers$consumer_documentsArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    notifications?: boolean | consumers$notificationsArgs<ExtArgs>
    prepaid_accounts?: boolean | consumers$prepaid_accountsArgs<ExtArgs>
    _count?: boolean | ConsumersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type consumersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | locationsDefaultArgs<ExtArgs>
  }

  export type $consumersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consumers"
    objects: {
      bills: Prisma.$billsPayload<ExtArgs>[]
      consumer_documents: Prisma.$consumer_documentsPayload<ExtArgs>[]
      locations: Prisma.$locationsPayload<ExtArgs>
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      prepaid_accounts: Prisma.$prepaid_accountsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      consumerNumber: string
      name: string
      email: string | null
      primaryPhone: string
      alternatePhone: string | null
      idType: $Enums.IdType
      idNumber: string
      connectionType: $Enums.ConnectionType
      category: $Enums.ConsumerCategory
      sanctionedLoad: number
      connectionDate: Date
      locationId: number
      billingCycle: $Enums.BillingCycle
      billDeliveryMode: $Enums.BillDeliveryMode[]
      defaultPaymentMethod: $Enums.PaymentMethod | null
      creditScore: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["consumers"]>
    composites: {}
  }

  type consumersGetPayload<S extends boolean | null | undefined | consumersDefaultArgs> = $Result.GetResult<Prisma.$consumersPayload, S>

  type consumersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<consumersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsumersCountAggregateInputType | true
    }

  export interface consumersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consumers'], meta: { name: 'consumers' } }
    /**
     * Find zero or one Consumers that matches the filter.
     * @param {consumersFindUniqueArgs} args - Arguments to find a Consumers
     * @example
     * // Get one Consumers
     * const consumers = await prisma.consumers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consumersFindUniqueArgs>(args: SelectSubset<T, consumersFindUniqueArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Consumers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {consumersFindUniqueOrThrowArgs} args - Arguments to find a Consumers
     * @example
     * // Get one Consumers
     * const consumers = await prisma.consumers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consumersFindUniqueOrThrowArgs>(args: SelectSubset<T, consumersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Consumers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumersFindFirstArgs} args - Arguments to find a Consumers
     * @example
     * // Get one Consumers
     * const consumers = await prisma.consumers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consumersFindFirstArgs>(args?: SelectSubset<T, consumersFindFirstArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Consumers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumersFindFirstOrThrowArgs} args - Arguments to find a Consumers
     * @example
     * // Get one Consumers
     * const consumers = await prisma.consumers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consumersFindFirstOrThrowArgs>(args?: SelectSubset<T, consumersFindFirstOrThrowArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Consumers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consumers
     * const consumers = await prisma.consumers.findMany()
     * 
     * // Get first 10 Consumers
     * const consumers = await prisma.consumers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consumersWithIdOnly = await prisma.consumers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends consumersFindManyArgs>(args?: SelectSubset<T, consumersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Consumers.
     * @param {consumersCreateArgs} args - Arguments to create a Consumers.
     * @example
     * // Create one Consumers
     * const Consumers = await prisma.consumers.create({
     *   data: {
     *     // ... data to create a Consumers
     *   }
     * })
     * 
     */
    create<T extends consumersCreateArgs>(args: SelectSubset<T, consumersCreateArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Consumers.
     * @param {consumersCreateManyArgs} args - Arguments to create many Consumers.
     * @example
     * // Create many Consumers
     * const consumers = await prisma.consumers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consumersCreateManyArgs>(args?: SelectSubset<T, consumersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consumers and returns the data saved in the database.
     * @param {consumersCreateManyAndReturnArgs} args - Arguments to create many Consumers.
     * @example
     * // Create many Consumers
     * const consumers = await prisma.consumers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consumers and only return the `id`
     * const consumersWithIdOnly = await prisma.consumers.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends consumersCreateManyAndReturnArgs>(args?: SelectSubset<T, consumersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Consumers.
     * @param {consumersDeleteArgs} args - Arguments to delete one Consumers.
     * @example
     * // Delete one Consumers
     * const Consumers = await prisma.consumers.delete({
     *   where: {
     *     // ... filter to delete one Consumers
     *   }
     * })
     * 
     */
    delete<T extends consumersDeleteArgs>(args: SelectSubset<T, consumersDeleteArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Consumers.
     * @param {consumersUpdateArgs} args - Arguments to update one Consumers.
     * @example
     * // Update one Consumers
     * const consumers = await prisma.consumers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consumersUpdateArgs>(args: SelectSubset<T, consumersUpdateArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Consumers.
     * @param {consumersDeleteManyArgs} args - Arguments to filter Consumers to delete.
     * @example
     * // Delete a few Consumers
     * const { count } = await prisma.consumers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consumersDeleteManyArgs>(args?: SelectSubset<T, consumersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consumers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consumers
     * const consumers = await prisma.consumers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consumersUpdateManyArgs>(args: SelectSubset<T, consumersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consumers.
     * @param {consumersUpsertArgs} args - Arguments to update or create a Consumers.
     * @example
     * // Update or create a Consumers
     * const consumers = await prisma.consumers.upsert({
     *   create: {
     *     // ... data to create a Consumers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consumers we want to update
     *   }
     * })
     */
    upsert<T extends consumersUpsertArgs>(args: SelectSubset<T, consumersUpsertArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Consumers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumersCountArgs} args - Arguments to filter Consumers to count.
     * @example
     * // Count the number of Consumers
     * const count = await prisma.consumers.count({
     *   where: {
     *     // ... the filter for the Consumers we want to count
     *   }
     * })
    **/
    count<T extends consumersCountArgs>(
      args?: Subset<T, consumersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsumersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consumers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsumersAggregateArgs>(args: Subset<T, ConsumersAggregateArgs>): Prisma.PrismaPromise<GetConsumersAggregateType<T>>

    /**
     * Group by Consumers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consumersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consumersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consumersGroupByArgs['orderBy'] }
        : { orderBy?: consumersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consumersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsumersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consumers model
   */
  readonly fields: consumersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consumers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consumersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bills<T extends consumers$billsArgs<ExtArgs> = {}>(args?: Subset<T, consumers$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "findMany"> | Null>
    consumer_documents<T extends consumers$consumer_documentsArgs<ExtArgs> = {}>(args?: Subset<T, consumers$consumer_documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consumer_documentsPayload<ExtArgs>, T, "findMany"> | Null>
    locations<T extends locationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, locationsDefaultArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    notifications<T extends consumers$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, consumers$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany"> | Null>
    prepaid_accounts<T extends consumers$prepaid_accountsArgs<ExtArgs> = {}>(args?: Subset<T, consumers$prepaid_accountsArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consumers model
   */ 
  interface consumersFieldRefs {
    readonly id: FieldRef<"consumers", 'Int'>
    readonly consumerNumber: FieldRef<"consumers", 'String'>
    readonly name: FieldRef<"consumers", 'String'>
    readonly email: FieldRef<"consumers", 'String'>
    readonly primaryPhone: FieldRef<"consumers", 'String'>
    readonly alternatePhone: FieldRef<"consumers", 'String'>
    readonly idType: FieldRef<"consumers", 'IdType'>
    readonly idNumber: FieldRef<"consumers", 'String'>
    readonly connectionType: FieldRef<"consumers", 'ConnectionType'>
    readonly category: FieldRef<"consumers", 'ConsumerCategory'>
    readonly sanctionedLoad: FieldRef<"consumers", 'Float'>
    readonly connectionDate: FieldRef<"consumers", 'DateTime'>
    readonly locationId: FieldRef<"consumers", 'Int'>
    readonly billingCycle: FieldRef<"consumers", 'BillingCycle'>
    readonly billDeliveryMode: FieldRef<"consumers", 'BillDeliveryMode[]'>
    readonly defaultPaymentMethod: FieldRef<"consumers", 'PaymentMethod'>
    readonly creditScore: FieldRef<"consumers", 'Int'>
    readonly createdAt: FieldRef<"consumers", 'DateTime'>
    readonly updatedAt: FieldRef<"consumers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * consumers findUnique
   */
  export type consumersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersInclude<ExtArgs> | null
    /**
     * Filter, which consumers to fetch.
     */
    where: consumersWhereUniqueInput
  }

  /**
   * consumers findUniqueOrThrow
   */
  export type consumersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersInclude<ExtArgs> | null
    /**
     * Filter, which consumers to fetch.
     */
    where: consumersWhereUniqueInput
  }

  /**
   * consumers findFirst
   */
  export type consumersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersInclude<ExtArgs> | null
    /**
     * Filter, which consumers to fetch.
     */
    where?: consumersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consumers to fetch.
     */
    orderBy?: consumersOrderByWithRelationInput | consumersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consumers.
     */
    cursor?: consumersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consumers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consumers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consumers.
     */
    distinct?: ConsumersScalarFieldEnum | ConsumersScalarFieldEnum[]
  }

  /**
   * consumers findFirstOrThrow
   */
  export type consumersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersInclude<ExtArgs> | null
    /**
     * Filter, which consumers to fetch.
     */
    where?: consumersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consumers to fetch.
     */
    orderBy?: consumersOrderByWithRelationInput | consumersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consumers.
     */
    cursor?: consumersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consumers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consumers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consumers.
     */
    distinct?: ConsumersScalarFieldEnum | ConsumersScalarFieldEnum[]
  }

  /**
   * consumers findMany
   */
  export type consumersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersInclude<ExtArgs> | null
    /**
     * Filter, which consumers to fetch.
     */
    where?: consumersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consumers to fetch.
     */
    orderBy?: consumersOrderByWithRelationInput | consumersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consumers.
     */
    cursor?: consumersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consumers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consumers.
     */
    skip?: number
    distinct?: ConsumersScalarFieldEnum | ConsumersScalarFieldEnum[]
  }

  /**
   * consumers create
   */
  export type consumersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersInclude<ExtArgs> | null
    /**
     * The data needed to create a consumers.
     */
    data: XOR<consumersCreateInput, consumersUncheckedCreateInput>
  }

  /**
   * consumers createMany
   */
  export type consumersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consumers.
     */
    data: consumersCreateManyInput | consumersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consumers createManyAndReturn
   */
  export type consumersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many consumers.
     */
    data: consumersCreateManyInput | consumersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * consumers update
   */
  export type consumersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersInclude<ExtArgs> | null
    /**
     * The data needed to update a consumers.
     */
    data: XOR<consumersUpdateInput, consumersUncheckedUpdateInput>
    /**
     * Choose, which consumers to update.
     */
    where: consumersWhereUniqueInput
  }

  /**
   * consumers updateMany
   */
  export type consumersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consumers.
     */
    data: XOR<consumersUpdateManyMutationInput, consumersUncheckedUpdateManyInput>
    /**
     * Filter which consumers to update
     */
    where?: consumersWhereInput
  }

  /**
   * consumers upsert
   */
  export type consumersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersInclude<ExtArgs> | null
    /**
     * The filter to search for the consumers to update in case it exists.
     */
    where: consumersWhereUniqueInput
    /**
     * In case the consumers found by the `where` argument doesn't exist, create a new consumers with this data.
     */
    create: XOR<consumersCreateInput, consumersUncheckedCreateInput>
    /**
     * In case the consumers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consumersUpdateInput, consumersUncheckedUpdateInput>
  }

  /**
   * consumers delete
   */
  export type consumersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersInclude<ExtArgs> | null
    /**
     * Filter which consumers to delete.
     */
    where: consumersWhereUniqueInput
  }

  /**
   * consumers deleteMany
   */
  export type consumersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consumers to delete
     */
    where?: consumersWhereInput
  }

  /**
   * consumers.bills
   */
  export type consumers$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    where?: billsWhereInput
    orderBy?: billsOrderByWithRelationInput | billsOrderByWithRelationInput[]
    cursor?: billsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * consumers.consumer_documents
   */
  export type consumers$consumer_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumer_documents
     */
    select?: consumer_documentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumer_documentsInclude<ExtArgs> | null
    where?: consumer_documentsWhereInput
    orderBy?: consumer_documentsOrderByWithRelationInput | consumer_documentsOrderByWithRelationInput[]
    cursor?: consumer_documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Consumer_documentsScalarFieldEnum | Consumer_documentsScalarFieldEnum[]
  }

  /**
   * consumers.notifications
   */
  export type consumers$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * consumers.prepaid_accounts
   */
  export type consumers$prepaid_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsInclude<ExtArgs> | null
    where?: prepaid_accountsWhereInput
  }

  /**
   * consumers without action
   */
  export type consumersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersInclude<ExtArgs> | null
  }


  /**
   * Model current_transformers
   */

  export type AggregateCurrent_transformers = {
    _count: Current_transformersCountAggregateOutputType | null
    _avg: Current_transformersAvgAggregateOutputType | null
    _sum: Current_transformersSumAggregateOutputType | null
    _min: Current_transformersMinAggregateOutputType | null
    _max: Current_transformersMaxAggregateOutputType | null
  }

  export type Current_transformersAvgAggregateOutputType = {
    id: number | null
    meterId: number | null
    ratedPrimary: number | null
    ratedSecondary: number | null
    burden: number | null
  }

  export type Current_transformersSumAggregateOutputType = {
    id: number | null
    meterId: number | null
    ratedPrimary: number | null
    ratedSecondary: number | null
    burden: number | null
  }

  export type Current_transformersMinAggregateOutputType = {
    id: number | null
    meterId: number | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    ratedPrimary: number | null
    ratedSecondary: number | null
    accuracyClass: string | null
    burden: number | null
    installationDate: Date | null
    lastTestedDate: Date | null
    nextTestDue: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Current_transformersMaxAggregateOutputType = {
    id: number | null
    meterId: number | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    ratedPrimary: number | null
    ratedSecondary: number | null
    accuracyClass: string | null
    burden: number | null
    installationDate: Date | null
    lastTestedDate: Date | null
    nextTestDue: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Current_transformersCountAggregateOutputType = {
    id: number
    meterId: number
    serialNumber: number
    manufacturer: number
    model: number
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: number
    burden: number
    installationDate: number
    lastTestedDate: number
    nextTestDue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Current_transformersAvgAggregateInputType = {
    id?: true
    meterId?: true
    ratedPrimary?: true
    ratedSecondary?: true
    burden?: true
  }

  export type Current_transformersSumAggregateInputType = {
    id?: true
    meterId?: true
    ratedPrimary?: true
    ratedSecondary?: true
    burden?: true
  }

  export type Current_transformersMinAggregateInputType = {
    id?: true
    meterId?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    ratedPrimary?: true
    ratedSecondary?: true
    accuracyClass?: true
    burden?: true
    installationDate?: true
    lastTestedDate?: true
    nextTestDue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Current_transformersMaxAggregateInputType = {
    id?: true
    meterId?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    ratedPrimary?: true
    ratedSecondary?: true
    accuracyClass?: true
    burden?: true
    installationDate?: true
    lastTestedDate?: true
    nextTestDue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Current_transformersCountAggregateInputType = {
    id?: true
    meterId?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    ratedPrimary?: true
    ratedSecondary?: true
    accuracyClass?: true
    burden?: true
    installationDate?: true
    lastTestedDate?: true
    nextTestDue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Current_transformersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which current_transformers to aggregate.
     */
    where?: current_transformersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of current_transformers to fetch.
     */
    orderBy?: current_transformersOrderByWithRelationInput | current_transformersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: current_transformersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` current_transformers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` current_transformers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned current_transformers
    **/
    _count?: true | Current_transformersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Current_transformersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Current_transformersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Current_transformersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Current_transformersMaxAggregateInputType
  }

  export type GetCurrent_transformersAggregateType<T extends Current_transformersAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrent_transformers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrent_transformers[P]>
      : GetScalarType<T[P], AggregateCurrent_transformers[P]>
  }




  export type current_transformersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: current_transformersWhereInput
    orderBy?: current_transformersOrderByWithAggregationInput | current_transformersOrderByWithAggregationInput[]
    by: Current_transformersScalarFieldEnum[] | Current_transformersScalarFieldEnum
    having?: current_transformersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Current_transformersCountAggregateInputType | true
    _avg?: Current_transformersAvgAggregateInputType
    _sum?: Current_transformersSumAggregateInputType
    _min?: Current_transformersMinAggregateInputType
    _max?: Current_transformersMaxAggregateInputType
  }

  export type Current_transformersGroupByOutputType = {
    id: number
    meterId: number
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date
    lastTestedDate: Date | null
    nextTestDue: Date | null
    createdAt: Date
    updatedAt: Date
    _count: Current_transformersCountAggregateOutputType | null
    _avg: Current_transformersAvgAggregateOutputType | null
    _sum: Current_transformersSumAggregateOutputType | null
    _min: Current_transformersMinAggregateOutputType | null
    _max: Current_transformersMaxAggregateOutputType | null
  }

  type GetCurrent_transformersGroupByPayload<T extends current_transformersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Current_transformersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Current_transformersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Current_transformersGroupByOutputType[P]>
            : GetScalarType<T[P], Current_transformersGroupByOutputType[P]>
        }
      >
    >


  export type current_transformersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterId?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    ratedPrimary?: boolean
    ratedSecondary?: boolean
    accuracyClass?: boolean
    burden?: boolean
    installationDate?: boolean
    lastTestedDate?: boolean
    nextTestDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["current_transformers"]>

  export type current_transformersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterId?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    ratedPrimary?: boolean
    ratedSecondary?: boolean
    accuracyClass?: boolean
    burden?: boolean
    installationDate?: boolean
    lastTestedDate?: boolean
    nextTestDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["current_transformers"]>

  export type current_transformersSelectScalar = {
    id?: boolean
    meterId?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    ratedPrimary?: boolean
    ratedSecondary?: boolean
    accuracyClass?: boolean
    burden?: boolean
    installationDate?: boolean
    lastTestedDate?: boolean
    nextTestDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type current_transformersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }
  export type current_transformersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }

  export type $current_transformersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "current_transformers"
    objects: {
      meters: Prisma.$metersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      meterId: number
      serialNumber: string
      manufacturer: string
      model: string
      ratedPrimary: number
      ratedSecondary: number
      accuracyClass: string
      burden: number
      installationDate: Date
      lastTestedDate: Date | null
      nextTestDue: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["current_transformers"]>
    composites: {}
  }

  type current_transformersGetPayload<S extends boolean | null | undefined | current_transformersDefaultArgs> = $Result.GetResult<Prisma.$current_transformersPayload, S>

  type current_transformersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<current_transformersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Current_transformersCountAggregateInputType | true
    }

  export interface current_transformersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['current_transformers'], meta: { name: 'current_transformers' } }
    /**
     * Find zero or one Current_transformers that matches the filter.
     * @param {current_transformersFindUniqueArgs} args - Arguments to find a Current_transformers
     * @example
     * // Get one Current_transformers
     * const current_transformers = await prisma.current_transformers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends current_transformersFindUniqueArgs>(args: SelectSubset<T, current_transformersFindUniqueArgs<ExtArgs>>): Prisma__current_transformersClient<$Result.GetResult<Prisma.$current_transformersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Current_transformers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {current_transformersFindUniqueOrThrowArgs} args - Arguments to find a Current_transformers
     * @example
     * // Get one Current_transformers
     * const current_transformers = await prisma.current_transformers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends current_transformersFindUniqueOrThrowArgs>(args: SelectSubset<T, current_transformersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__current_transformersClient<$Result.GetResult<Prisma.$current_transformersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Current_transformers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {current_transformersFindFirstArgs} args - Arguments to find a Current_transformers
     * @example
     * // Get one Current_transformers
     * const current_transformers = await prisma.current_transformers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends current_transformersFindFirstArgs>(args?: SelectSubset<T, current_transformersFindFirstArgs<ExtArgs>>): Prisma__current_transformersClient<$Result.GetResult<Prisma.$current_transformersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Current_transformers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {current_transformersFindFirstOrThrowArgs} args - Arguments to find a Current_transformers
     * @example
     * // Get one Current_transformers
     * const current_transformers = await prisma.current_transformers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends current_transformersFindFirstOrThrowArgs>(args?: SelectSubset<T, current_transformersFindFirstOrThrowArgs<ExtArgs>>): Prisma__current_transformersClient<$Result.GetResult<Prisma.$current_transformersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Current_transformers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {current_transformersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Current_transformers
     * const current_transformers = await prisma.current_transformers.findMany()
     * 
     * // Get first 10 Current_transformers
     * const current_transformers = await prisma.current_transformers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const current_transformersWithIdOnly = await prisma.current_transformers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends current_transformersFindManyArgs>(args?: SelectSubset<T, current_transformersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$current_transformersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Current_transformers.
     * @param {current_transformersCreateArgs} args - Arguments to create a Current_transformers.
     * @example
     * // Create one Current_transformers
     * const Current_transformers = await prisma.current_transformers.create({
     *   data: {
     *     // ... data to create a Current_transformers
     *   }
     * })
     * 
     */
    create<T extends current_transformersCreateArgs>(args: SelectSubset<T, current_transformersCreateArgs<ExtArgs>>): Prisma__current_transformersClient<$Result.GetResult<Prisma.$current_transformersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Current_transformers.
     * @param {current_transformersCreateManyArgs} args - Arguments to create many Current_transformers.
     * @example
     * // Create many Current_transformers
     * const current_transformers = await prisma.current_transformers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends current_transformersCreateManyArgs>(args?: SelectSubset<T, current_transformersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Current_transformers and returns the data saved in the database.
     * @param {current_transformersCreateManyAndReturnArgs} args - Arguments to create many Current_transformers.
     * @example
     * // Create many Current_transformers
     * const current_transformers = await prisma.current_transformers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Current_transformers and only return the `id`
     * const current_transformersWithIdOnly = await prisma.current_transformers.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends current_transformersCreateManyAndReturnArgs>(args?: SelectSubset<T, current_transformersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$current_transformersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Current_transformers.
     * @param {current_transformersDeleteArgs} args - Arguments to delete one Current_transformers.
     * @example
     * // Delete one Current_transformers
     * const Current_transformers = await prisma.current_transformers.delete({
     *   where: {
     *     // ... filter to delete one Current_transformers
     *   }
     * })
     * 
     */
    delete<T extends current_transformersDeleteArgs>(args: SelectSubset<T, current_transformersDeleteArgs<ExtArgs>>): Prisma__current_transformersClient<$Result.GetResult<Prisma.$current_transformersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Current_transformers.
     * @param {current_transformersUpdateArgs} args - Arguments to update one Current_transformers.
     * @example
     * // Update one Current_transformers
     * const current_transformers = await prisma.current_transformers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends current_transformersUpdateArgs>(args: SelectSubset<T, current_transformersUpdateArgs<ExtArgs>>): Prisma__current_transformersClient<$Result.GetResult<Prisma.$current_transformersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Current_transformers.
     * @param {current_transformersDeleteManyArgs} args - Arguments to filter Current_transformers to delete.
     * @example
     * // Delete a few Current_transformers
     * const { count } = await prisma.current_transformers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends current_transformersDeleteManyArgs>(args?: SelectSubset<T, current_transformersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Current_transformers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {current_transformersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Current_transformers
     * const current_transformers = await prisma.current_transformers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends current_transformersUpdateManyArgs>(args: SelectSubset<T, current_transformersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Current_transformers.
     * @param {current_transformersUpsertArgs} args - Arguments to update or create a Current_transformers.
     * @example
     * // Update or create a Current_transformers
     * const current_transformers = await prisma.current_transformers.upsert({
     *   create: {
     *     // ... data to create a Current_transformers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Current_transformers we want to update
     *   }
     * })
     */
    upsert<T extends current_transformersUpsertArgs>(args: SelectSubset<T, current_transformersUpsertArgs<ExtArgs>>): Prisma__current_transformersClient<$Result.GetResult<Prisma.$current_transformersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Current_transformers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {current_transformersCountArgs} args - Arguments to filter Current_transformers to count.
     * @example
     * // Count the number of Current_transformers
     * const count = await prisma.current_transformers.count({
     *   where: {
     *     // ... the filter for the Current_transformers we want to count
     *   }
     * })
    **/
    count<T extends current_transformersCountArgs>(
      args?: Subset<T, current_transformersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Current_transformersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Current_transformers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Current_transformersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Current_transformersAggregateArgs>(args: Subset<T, Current_transformersAggregateArgs>): Prisma.PrismaPromise<GetCurrent_transformersAggregateType<T>>

    /**
     * Group by Current_transformers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {current_transformersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends current_transformersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: current_transformersGroupByArgs['orderBy'] }
        : { orderBy?: current_transformersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, current_transformersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrent_transformersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the current_transformers model
   */
  readonly fields: current_transformersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for current_transformers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__current_transformersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meters<T extends metersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, metersDefaultArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the current_transformers model
   */ 
  interface current_transformersFieldRefs {
    readonly id: FieldRef<"current_transformers", 'Int'>
    readonly meterId: FieldRef<"current_transformers", 'Int'>
    readonly serialNumber: FieldRef<"current_transformers", 'String'>
    readonly manufacturer: FieldRef<"current_transformers", 'String'>
    readonly model: FieldRef<"current_transformers", 'String'>
    readonly ratedPrimary: FieldRef<"current_transformers", 'Float'>
    readonly ratedSecondary: FieldRef<"current_transformers", 'Float'>
    readonly accuracyClass: FieldRef<"current_transformers", 'String'>
    readonly burden: FieldRef<"current_transformers", 'Float'>
    readonly installationDate: FieldRef<"current_transformers", 'DateTime'>
    readonly lastTestedDate: FieldRef<"current_transformers", 'DateTime'>
    readonly nextTestDue: FieldRef<"current_transformers", 'DateTime'>
    readonly createdAt: FieldRef<"current_transformers", 'DateTime'>
    readonly updatedAt: FieldRef<"current_transformers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * current_transformers findUnique
   */
  export type current_transformersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersInclude<ExtArgs> | null
    /**
     * Filter, which current_transformers to fetch.
     */
    where: current_transformersWhereUniqueInput
  }

  /**
   * current_transformers findUniqueOrThrow
   */
  export type current_transformersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersInclude<ExtArgs> | null
    /**
     * Filter, which current_transformers to fetch.
     */
    where: current_transformersWhereUniqueInput
  }

  /**
   * current_transformers findFirst
   */
  export type current_transformersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersInclude<ExtArgs> | null
    /**
     * Filter, which current_transformers to fetch.
     */
    where?: current_transformersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of current_transformers to fetch.
     */
    orderBy?: current_transformersOrderByWithRelationInput | current_transformersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for current_transformers.
     */
    cursor?: current_transformersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` current_transformers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` current_transformers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of current_transformers.
     */
    distinct?: Current_transformersScalarFieldEnum | Current_transformersScalarFieldEnum[]
  }

  /**
   * current_transformers findFirstOrThrow
   */
  export type current_transformersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersInclude<ExtArgs> | null
    /**
     * Filter, which current_transformers to fetch.
     */
    where?: current_transformersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of current_transformers to fetch.
     */
    orderBy?: current_transformersOrderByWithRelationInput | current_transformersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for current_transformers.
     */
    cursor?: current_transformersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` current_transformers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` current_transformers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of current_transformers.
     */
    distinct?: Current_transformersScalarFieldEnum | Current_transformersScalarFieldEnum[]
  }

  /**
   * current_transformers findMany
   */
  export type current_transformersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersInclude<ExtArgs> | null
    /**
     * Filter, which current_transformers to fetch.
     */
    where?: current_transformersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of current_transformers to fetch.
     */
    orderBy?: current_transformersOrderByWithRelationInput | current_transformersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing current_transformers.
     */
    cursor?: current_transformersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` current_transformers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` current_transformers.
     */
    skip?: number
    distinct?: Current_transformersScalarFieldEnum | Current_transformersScalarFieldEnum[]
  }

  /**
   * current_transformers create
   */
  export type current_transformersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersInclude<ExtArgs> | null
    /**
     * The data needed to create a current_transformers.
     */
    data: XOR<current_transformersCreateInput, current_transformersUncheckedCreateInput>
  }

  /**
   * current_transformers createMany
   */
  export type current_transformersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many current_transformers.
     */
    data: current_transformersCreateManyInput | current_transformersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * current_transformers createManyAndReturn
   */
  export type current_transformersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many current_transformers.
     */
    data: current_transformersCreateManyInput | current_transformersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * current_transformers update
   */
  export type current_transformersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersInclude<ExtArgs> | null
    /**
     * The data needed to update a current_transformers.
     */
    data: XOR<current_transformersUpdateInput, current_transformersUncheckedUpdateInput>
    /**
     * Choose, which current_transformers to update.
     */
    where: current_transformersWhereUniqueInput
  }

  /**
   * current_transformers updateMany
   */
  export type current_transformersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update current_transformers.
     */
    data: XOR<current_transformersUpdateManyMutationInput, current_transformersUncheckedUpdateManyInput>
    /**
     * Filter which current_transformers to update
     */
    where?: current_transformersWhereInput
  }

  /**
   * current_transformers upsert
   */
  export type current_transformersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersInclude<ExtArgs> | null
    /**
     * The filter to search for the current_transformers to update in case it exists.
     */
    where: current_transformersWhereUniqueInput
    /**
     * In case the current_transformers found by the `where` argument doesn't exist, create a new current_transformers with this data.
     */
    create: XOR<current_transformersCreateInput, current_transformersUncheckedCreateInput>
    /**
     * In case the current_transformers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<current_transformersUpdateInput, current_transformersUncheckedUpdateInput>
  }

  /**
   * current_transformers delete
   */
  export type current_transformersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersInclude<ExtArgs> | null
    /**
     * Filter which current_transformers to delete.
     */
    where: current_transformersWhereUniqueInput
  }

  /**
   * current_transformers deleteMany
   */
  export type current_transformersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which current_transformers to delete
     */
    where?: current_transformersWhereInput
  }

  /**
   * current_transformers without action
   */
  export type current_transformersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersInclude<ExtArgs> | null
  }


  /**
   * Model departments
   */

  export type AggregateDepartments = {
    _count: DepartmentsCountAggregateOutputType | null
    _avg: DepartmentsAvgAggregateOutputType | null
    _sum: DepartmentsSumAggregateOutputType | null
    _min: DepartmentsMinAggregateOutputType | null
    _max: DepartmentsMaxAggregateOutputType | null
  }

  export type DepartmentsAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type DepartmentsSumAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type DepartmentsMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    description: string | null
    parentId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    description: string | null
    parentId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentsCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    parentId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentsAvgAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type DepartmentsSumAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type DepartmentsMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentsMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentsCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to aggregate.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned departments
    **/
    _count?: true | DepartmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentsMaxAggregateInputType
  }

  export type GetDepartmentsAggregateType<T extends DepartmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartments[P]>
      : GetScalarType<T[P], AggregateDepartments[P]>
  }




  export type departmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentsWhereInput
    orderBy?: departmentsOrderByWithAggregationInput | departmentsOrderByWithAggregationInput[]
    by: DepartmentsScalarFieldEnum[] | DepartmentsScalarFieldEnum
    having?: departmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentsCountAggregateInputType | true
    _avg?: DepartmentsAvgAggregateInputType
    _sum?: DepartmentsSumAggregateInputType
    _min?: DepartmentsMinAggregateInputType
    _max?: DepartmentsMaxAggregateInputType
  }

  export type DepartmentsGroupByOutputType = {
    id: number
    name: string
    code: string
    description: string | null
    parentId: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DepartmentsCountAggregateOutputType | null
    _avg: DepartmentsAvgAggregateOutputType | null
    _sum: DepartmentsSumAggregateOutputType | null
    _min: DepartmentsMinAggregateOutputType | null
    _max: DepartmentsMaxAggregateOutputType | null
  }

  type GetDepartmentsGroupByPayload<T extends departmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentsGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentsGroupByOutputType[P]>
        }
      >
    >


  export type departmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | departments$parentArgs<ExtArgs>
    children?: boolean | departments$childrenArgs<ExtArgs>
    users?: boolean | departments$usersArgs<ExtArgs>
    _count?: boolean | DepartmentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departments"]>

  export type departmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | departments$parentArgs<ExtArgs>
  }, ExtArgs["result"]["departments"]>

  export type departmentsSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type departmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | departments$parentArgs<ExtArgs>
    children?: boolean | departments$childrenArgs<ExtArgs>
    users?: boolean | departments$usersArgs<ExtArgs>
    _count?: boolean | DepartmentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type departmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | departments$parentArgs<ExtArgs>
  }

  export type $departmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "departments"
    objects: {
      parent: Prisma.$departmentsPayload<ExtArgs> | null
      children: Prisma.$departmentsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      description: string | null
      parentId: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["departments"]>
    composites: {}
  }

  type departmentsGetPayload<S extends boolean | null | undefined | departmentsDefaultArgs> = $Result.GetResult<Prisma.$departmentsPayload, S>

  type departmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<departmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentsCountAggregateInputType | true
    }

  export interface departmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['departments'], meta: { name: 'departments' } }
    /**
     * Find zero or one Departments that matches the filter.
     * @param {departmentsFindUniqueArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends departmentsFindUniqueArgs>(args: SelectSubset<T, departmentsFindUniqueArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Departments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {departmentsFindUniqueOrThrowArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends departmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, departmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindFirstArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends departmentsFindFirstArgs>(args?: SelectSubset<T, departmentsFindFirstArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Departments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindFirstOrThrowArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends departmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, departmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.departments.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.departments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentsWithIdOnly = await prisma.departments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends departmentsFindManyArgs>(args?: SelectSubset<T, departmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Departments.
     * @param {departmentsCreateArgs} args - Arguments to create a Departments.
     * @example
     * // Create one Departments
     * const Departments = await prisma.departments.create({
     *   data: {
     *     // ... data to create a Departments
     *   }
     * })
     * 
     */
    create<T extends departmentsCreateArgs>(args: SelectSubset<T, departmentsCreateArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {departmentsCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const departments = await prisma.departments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends departmentsCreateManyArgs>(args?: SelectSubset<T, departmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {departmentsCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const departments = await prisma.departments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentsWithIdOnly = await prisma.departments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends departmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, departmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Departments.
     * @param {departmentsDeleteArgs} args - Arguments to delete one Departments.
     * @example
     * // Delete one Departments
     * const Departments = await prisma.departments.delete({
     *   where: {
     *     // ... filter to delete one Departments
     *   }
     * })
     * 
     */
    delete<T extends departmentsDeleteArgs>(args: SelectSubset<T, departmentsDeleteArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Departments.
     * @param {departmentsUpdateArgs} args - Arguments to update one Departments.
     * @example
     * // Update one Departments
     * const departments = await prisma.departments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends departmentsUpdateArgs>(args: SelectSubset<T, departmentsUpdateArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {departmentsDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.departments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends departmentsDeleteManyArgs>(args?: SelectSubset<T, departmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const departments = await prisma.departments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends departmentsUpdateManyArgs>(args: SelectSubset<T, departmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Departments.
     * @param {departmentsUpsertArgs} args - Arguments to update or create a Departments.
     * @example
     * // Update or create a Departments
     * const departments = await prisma.departments.upsert({
     *   create: {
     *     // ... data to create a Departments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departments we want to update
     *   }
     * })
     */
    upsert<T extends departmentsUpsertArgs>(args: SelectSubset<T, departmentsUpsertArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.departments.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends departmentsCountArgs>(
      args?: Subset<T, departmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentsAggregateArgs>(args: Subset<T, DepartmentsAggregateArgs>): Prisma.PrismaPromise<GetDepartmentsAggregateType<T>>

    /**
     * Group by Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends departmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: departmentsGroupByArgs['orderBy'] }
        : { orderBy?: departmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, departmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the departments model
   */
  readonly fields: departmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for departments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__departmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends departments$parentArgs<ExtArgs> = {}>(args?: Subset<T, departments$parentArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends departments$childrenArgs<ExtArgs> = {}>(args?: Subset<T, departments$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends departments$usersArgs<ExtArgs> = {}>(args?: Subset<T, departments$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the departments model
   */ 
  interface departmentsFieldRefs {
    readonly id: FieldRef<"departments", 'Int'>
    readonly name: FieldRef<"departments", 'String'>
    readonly code: FieldRef<"departments", 'String'>
    readonly description: FieldRef<"departments", 'String'>
    readonly parentId: FieldRef<"departments", 'Int'>
    readonly isActive: FieldRef<"departments", 'Boolean'>
    readonly createdAt: FieldRef<"departments", 'DateTime'>
    readonly updatedAt: FieldRef<"departments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * departments findUnique
   */
  export type departmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments findUniqueOrThrow
   */
  export type departmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments findFirst
   */
  export type departmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments findFirstOrThrow
   */
  export type departmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments findMany
   */
  export type departmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments create
   */
  export type departmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a departments.
     */
    data: XOR<departmentsCreateInput, departmentsUncheckedCreateInput>
  }

  /**
   * departments createMany
   */
  export type departmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many departments.
     */
    data: departmentsCreateManyInput | departmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * departments createManyAndReturn
   */
  export type departmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many departments.
     */
    data: departmentsCreateManyInput | departmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * departments update
   */
  export type departmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a departments.
     */
    data: XOR<departmentsUpdateInput, departmentsUncheckedUpdateInput>
    /**
     * Choose, which departments to update.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments updateMany
   */
  export type departmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update departments.
     */
    data: XOR<departmentsUpdateManyMutationInput, departmentsUncheckedUpdateManyInput>
    /**
     * Filter which departments to update
     */
    where?: departmentsWhereInput
  }

  /**
   * departments upsert
   */
  export type departmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the departments to update in case it exists.
     */
    where: departmentsWhereUniqueInput
    /**
     * In case the departments found by the `where` argument doesn't exist, create a new departments with this data.
     */
    create: XOR<departmentsCreateInput, departmentsUncheckedCreateInput>
    /**
     * In case the departments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<departmentsUpdateInput, departmentsUncheckedUpdateInput>
  }

  /**
   * departments delete
   */
  export type departmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    /**
     * Filter which departments to delete.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments deleteMany
   */
  export type departmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to delete
     */
    where?: departmentsWhereInput
  }

  /**
   * departments.parent
   */
  export type departments$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    where?: departmentsWhereInput
  }

  /**
   * departments.children
   */
  export type departments$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    where?: departmentsWhereInput
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    cursor?: departmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments.users
   */
  export type departments$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * departments without action
   */
  export type departmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
  }


  /**
   * Model dtr_faults
   */

  export type AggregateDtr_faults = {
    _count: Dtr_faultsCountAggregateOutputType | null
    _avg: Dtr_faultsAvgAggregateOutputType | null
    _sum: Dtr_faultsSumAggregateOutputType | null
    _min: Dtr_faultsMinAggregateOutputType | null
    _max: Dtr_faultsMaxAggregateOutputType | null
  }

  export type Dtr_faultsAvgAggregateOutputType = {
    id: number | null
    dtrId: number | null
    affectedMeters: number | null
    outageMinutes: number | null
  }

  export type Dtr_faultsSumAggregateOutputType = {
    id: number | null
    dtrId: number | null
    affectedMeters: number | null
    outageMinutes: number | null
  }

  export type Dtr_faultsMinAggregateOutputType = {
    id: number | null
    dtrId: number | null
    faultType: $Enums.FaultType | null
    severity: $Enums.FaultSeverity | null
    occuredAt: Date | null
    resolvedAt: Date | null
    description: string | null
    rootCause: string | null
    resolution: string | null
    affectedMeters: number | null
    outageMinutes: number | null
    status: $Enums.FaultStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Dtr_faultsMaxAggregateOutputType = {
    id: number | null
    dtrId: number | null
    faultType: $Enums.FaultType | null
    severity: $Enums.FaultSeverity | null
    occuredAt: Date | null
    resolvedAt: Date | null
    description: string | null
    rootCause: string | null
    resolution: string | null
    affectedMeters: number | null
    outageMinutes: number | null
    status: $Enums.FaultStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Dtr_faultsCountAggregateOutputType = {
    id: number
    dtrId: number
    faultType: number
    severity: number
    occuredAt: number
    resolvedAt: number
    description: number
    rootCause: number
    resolution: number
    affectedMeters: number
    outageMinutes: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Dtr_faultsAvgAggregateInputType = {
    id?: true
    dtrId?: true
    affectedMeters?: true
    outageMinutes?: true
  }

  export type Dtr_faultsSumAggregateInputType = {
    id?: true
    dtrId?: true
    affectedMeters?: true
    outageMinutes?: true
  }

  export type Dtr_faultsMinAggregateInputType = {
    id?: true
    dtrId?: true
    faultType?: true
    severity?: true
    occuredAt?: true
    resolvedAt?: true
    description?: true
    rootCause?: true
    resolution?: true
    affectedMeters?: true
    outageMinutes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Dtr_faultsMaxAggregateInputType = {
    id?: true
    dtrId?: true
    faultType?: true
    severity?: true
    occuredAt?: true
    resolvedAt?: true
    description?: true
    rootCause?: true
    resolution?: true
    affectedMeters?: true
    outageMinutes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Dtr_faultsCountAggregateInputType = {
    id?: true
    dtrId?: true
    faultType?: true
    severity?: true
    occuredAt?: true
    resolvedAt?: true
    description?: true
    rootCause?: true
    resolution?: true
    affectedMeters?: true
    outageMinutes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Dtr_faultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dtr_faults to aggregate.
     */
    where?: dtr_faultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_faults to fetch.
     */
    orderBy?: dtr_faultsOrderByWithRelationInput | dtr_faultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dtr_faultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_faults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_faults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dtr_faults
    **/
    _count?: true | Dtr_faultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Dtr_faultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Dtr_faultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Dtr_faultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Dtr_faultsMaxAggregateInputType
  }

  export type GetDtr_faultsAggregateType<T extends Dtr_faultsAggregateArgs> = {
        [P in keyof T & keyof AggregateDtr_faults]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDtr_faults[P]>
      : GetScalarType<T[P], AggregateDtr_faults[P]>
  }




  export type dtr_faultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dtr_faultsWhereInput
    orderBy?: dtr_faultsOrderByWithAggregationInput | dtr_faultsOrderByWithAggregationInput[]
    by: Dtr_faultsScalarFieldEnum[] | Dtr_faultsScalarFieldEnum
    having?: dtr_faultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Dtr_faultsCountAggregateInputType | true
    _avg?: Dtr_faultsAvgAggregateInputType
    _sum?: Dtr_faultsSumAggregateInputType
    _min?: Dtr_faultsMinAggregateInputType
    _max?: Dtr_faultsMaxAggregateInputType
  }

  export type Dtr_faultsGroupByOutputType = {
    id: number
    dtrId: number
    faultType: $Enums.FaultType
    severity: $Enums.FaultSeverity
    occuredAt: Date
    resolvedAt: Date | null
    description: string
    rootCause: string | null
    resolution: string | null
    affectedMeters: number | null
    outageMinutes: number | null
    status: $Enums.FaultStatus
    createdAt: Date
    updatedAt: Date
    _count: Dtr_faultsCountAggregateOutputType | null
    _avg: Dtr_faultsAvgAggregateOutputType | null
    _sum: Dtr_faultsSumAggregateOutputType | null
    _min: Dtr_faultsMinAggregateOutputType | null
    _max: Dtr_faultsMaxAggregateOutputType | null
  }

  type GetDtr_faultsGroupByPayload<T extends dtr_faultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Dtr_faultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Dtr_faultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Dtr_faultsGroupByOutputType[P]>
            : GetScalarType<T[P], Dtr_faultsGroupByOutputType[P]>
        }
      >
    >


  export type dtr_faultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dtrId?: boolean
    faultType?: boolean
    severity?: boolean
    occuredAt?: boolean
    resolvedAt?: boolean
    description?: boolean
    rootCause?: boolean
    resolution?: boolean
    affectedMeters?: boolean
    outageMinutes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dtr_faults"]>

  export type dtr_faultsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dtrId?: boolean
    faultType?: boolean
    severity?: boolean
    occuredAt?: boolean
    resolvedAt?: boolean
    description?: boolean
    rootCause?: boolean
    resolution?: boolean
    affectedMeters?: boolean
    outageMinutes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dtr_faults"]>

  export type dtr_faultsSelectScalar = {
    id?: boolean
    dtrId?: boolean
    faultType?: boolean
    severity?: boolean
    occuredAt?: boolean
    resolvedAt?: boolean
    description?: boolean
    rootCause?: boolean
    resolution?: boolean
    affectedMeters?: boolean
    outageMinutes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type dtr_faultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }
  export type dtr_faultsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }

  export type $dtr_faultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dtr_faults"
    objects: {
      dtrs: Prisma.$dtrsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dtrId: number
      faultType: $Enums.FaultType
      severity: $Enums.FaultSeverity
      occuredAt: Date
      resolvedAt: Date | null
      description: string
      rootCause: string | null
      resolution: string | null
      affectedMeters: number | null
      outageMinutes: number | null
      status: $Enums.FaultStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dtr_faults"]>
    composites: {}
  }

  type dtr_faultsGetPayload<S extends boolean | null | undefined | dtr_faultsDefaultArgs> = $Result.GetResult<Prisma.$dtr_faultsPayload, S>

  type dtr_faultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<dtr_faultsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Dtr_faultsCountAggregateInputType | true
    }

  export interface dtr_faultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dtr_faults'], meta: { name: 'dtr_faults' } }
    /**
     * Find zero or one Dtr_faults that matches the filter.
     * @param {dtr_faultsFindUniqueArgs} args - Arguments to find a Dtr_faults
     * @example
     * // Get one Dtr_faults
     * const dtr_faults = await prisma.dtr_faults.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dtr_faultsFindUniqueArgs>(args: SelectSubset<T, dtr_faultsFindUniqueArgs<ExtArgs>>): Prisma__dtr_faultsClient<$Result.GetResult<Prisma.$dtr_faultsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dtr_faults that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {dtr_faultsFindUniqueOrThrowArgs} args - Arguments to find a Dtr_faults
     * @example
     * // Get one Dtr_faults
     * const dtr_faults = await prisma.dtr_faults.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dtr_faultsFindUniqueOrThrowArgs>(args: SelectSubset<T, dtr_faultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dtr_faultsClient<$Result.GetResult<Prisma.$dtr_faultsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dtr_faults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_faultsFindFirstArgs} args - Arguments to find a Dtr_faults
     * @example
     * // Get one Dtr_faults
     * const dtr_faults = await prisma.dtr_faults.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dtr_faultsFindFirstArgs>(args?: SelectSubset<T, dtr_faultsFindFirstArgs<ExtArgs>>): Prisma__dtr_faultsClient<$Result.GetResult<Prisma.$dtr_faultsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dtr_faults that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_faultsFindFirstOrThrowArgs} args - Arguments to find a Dtr_faults
     * @example
     * // Get one Dtr_faults
     * const dtr_faults = await prisma.dtr_faults.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dtr_faultsFindFirstOrThrowArgs>(args?: SelectSubset<T, dtr_faultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__dtr_faultsClient<$Result.GetResult<Prisma.$dtr_faultsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dtr_faults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_faultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dtr_faults
     * const dtr_faults = await prisma.dtr_faults.findMany()
     * 
     * // Get first 10 Dtr_faults
     * const dtr_faults = await prisma.dtr_faults.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dtr_faultsWithIdOnly = await prisma.dtr_faults.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dtr_faultsFindManyArgs>(args?: SelectSubset<T, dtr_faultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtr_faultsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dtr_faults.
     * @param {dtr_faultsCreateArgs} args - Arguments to create a Dtr_faults.
     * @example
     * // Create one Dtr_faults
     * const Dtr_faults = await prisma.dtr_faults.create({
     *   data: {
     *     // ... data to create a Dtr_faults
     *   }
     * })
     * 
     */
    create<T extends dtr_faultsCreateArgs>(args: SelectSubset<T, dtr_faultsCreateArgs<ExtArgs>>): Prisma__dtr_faultsClient<$Result.GetResult<Prisma.$dtr_faultsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dtr_faults.
     * @param {dtr_faultsCreateManyArgs} args - Arguments to create many Dtr_faults.
     * @example
     * // Create many Dtr_faults
     * const dtr_faults = await prisma.dtr_faults.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dtr_faultsCreateManyArgs>(args?: SelectSubset<T, dtr_faultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dtr_faults and returns the data saved in the database.
     * @param {dtr_faultsCreateManyAndReturnArgs} args - Arguments to create many Dtr_faults.
     * @example
     * // Create many Dtr_faults
     * const dtr_faults = await prisma.dtr_faults.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dtr_faults and only return the `id`
     * const dtr_faultsWithIdOnly = await prisma.dtr_faults.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends dtr_faultsCreateManyAndReturnArgs>(args?: SelectSubset<T, dtr_faultsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtr_faultsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dtr_faults.
     * @param {dtr_faultsDeleteArgs} args - Arguments to delete one Dtr_faults.
     * @example
     * // Delete one Dtr_faults
     * const Dtr_faults = await prisma.dtr_faults.delete({
     *   where: {
     *     // ... filter to delete one Dtr_faults
     *   }
     * })
     * 
     */
    delete<T extends dtr_faultsDeleteArgs>(args: SelectSubset<T, dtr_faultsDeleteArgs<ExtArgs>>): Prisma__dtr_faultsClient<$Result.GetResult<Prisma.$dtr_faultsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dtr_faults.
     * @param {dtr_faultsUpdateArgs} args - Arguments to update one Dtr_faults.
     * @example
     * // Update one Dtr_faults
     * const dtr_faults = await prisma.dtr_faults.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dtr_faultsUpdateArgs>(args: SelectSubset<T, dtr_faultsUpdateArgs<ExtArgs>>): Prisma__dtr_faultsClient<$Result.GetResult<Prisma.$dtr_faultsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dtr_faults.
     * @param {dtr_faultsDeleteManyArgs} args - Arguments to filter Dtr_faults to delete.
     * @example
     * // Delete a few Dtr_faults
     * const { count } = await prisma.dtr_faults.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dtr_faultsDeleteManyArgs>(args?: SelectSubset<T, dtr_faultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dtr_faults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_faultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dtr_faults
     * const dtr_faults = await prisma.dtr_faults.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dtr_faultsUpdateManyArgs>(args: SelectSubset<T, dtr_faultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dtr_faults.
     * @param {dtr_faultsUpsertArgs} args - Arguments to update or create a Dtr_faults.
     * @example
     * // Update or create a Dtr_faults
     * const dtr_faults = await prisma.dtr_faults.upsert({
     *   create: {
     *     // ... data to create a Dtr_faults
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dtr_faults we want to update
     *   }
     * })
     */
    upsert<T extends dtr_faultsUpsertArgs>(args: SelectSubset<T, dtr_faultsUpsertArgs<ExtArgs>>): Prisma__dtr_faultsClient<$Result.GetResult<Prisma.$dtr_faultsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dtr_faults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_faultsCountArgs} args - Arguments to filter Dtr_faults to count.
     * @example
     * // Count the number of Dtr_faults
     * const count = await prisma.dtr_faults.count({
     *   where: {
     *     // ... the filter for the Dtr_faults we want to count
     *   }
     * })
    **/
    count<T extends dtr_faultsCountArgs>(
      args?: Subset<T, dtr_faultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Dtr_faultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dtr_faults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dtr_faultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Dtr_faultsAggregateArgs>(args: Subset<T, Dtr_faultsAggregateArgs>): Prisma.PrismaPromise<GetDtr_faultsAggregateType<T>>

    /**
     * Group by Dtr_faults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_faultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dtr_faultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dtr_faultsGroupByArgs['orderBy'] }
        : { orderBy?: dtr_faultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dtr_faultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDtr_faultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dtr_faults model
   */
  readonly fields: dtr_faultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dtr_faults.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dtr_faultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dtrs<T extends dtrsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, dtrsDefaultArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dtr_faults model
   */ 
  interface dtr_faultsFieldRefs {
    readonly id: FieldRef<"dtr_faults", 'Int'>
    readonly dtrId: FieldRef<"dtr_faults", 'Int'>
    readonly faultType: FieldRef<"dtr_faults", 'FaultType'>
    readonly severity: FieldRef<"dtr_faults", 'FaultSeverity'>
    readonly occuredAt: FieldRef<"dtr_faults", 'DateTime'>
    readonly resolvedAt: FieldRef<"dtr_faults", 'DateTime'>
    readonly description: FieldRef<"dtr_faults", 'String'>
    readonly rootCause: FieldRef<"dtr_faults", 'String'>
    readonly resolution: FieldRef<"dtr_faults", 'String'>
    readonly affectedMeters: FieldRef<"dtr_faults", 'Int'>
    readonly outageMinutes: FieldRef<"dtr_faults", 'Int'>
    readonly status: FieldRef<"dtr_faults", 'FaultStatus'>
    readonly createdAt: FieldRef<"dtr_faults", 'DateTime'>
    readonly updatedAt: FieldRef<"dtr_faults", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * dtr_faults findUnique
   */
  export type dtr_faultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsInclude<ExtArgs> | null
    /**
     * Filter, which dtr_faults to fetch.
     */
    where: dtr_faultsWhereUniqueInput
  }

  /**
   * dtr_faults findUniqueOrThrow
   */
  export type dtr_faultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsInclude<ExtArgs> | null
    /**
     * Filter, which dtr_faults to fetch.
     */
    where: dtr_faultsWhereUniqueInput
  }

  /**
   * dtr_faults findFirst
   */
  export type dtr_faultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsInclude<ExtArgs> | null
    /**
     * Filter, which dtr_faults to fetch.
     */
    where?: dtr_faultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_faults to fetch.
     */
    orderBy?: dtr_faultsOrderByWithRelationInput | dtr_faultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dtr_faults.
     */
    cursor?: dtr_faultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_faults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_faults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dtr_faults.
     */
    distinct?: Dtr_faultsScalarFieldEnum | Dtr_faultsScalarFieldEnum[]
  }

  /**
   * dtr_faults findFirstOrThrow
   */
  export type dtr_faultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsInclude<ExtArgs> | null
    /**
     * Filter, which dtr_faults to fetch.
     */
    where?: dtr_faultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_faults to fetch.
     */
    orderBy?: dtr_faultsOrderByWithRelationInput | dtr_faultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dtr_faults.
     */
    cursor?: dtr_faultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_faults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_faults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dtr_faults.
     */
    distinct?: Dtr_faultsScalarFieldEnum | Dtr_faultsScalarFieldEnum[]
  }

  /**
   * dtr_faults findMany
   */
  export type dtr_faultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsInclude<ExtArgs> | null
    /**
     * Filter, which dtr_faults to fetch.
     */
    where?: dtr_faultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_faults to fetch.
     */
    orderBy?: dtr_faultsOrderByWithRelationInput | dtr_faultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dtr_faults.
     */
    cursor?: dtr_faultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_faults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_faults.
     */
    skip?: number
    distinct?: Dtr_faultsScalarFieldEnum | Dtr_faultsScalarFieldEnum[]
  }

  /**
   * dtr_faults create
   */
  export type dtr_faultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsInclude<ExtArgs> | null
    /**
     * The data needed to create a dtr_faults.
     */
    data: XOR<dtr_faultsCreateInput, dtr_faultsUncheckedCreateInput>
  }

  /**
   * dtr_faults createMany
   */
  export type dtr_faultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dtr_faults.
     */
    data: dtr_faultsCreateManyInput | dtr_faultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dtr_faults createManyAndReturn
   */
  export type dtr_faultsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many dtr_faults.
     */
    data: dtr_faultsCreateManyInput | dtr_faultsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * dtr_faults update
   */
  export type dtr_faultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsInclude<ExtArgs> | null
    /**
     * The data needed to update a dtr_faults.
     */
    data: XOR<dtr_faultsUpdateInput, dtr_faultsUncheckedUpdateInput>
    /**
     * Choose, which dtr_faults to update.
     */
    where: dtr_faultsWhereUniqueInput
  }

  /**
   * dtr_faults updateMany
   */
  export type dtr_faultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dtr_faults.
     */
    data: XOR<dtr_faultsUpdateManyMutationInput, dtr_faultsUncheckedUpdateManyInput>
    /**
     * Filter which dtr_faults to update
     */
    where?: dtr_faultsWhereInput
  }

  /**
   * dtr_faults upsert
   */
  export type dtr_faultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsInclude<ExtArgs> | null
    /**
     * The filter to search for the dtr_faults to update in case it exists.
     */
    where: dtr_faultsWhereUniqueInput
    /**
     * In case the dtr_faults found by the `where` argument doesn't exist, create a new dtr_faults with this data.
     */
    create: XOR<dtr_faultsCreateInput, dtr_faultsUncheckedCreateInput>
    /**
     * In case the dtr_faults was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dtr_faultsUpdateInput, dtr_faultsUncheckedUpdateInput>
  }

  /**
   * dtr_faults delete
   */
  export type dtr_faultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsInclude<ExtArgs> | null
    /**
     * Filter which dtr_faults to delete.
     */
    where: dtr_faultsWhereUniqueInput
  }

  /**
   * dtr_faults deleteMany
   */
  export type dtr_faultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dtr_faults to delete
     */
    where?: dtr_faultsWhereInput
  }

  /**
   * dtr_faults without action
   */
  export type dtr_faultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsInclude<ExtArgs> | null
  }


  /**
   * Model dtr_maintenance
   */

  export type AggregateDtr_maintenance = {
    _count: Dtr_maintenanceCountAggregateOutputType | null
    _avg: Dtr_maintenanceAvgAggregateOutputType | null
    _sum: Dtr_maintenanceSumAggregateOutputType | null
    _min: Dtr_maintenanceMinAggregateOutputType | null
    _max: Dtr_maintenanceMaxAggregateOutputType | null
  }

  export type Dtr_maintenanceAvgAggregateOutputType = {
    id: number | null
    dtrId: number | null
    oilDielectricTest: number | null
    oilAcidityTest: number | null
    moistureContent: number | null
  }

  export type Dtr_maintenanceSumAggregateOutputType = {
    id: number | null
    dtrId: number | null
    oilDielectricTest: number | null
    oilAcidityTest: number | null
    moistureContent: number | null
  }

  export type Dtr_maintenanceMinAggregateOutputType = {
    id: number | null
    dtrId: number | null
    maintenanceType: $Enums.MaintenanceType | null
    scheduledDate: Date | null
    completedDate: Date | null
    workDone: string | null
    findings: string | null
    recommendations: string | null
    oilDielectricTest: number | null
    oilAcidityTest: number | null
    moistureContent: number | null
    performedBy: string | null
    verifiedBy: string | null
    status: $Enums.MaintenanceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Dtr_maintenanceMaxAggregateOutputType = {
    id: number | null
    dtrId: number | null
    maintenanceType: $Enums.MaintenanceType | null
    scheduledDate: Date | null
    completedDate: Date | null
    workDone: string | null
    findings: string | null
    recommendations: string | null
    oilDielectricTest: number | null
    oilAcidityTest: number | null
    moistureContent: number | null
    performedBy: string | null
    verifiedBy: string | null
    status: $Enums.MaintenanceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Dtr_maintenanceCountAggregateOutputType = {
    id: number
    dtrId: number
    maintenanceType: number
    scheduledDate: number
    completedDate: number
    workDone: number
    findings: number
    recommendations: number
    oilDielectricTest: number
    oilAcidityTest: number
    moistureContent: number
    performedBy: number
    verifiedBy: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Dtr_maintenanceAvgAggregateInputType = {
    id?: true
    dtrId?: true
    oilDielectricTest?: true
    oilAcidityTest?: true
    moistureContent?: true
  }

  export type Dtr_maintenanceSumAggregateInputType = {
    id?: true
    dtrId?: true
    oilDielectricTest?: true
    oilAcidityTest?: true
    moistureContent?: true
  }

  export type Dtr_maintenanceMinAggregateInputType = {
    id?: true
    dtrId?: true
    maintenanceType?: true
    scheduledDate?: true
    completedDate?: true
    workDone?: true
    findings?: true
    recommendations?: true
    oilDielectricTest?: true
    oilAcidityTest?: true
    moistureContent?: true
    performedBy?: true
    verifiedBy?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Dtr_maintenanceMaxAggregateInputType = {
    id?: true
    dtrId?: true
    maintenanceType?: true
    scheduledDate?: true
    completedDate?: true
    workDone?: true
    findings?: true
    recommendations?: true
    oilDielectricTest?: true
    oilAcidityTest?: true
    moistureContent?: true
    performedBy?: true
    verifiedBy?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Dtr_maintenanceCountAggregateInputType = {
    id?: true
    dtrId?: true
    maintenanceType?: true
    scheduledDate?: true
    completedDate?: true
    workDone?: true
    findings?: true
    recommendations?: true
    oilDielectricTest?: true
    oilAcidityTest?: true
    moistureContent?: true
    performedBy?: true
    verifiedBy?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Dtr_maintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dtr_maintenance to aggregate.
     */
    where?: dtr_maintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_maintenances to fetch.
     */
    orderBy?: dtr_maintenanceOrderByWithRelationInput | dtr_maintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dtr_maintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dtr_maintenances
    **/
    _count?: true | Dtr_maintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Dtr_maintenanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Dtr_maintenanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Dtr_maintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Dtr_maintenanceMaxAggregateInputType
  }

  export type GetDtr_maintenanceAggregateType<T extends Dtr_maintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateDtr_maintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDtr_maintenance[P]>
      : GetScalarType<T[P], AggregateDtr_maintenance[P]>
  }




  export type dtr_maintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dtr_maintenanceWhereInput
    orderBy?: dtr_maintenanceOrderByWithAggregationInput | dtr_maintenanceOrderByWithAggregationInput[]
    by: Dtr_maintenanceScalarFieldEnum[] | Dtr_maintenanceScalarFieldEnum
    having?: dtr_maintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Dtr_maintenanceCountAggregateInputType | true
    _avg?: Dtr_maintenanceAvgAggregateInputType
    _sum?: Dtr_maintenanceSumAggregateInputType
    _min?: Dtr_maintenanceMinAggregateInputType
    _max?: Dtr_maintenanceMaxAggregateInputType
  }

  export type Dtr_maintenanceGroupByOutputType = {
    id: number
    dtrId: number
    maintenanceType: $Enums.MaintenanceType
    scheduledDate: Date
    completedDate: Date | null
    workDone: string
    findings: string | null
    recommendations: string | null
    oilDielectricTest: number | null
    oilAcidityTest: number | null
    moistureContent: number | null
    performedBy: string
    verifiedBy: string | null
    status: $Enums.MaintenanceStatus
    createdAt: Date
    updatedAt: Date
    _count: Dtr_maintenanceCountAggregateOutputType | null
    _avg: Dtr_maintenanceAvgAggregateOutputType | null
    _sum: Dtr_maintenanceSumAggregateOutputType | null
    _min: Dtr_maintenanceMinAggregateOutputType | null
    _max: Dtr_maintenanceMaxAggregateOutputType | null
  }

  type GetDtr_maintenanceGroupByPayload<T extends dtr_maintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Dtr_maintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Dtr_maintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Dtr_maintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], Dtr_maintenanceGroupByOutputType[P]>
        }
      >
    >


  export type dtr_maintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dtrId?: boolean
    maintenanceType?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    workDone?: boolean
    findings?: boolean
    recommendations?: boolean
    oilDielectricTest?: boolean
    oilAcidityTest?: boolean
    moistureContent?: boolean
    performedBy?: boolean
    verifiedBy?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dtr_maintenance"]>

  export type dtr_maintenanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dtrId?: boolean
    maintenanceType?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    workDone?: boolean
    findings?: boolean
    recommendations?: boolean
    oilDielectricTest?: boolean
    oilAcidityTest?: boolean
    moistureContent?: boolean
    performedBy?: boolean
    verifiedBy?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dtr_maintenance"]>

  export type dtr_maintenanceSelectScalar = {
    id?: boolean
    dtrId?: boolean
    maintenanceType?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    workDone?: boolean
    findings?: boolean
    recommendations?: boolean
    oilDielectricTest?: boolean
    oilAcidityTest?: boolean
    moistureContent?: boolean
    performedBy?: boolean
    verifiedBy?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type dtr_maintenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }
  export type dtr_maintenanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }

  export type $dtr_maintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dtr_maintenance"
    objects: {
      dtrs: Prisma.$dtrsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dtrId: number
      maintenanceType: $Enums.MaintenanceType
      scheduledDate: Date
      completedDate: Date | null
      workDone: string
      findings: string | null
      recommendations: string | null
      oilDielectricTest: number | null
      oilAcidityTest: number | null
      moistureContent: number | null
      performedBy: string
      verifiedBy: string | null
      status: $Enums.MaintenanceStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dtr_maintenance"]>
    composites: {}
  }

  type dtr_maintenanceGetPayload<S extends boolean | null | undefined | dtr_maintenanceDefaultArgs> = $Result.GetResult<Prisma.$dtr_maintenancePayload, S>

  type dtr_maintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<dtr_maintenanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Dtr_maintenanceCountAggregateInputType | true
    }

  export interface dtr_maintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dtr_maintenance'], meta: { name: 'dtr_maintenance' } }
    /**
     * Find zero or one Dtr_maintenance that matches the filter.
     * @param {dtr_maintenanceFindUniqueArgs} args - Arguments to find a Dtr_maintenance
     * @example
     * // Get one Dtr_maintenance
     * const dtr_maintenance = await prisma.dtr_maintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dtr_maintenanceFindUniqueArgs>(args: SelectSubset<T, dtr_maintenanceFindUniqueArgs<ExtArgs>>): Prisma__dtr_maintenanceClient<$Result.GetResult<Prisma.$dtr_maintenancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dtr_maintenance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {dtr_maintenanceFindUniqueOrThrowArgs} args - Arguments to find a Dtr_maintenance
     * @example
     * // Get one Dtr_maintenance
     * const dtr_maintenance = await prisma.dtr_maintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dtr_maintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, dtr_maintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dtr_maintenanceClient<$Result.GetResult<Prisma.$dtr_maintenancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dtr_maintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_maintenanceFindFirstArgs} args - Arguments to find a Dtr_maintenance
     * @example
     * // Get one Dtr_maintenance
     * const dtr_maintenance = await prisma.dtr_maintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dtr_maintenanceFindFirstArgs>(args?: SelectSubset<T, dtr_maintenanceFindFirstArgs<ExtArgs>>): Prisma__dtr_maintenanceClient<$Result.GetResult<Prisma.$dtr_maintenancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dtr_maintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_maintenanceFindFirstOrThrowArgs} args - Arguments to find a Dtr_maintenance
     * @example
     * // Get one Dtr_maintenance
     * const dtr_maintenance = await prisma.dtr_maintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dtr_maintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, dtr_maintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__dtr_maintenanceClient<$Result.GetResult<Prisma.$dtr_maintenancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dtr_maintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_maintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dtr_maintenances
     * const dtr_maintenances = await prisma.dtr_maintenance.findMany()
     * 
     * // Get first 10 Dtr_maintenances
     * const dtr_maintenances = await prisma.dtr_maintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dtr_maintenanceWithIdOnly = await prisma.dtr_maintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dtr_maintenanceFindManyArgs>(args?: SelectSubset<T, dtr_maintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtr_maintenancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dtr_maintenance.
     * @param {dtr_maintenanceCreateArgs} args - Arguments to create a Dtr_maintenance.
     * @example
     * // Create one Dtr_maintenance
     * const Dtr_maintenance = await prisma.dtr_maintenance.create({
     *   data: {
     *     // ... data to create a Dtr_maintenance
     *   }
     * })
     * 
     */
    create<T extends dtr_maintenanceCreateArgs>(args: SelectSubset<T, dtr_maintenanceCreateArgs<ExtArgs>>): Prisma__dtr_maintenanceClient<$Result.GetResult<Prisma.$dtr_maintenancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dtr_maintenances.
     * @param {dtr_maintenanceCreateManyArgs} args - Arguments to create many Dtr_maintenances.
     * @example
     * // Create many Dtr_maintenances
     * const dtr_maintenance = await prisma.dtr_maintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dtr_maintenanceCreateManyArgs>(args?: SelectSubset<T, dtr_maintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dtr_maintenances and returns the data saved in the database.
     * @param {dtr_maintenanceCreateManyAndReturnArgs} args - Arguments to create many Dtr_maintenances.
     * @example
     * // Create many Dtr_maintenances
     * const dtr_maintenance = await prisma.dtr_maintenance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dtr_maintenances and only return the `id`
     * const dtr_maintenanceWithIdOnly = await prisma.dtr_maintenance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends dtr_maintenanceCreateManyAndReturnArgs>(args?: SelectSubset<T, dtr_maintenanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtr_maintenancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dtr_maintenance.
     * @param {dtr_maintenanceDeleteArgs} args - Arguments to delete one Dtr_maintenance.
     * @example
     * // Delete one Dtr_maintenance
     * const Dtr_maintenance = await prisma.dtr_maintenance.delete({
     *   where: {
     *     // ... filter to delete one Dtr_maintenance
     *   }
     * })
     * 
     */
    delete<T extends dtr_maintenanceDeleteArgs>(args: SelectSubset<T, dtr_maintenanceDeleteArgs<ExtArgs>>): Prisma__dtr_maintenanceClient<$Result.GetResult<Prisma.$dtr_maintenancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dtr_maintenance.
     * @param {dtr_maintenanceUpdateArgs} args - Arguments to update one Dtr_maintenance.
     * @example
     * // Update one Dtr_maintenance
     * const dtr_maintenance = await prisma.dtr_maintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dtr_maintenanceUpdateArgs>(args: SelectSubset<T, dtr_maintenanceUpdateArgs<ExtArgs>>): Prisma__dtr_maintenanceClient<$Result.GetResult<Prisma.$dtr_maintenancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dtr_maintenances.
     * @param {dtr_maintenanceDeleteManyArgs} args - Arguments to filter Dtr_maintenances to delete.
     * @example
     * // Delete a few Dtr_maintenances
     * const { count } = await prisma.dtr_maintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dtr_maintenanceDeleteManyArgs>(args?: SelectSubset<T, dtr_maintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dtr_maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_maintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dtr_maintenances
     * const dtr_maintenance = await prisma.dtr_maintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dtr_maintenanceUpdateManyArgs>(args: SelectSubset<T, dtr_maintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dtr_maintenance.
     * @param {dtr_maintenanceUpsertArgs} args - Arguments to update or create a Dtr_maintenance.
     * @example
     * // Update or create a Dtr_maintenance
     * const dtr_maintenance = await prisma.dtr_maintenance.upsert({
     *   create: {
     *     // ... data to create a Dtr_maintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dtr_maintenance we want to update
     *   }
     * })
     */
    upsert<T extends dtr_maintenanceUpsertArgs>(args: SelectSubset<T, dtr_maintenanceUpsertArgs<ExtArgs>>): Prisma__dtr_maintenanceClient<$Result.GetResult<Prisma.$dtr_maintenancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dtr_maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_maintenanceCountArgs} args - Arguments to filter Dtr_maintenances to count.
     * @example
     * // Count the number of Dtr_maintenances
     * const count = await prisma.dtr_maintenance.count({
     *   where: {
     *     // ... the filter for the Dtr_maintenances we want to count
     *   }
     * })
    **/
    count<T extends dtr_maintenanceCountArgs>(
      args?: Subset<T, dtr_maintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Dtr_maintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dtr_maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dtr_maintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Dtr_maintenanceAggregateArgs>(args: Subset<T, Dtr_maintenanceAggregateArgs>): Prisma.PrismaPromise<GetDtr_maintenanceAggregateType<T>>

    /**
     * Group by Dtr_maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_maintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dtr_maintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dtr_maintenanceGroupByArgs['orderBy'] }
        : { orderBy?: dtr_maintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dtr_maintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDtr_maintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dtr_maintenance model
   */
  readonly fields: dtr_maintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dtr_maintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dtr_maintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dtrs<T extends dtrsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, dtrsDefaultArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dtr_maintenance model
   */ 
  interface dtr_maintenanceFieldRefs {
    readonly id: FieldRef<"dtr_maintenance", 'Int'>
    readonly dtrId: FieldRef<"dtr_maintenance", 'Int'>
    readonly maintenanceType: FieldRef<"dtr_maintenance", 'MaintenanceType'>
    readonly scheduledDate: FieldRef<"dtr_maintenance", 'DateTime'>
    readonly completedDate: FieldRef<"dtr_maintenance", 'DateTime'>
    readonly workDone: FieldRef<"dtr_maintenance", 'String'>
    readonly findings: FieldRef<"dtr_maintenance", 'String'>
    readonly recommendations: FieldRef<"dtr_maintenance", 'String'>
    readonly oilDielectricTest: FieldRef<"dtr_maintenance", 'Float'>
    readonly oilAcidityTest: FieldRef<"dtr_maintenance", 'Float'>
    readonly moistureContent: FieldRef<"dtr_maintenance", 'Float'>
    readonly performedBy: FieldRef<"dtr_maintenance", 'String'>
    readonly verifiedBy: FieldRef<"dtr_maintenance", 'String'>
    readonly status: FieldRef<"dtr_maintenance", 'MaintenanceStatus'>
    readonly createdAt: FieldRef<"dtr_maintenance", 'DateTime'>
    readonly updatedAt: FieldRef<"dtr_maintenance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * dtr_maintenance findUnique
   */
  export type dtr_maintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceInclude<ExtArgs> | null
    /**
     * Filter, which dtr_maintenance to fetch.
     */
    where: dtr_maintenanceWhereUniqueInput
  }

  /**
   * dtr_maintenance findUniqueOrThrow
   */
  export type dtr_maintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceInclude<ExtArgs> | null
    /**
     * Filter, which dtr_maintenance to fetch.
     */
    where: dtr_maintenanceWhereUniqueInput
  }

  /**
   * dtr_maintenance findFirst
   */
  export type dtr_maintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceInclude<ExtArgs> | null
    /**
     * Filter, which dtr_maintenance to fetch.
     */
    where?: dtr_maintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_maintenances to fetch.
     */
    orderBy?: dtr_maintenanceOrderByWithRelationInput | dtr_maintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dtr_maintenances.
     */
    cursor?: dtr_maintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dtr_maintenances.
     */
    distinct?: Dtr_maintenanceScalarFieldEnum | Dtr_maintenanceScalarFieldEnum[]
  }

  /**
   * dtr_maintenance findFirstOrThrow
   */
  export type dtr_maintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceInclude<ExtArgs> | null
    /**
     * Filter, which dtr_maintenance to fetch.
     */
    where?: dtr_maintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_maintenances to fetch.
     */
    orderBy?: dtr_maintenanceOrderByWithRelationInput | dtr_maintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dtr_maintenances.
     */
    cursor?: dtr_maintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dtr_maintenances.
     */
    distinct?: Dtr_maintenanceScalarFieldEnum | Dtr_maintenanceScalarFieldEnum[]
  }

  /**
   * dtr_maintenance findMany
   */
  export type dtr_maintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceInclude<ExtArgs> | null
    /**
     * Filter, which dtr_maintenances to fetch.
     */
    where?: dtr_maintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_maintenances to fetch.
     */
    orderBy?: dtr_maintenanceOrderByWithRelationInput | dtr_maintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dtr_maintenances.
     */
    cursor?: dtr_maintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_maintenances.
     */
    skip?: number
    distinct?: Dtr_maintenanceScalarFieldEnum | Dtr_maintenanceScalarFieldEnum[]
  }

  /**
   * dtr_maintenance create
   */
  export type dtr_maintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a dtr_maintenance.
     */
    data: XOR<dtr_maintenanceCreateInput, dtr_maintenanceUncheckedCreateInput>
  }

  /**
   * dtr_maintenance createMany
   */
  export type dtr_maintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dtr_maintenances.
     */
    data: dtr_maintenanceCreateManyInput | dtr_maintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dtr_maintenance createManyAndReturn
   */
  export type dtr_maintenanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many dtr_maintenances.
     */
    data: dtr_maintenanceCreateManyInput | dtr_maintenanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * dtr_maintenance update
   */
  export type dtr_maintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a dtr_maintenance.
     */
    data: XOR<dtr_maintenanceUpdateInput, dtr_maintenanceUncheckedUpdateInput>
    /**
     * Choose, which dtr_maintenance to update.
     */
    where: dtr_maintenanceWhereUniqueInput
  }

  /**
   * dtr_maintenance updateMany
   */
  export type dtr_maintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dtr_maintenances.
     */
    data: XOR<dtr_maintenanceUpdateManyMutationInput, dtr_maintenanceUncheckedUpdateManyInput>
    /**
     * Filter which dtr_maintenances to update
     */
    where?: dtr_maintenanceWhereInput
  }

  /**
   * dtr_maintenance upsert
   */
  export type dtr_maintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the dtr_maintenance to update in case it exists.
     */
    where: dtr_maintenanceWhereUniqueInput
    /**
     * In case the dtr_maintenance found by the `where` argument doesn't exist, create a new dtr_maintenance with this data.
     */
    create: XOR<dtr_maintenanceCreateInput, dtr_maintenanceUncheckedCreateInput>
    /**
     * In case the dtr_maintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dtr_maintenanceUpdateInput, dtr_maintenanceUncheckedUpdateInput>
  }

  /**
   * dtr_maintenance delete
   */
  export type dtr_maintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceInclude<ExtArgs> | null
    /**
     * Filter which dtr_maintenance to delete.
     */
    where: dtr_maintenanceWhereUniqueInput
  }

  /**
   * dtr_maintenance deleteMany
   */
  export type dtr_maintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dtr_maintenances to delete
     */
    where?: dtr_maintenanceWhereInput
  }

  /**
   * dtr_maintenance without action
   */
  export type dtr_maintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceInclude<ExtArgs> | null
  }


  /**
   * Model dtr_readings
   */

  export type AggregateDtr_readings = {
    _count: Dtr_readingsCountAggregateOutputType | null
    _avg: Dtr_readingsAvgAggregateOutputType | null
    _sum: Dtr_readingsSumAggregateOutputType | null
    _min: Dtr_readingsMinAggregateOutputType | null
    _max: Dtr_readingsMaxAggregateOutputType | null
  }

  export type Dtr_readingsAvgAggregateOutputType = {
    id: number | null
    dtrId: number | null
    loadKVA: number | null
    loadPercentage: number | null
    powerFactor: number | null
    oilTemperature: number | null
    windingTemperature: number | null
    ambientTemperature: number | null
    frequency: number | null
    voltageUnbalance: number | null
    currentUnbalance: number | null
  }

  export type Dtr_readingsSumAggregateOutputType = {
    id: number | null
    dtrId: number | null
    loadKVA: number | null
    loadPercentage: number | null
    powerFactor: number | null
    oilTemperature: number | null
    windingTemperature: number | null
    ambientTemperature: number | null
    frequency: number | null
    voltageUnbalance: number | null
    currentUnbalance: number | null
  }

  export type Dtr_readingsMinAggregateOutputType = {
    id: number | null
    dtrId: number | null
    readingDate: Date | null
    readingType: $Enums.DTRReadingType | null
    loadKVA: number | null
    loadPercentage: number | null
    powerFactor: number | null
    oilTemperature: number | null
    windingTemperature: number | null
    ambientTemperature: number | null
    frequency: number | null
    voltageUnbalance: number | null
    currentUnbalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Dtr_readingsMaxAggregateOutputType = {
    id: number | null
    dtrId: number | null
    readingDate: Date | null
    readingType: $Enums.DTRReadingType | null
    loadKVA: number | null
    loadPercentage: number | null
    powerFactor: number | null
    oilTemperature: number | null
    windingTemperature: number | null
    ambientTemperature: number | null
    frequency: number | null
    voltageUnbalance: number | null
    currentUnbalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Dtr_readingsCountAggregateOutputType = {
    id: number
    dtrId: number
    readingDate: number
    readingType: number
    loadKVA: number
    loadPercentage: number
    primaryVoltage: number
    secondaryVoltage: number
    primaryCurrent: number
    secondaryCurrent: number
    powerFactor: number
    oilTemperature: number
    windingTemperature: number
    ambientTemperature: number
    frequency: number
    voltageUnbalance: number
    currentUnbalance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Dtr_readingsAvgAggregateInputType = {
    id?: true
    dtrId?: true
    loadKVA?: true
    loadPercentage?: true
    powerFactor?: true
    oilTemperature?: true
    windingTemperature?: true
    ambientTemperature?: true
    frequency?: true
    voltageUnbalance?: true
    currentUnbalance?: true
  }

  export type Dtr_readingsSumAggregateInputType = {
    id?: true
    dtrId?: true
    loadKVA?: true
    loadPercentage?: true
    powerFactor?: true
    oilTemperature?: true
    windingTemperature?: true
    ambientTemperature?: true
    frequency?: true
    voltageUnbalance?: true
    currentUnbalance?: true
  }

  export type Dtr_readingsMinAggregateInputType = {
    id?: true
    dtrId?: true
    readingDate?: true
    readingType?: true
    loadKVA?: true
    loadPercentage?: true
    powerFactor?: true
    oilTemperature?: true
    windingTemperature?: true
    ambientTemperature?: true
    frequency?: true
    voltageUnbalance?: true
    currentUnbalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Dtr_readingsMaxAggregateInputType = {
    id?: true
    dtrId?: true
    readingDate?: true
    readingType?: true
    loadKVA?: true
    loadPercentage?: true
    powerFactor?: true
    oilTemperature?: true
    windingTemperature?: true
    ambientTemperature?: true
    frequency?: true
    voltageUnbalance?: true
    currentUnbalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Dtr_readingsCountAggregateInputType = {
    id?: true
    dtrId?: true
    readingDate?: true
    readingType?: true
    loadKVA?: true
    loadPercentage?: true
    primaryVoltage?: true
    secondaryVoltage?: true
    primaryCurrent?: true
    secondaryCurrent?: true
    powerFactor?: true
    oilTemperature?: true
    windingTemperature?: true
    ambientTemperature?: true
    frequency?: true
    voltageUnbalance?: true
    currentUnbalance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Dtr_readingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dtr_readings to aggregate.
     */
    where?: dtr_readingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_readings to fetch.
     */
    orderBy?: dtr_readingsOrderByWithRelationInput | dtr_readingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dtr_readingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_readings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dtr_readings
    **/
    _count?: true | Dtr_readingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Dtr_readingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Dtr_readingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Dtr_readingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Dtr_readingsMaxAggregateInputType
  }

  export type GetDtr_readingsAggregateType<T extends Dtr_readingsAggregateArgs> = {
        [P in keyof T & keyof AggregateDtr_readings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDtr_readings[P]>
      : GetScalarType<T[P], AggregateDtr_readings[P]>
  }




  export type dtr_readingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dtr_readingsWhereInput
    orderBy?: dtr_readingsOrderByWithAggregationInput | dtr_readingsOrderByWithAggregationInput[]
    by: Dtr_readingsScalarFieldEnum[] | Dtr_readingsScalarFieldEnum
    having?: dtr_readingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Dtr_readingsCountAggregateInputType | true
    _avg?: Dtr_readingsAvgAggregateInputType
    _sum?: Dtr_readingsSumAggregateInputType
    _min?: Dtr_readingsMinAggregateInputType
    _max?: Dtr_readingsMaxAggregateInputType
  }

  export type Dtr_readingsGroupByOutputType = {
    id: number
    dtrId: number
    readingDate: Date
    readingType: $Enums.DTRReadingType
    loadKVA: number
    loadPercentage: number
    primaryVoltage: JsonValue
    secondaryVoltage: JsonValue
    primaryCurrent: JsonValue
    secondaryCurrent: JsonValue
    powerFactor: number | null
    oilTemperature: number | null
    windingTemperature: number | null
    ambientTemperature: number | null
    frequency: number | null
    voltageUnbalance: number | null
    currentUnbalance: number | null
    createdAt: Date
    updatedAt: Date
    _count: Dtr_readingsCountAggregateOutputType | null
    _avg: Dtr_readingsAvgAggregateOutputType | null
    _sum: Dtr_readingsSumAggregateOutputType | null
    _min: Dtr_readingsMinAggregateOutputType | null
    _max: Dtr_readingsMaxAggregateOutputType | null
  }

  type GetDtr_readingsGroupByPayload<T extends dtr_readingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Dtr_readingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Dtr_readingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Dtr_readingsGroupByOutputType[P]>
            : GetScalarType<T[P], Dtr_readingsGroupByOutputType[P]>
        }
      >
    >


  export type dtr_readingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dtrId?: boolean
    readingDate?: boolean
    readingType?: boolean
    loadKVA?: boolean
    loadPercentage?: boolean
    primaryVoltage?: boolean
    secondaryVoltage?: boolean
    primaryCurrent?: boolean
    secondaryCurrent?: boolean
    powerFactor?: boolean
    oilTemperature?: boolean
    windingTemperature?: boolean
    ambientTemperature?: boolean
    frequency?: boolean
    voltageUnbalance?: boolean
    currentUnbalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dtr_readings"]>

  export type dtr_readingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dtrId?: boolean
    readingDate?: boolean
    readingType?: boolean
    loadKVA?: boolean
    loadPercentage?: boolean
    primaryVoltage?: boolean
    secondaryVoltage?: boolean
    primaryCurrent?: boolean
    secondaryCurrent?: boolean
    powerFactor?: boolean
    oilTemperature?: boolean
    windingTemperature?: boolean
    ambientTemperature?: boolean
    frequency?: boolean
    voltageUnbalance?: boolean
    currentUnbalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dtr_readings"]>

  export type dtr_readingsSelectScalar = {
    id?: boolean
    dtrId?: boolean
    readingDate?: boolean
    readingType?: boolean
    loadKVA?: boolean
    loadPercentage?: boolean
    primaryVoltage?: boolean
    secondaryVoltage?: boolean
    primaryCurrent?: boolean
    secondaryCurrent?: boolean
    powerFactor?: boolean
    oilTemperature?: boolean
    windingTemperature?: boolean
    ambientTemperature?: boolean
    frequency?: boolean
    voltageUnbalance?: boolean
    currentUnbalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type dtr_readingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }
  export type dtr_readingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dtrs?: boolean | dtrsDefaultArgs<ExtArgs>
  }

  export type $dtr_readingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dtr_readings"
    objects: {
      dtrs: Prisma.$dtrsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dtrId: number
      readingDate: Date
      readingType: $Enums.DTRReadingType
      loadKVA: number
      loadPercentage: number
      primaryVoltage: Prisma.JsonValue
      secondaryVoltage: Prisma.JsonValue
      primaryCurrent: Prisma.JsonValue
      secondaryCurrent: Prisma.JsonValue
      powerFactor: number | null
      oilTemperature: number | null
      windingTemperature: number | null
      ambientTemperature: number | null
      frequency: number | null
      voltageUnbalance: number | null
      currentUnbalance: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dtr_readings"]>
    composites: {}
  }

  type dtr_readingsGetPayload<S extends boolean | null | undefined | dtr_readingsDefaultArgs> = $Result.GetResult<Prisma.$dtr_readingsPayload, S>

  type dtr_readingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<dtr_readingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Dtr_readingsCountAggregateInputType | true
    }

  export interface dtr_readingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dtr_readings'], meta: { name: 'dtr_readings' } }
    /**
     * Find zero or one Dtr_readings that matches the filter.
     * @param {dtr_readingsFindUniqueArgs} args - Arguments to find a Dtr_readings
     * @example
     * // Get one Dtr_readings
     * const dtr_readings = await prisma.dtr_readings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dtr_readingsFindUniqueArgs>(args: SelectSubset<T, dtr_readingsFindUniqueArgs<ExtArgs>>): Prisma__dtr_readingsClient<$Result.GetResult<Prisma.$dtr_readingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dtr_readings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {dtr_readingsFindUniqueOrThrowArgs} args - Arguments to find a Dtr_readings
     * @example
     * // Get one Dtr_readings
     * const dtr_readings = await prisma.dtr_readings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dtr_readingsFindUniqueOrThrowArgs>(args: SelectSubset<T, dtr_readingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dtr_readingsClient<$Result.GetResult<Prisma.$dtr_readingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dtr_readings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_readingsFindFirstArgs} args - Arguments to find a Dtr_readings
     * @example
     * // Get one Dtr_readings
     * const dtr_readings = await prisma.dtr_readings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dtr_readingsFindFirstArgs>(args?: SelectSubset<T, dtr_readingsFindFirstArgs<ExtArgs>>): Prisma__dtr_readingsClient<$Result.GetResult<Prisma.$dtr_readingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dtr_readings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_readingsFindFirstOrThrowArgs} args - Arguments to find a Dtr_readings
     * @example
     * // Get one Dtr_readings
     * const dtr_readings = await prisma.dtr_readings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dtr_readingsFindFirstOrThrowArgs>(args?: SelectSubset<T, dtr_readingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__dtr_readingsClient<$Result.GetResult<Prisma.$dtr_readingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dtr_readings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_readingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dtr_readings
     * const dtr_readings = await prisma.dtr_readings.findMany()
     * 
     * // Get first 10 Dtr_readings
     * const dtr_readings = await prisma.dtr_readings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dtr_readingsWithIdOnly = await prisma.dtr_readings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dtr_readingsFindManyArgs>(args?: SelectSubset<T, dtr_readingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtr_readingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dtr_readings.
     * @param {dtr_readingsCreateArgs} args - Arguments to create a Dtr_readings.
     * @example
     * // Create one Dtr_readings
     * const Dtr_readings = await prisma.dtr_readings.create({
     *   data: {
     *     // ... data to create a Dtr_readings
     *   }
     * })
     * 
     */
    create<T extends dtr_readingsCreateArgs>(args: SelectSubset<T, dtr_readingsCreateArgs<ExtArgs>>): Prisma__dtr_readingsClient<$Result.GetResult<Prisma.$dtr_readingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dtr_readings.
     * @param {dtr_readingsCreateManyArgs} args - Arguments to create many Dtr_readings.
     * @example
     * // Create many Dtr_readings
     * const dtr_readings = await prisma.dtr_readings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dtr_readingsCreateManyArgs>(args?: SelectSubset<T, dtr_readingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dtr_readings and returns the data saved in the database.
     * @param {dtr_readingsCreateManyAndReturnArgs} args - Arguments to create many Dtr_readings.
     * @example
     * // Create many Dtr_readings
     * const dtr_readings = await prisma.dtr_readings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dtr_readings and only return the `id`
     * const dtr_readingsWithIdOnly = await prisma.dtr_readings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends dtr_readingsCreateManyAndReturnArgs>(args?: SelectSubset<T, dtr_readingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtr_readingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dtr_readings.
     * @param {dtr_readingsDeleteArgs} args - Arguments to delete one Dtr_readings.
     * @example
     * // Delete one Dtr_readings
     * const Dtr_readings = await prisma.dtr_readings.delete({
     *   where: {
     *     // ... filter to delete one Dtr_readings
     *   }
     * })
     * 
     */
    delete<T extends dtr_readingsDeleteArgs>(args: SelectSubset<T, dtr_readingsDeleteArgs<ExtArgs>>): Prisma__dtr_readingsClient<$Result.GetResult<Prisma.$dtr_readingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dtr_readings.
     * @param {dtr_readingsUpdateArgs} args - Arguments to update one Dtr_readings.
     * @example
     * // Update one Dtr_readings
     * const dtr_readings = await prisma.dtr_readings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dtr_readingsUpdateArgs>(args: SelectSubset<T, dtr_readingsUpdateArgs<ExtArgs>>): Prisma__dtr_readingsClient<$Result.GetResult<Prisma.$dtr_readingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dtr_readings.
     * @param {dtr_readingsDeleteManyArgs} args - Arguments to filter Dtr_readings to delete.
     * @example
     * // Delete a few Dtr_readings
     * const { count } = await prisma.dtr_readings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dtr_readingsDeleteManyArgs>(args?: SelectSubset<T, dtr_readingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dtr_readings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_readingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dtr_readings
     * const dtr_readings = await prisma.dtr_readings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dtr_readingsUpdateManyArgs>(args: SelectSubset<T, dtr_readingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dtr_readings.
     * @param {dtr_readingsUpsertArgs} args - Arguments to update or create a Dtr_readings.
     * @example
     * // Update or create a Dtr_readings
     * const dtr_readings = await prisma.dtr_readings.upsert({
     *   create: {
     *     // ... data to create a Dtr_readings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dtr_readings we want to update
     *   }
     * })
     */
    upsert<T extends dtr_readingsUpsertArgs>(args: SelectSubset<T, dtr_readingsUpsertArgs<ExtArgs>>): Prisma__dtr_readingsClient<$Result.GetResult<Prisma.$dtr_readingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dtr_readings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_readingsCountArgs} args - Arguments to filter Dtr_readings to count.
     * @example
     * // Count the number of Dtr_readings
     * const count = await prisma.dtr_readings.count({
     *   where: {
     *     // ... the filter for the Dtr_readings we want to count
     *   }
     * })
    **/
    count<T extends dtr_readingsCountArgs>(
      args?: Subset<T, dtr_readingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Dtr_readingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dtr_readings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dtr_readingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Dtr_readingsAggregateArgs>(args: Subset<T, Dtr_readingsAggregateArgs>): Prisma.PrismaPromise<GetDtr_readingsAggregateType<T>>

    /**
     * Group by Dtr_readings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtr_readingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dtr_readingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dtr_readingsGroupByArgs['orderBy'] }
        : { orderBy?: dtr_readingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dtr_readingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDtr_readingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dtr_readings model
   */
  readonly fields: dtr_readingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dtr_readings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dtr_readingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dtrs<T extends dtrsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, dtrsDefaultArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dtr_readings model
   */ 
  interface dtr_readingsFieldRefs {
    readonly id: FieldRef<"dtr_readings", 'Int'>
    readonly dtrId: FieldRef<"dtr_readings", 'Int'>
    readonly readingDate: FieldRef<"dtr_readings", 'DateTime'>
    readonly readingType: FieldRef<"dtr_readings", 'DTRReadingType'>
    readonly loadKVA: FieldRef<"dtr_readings", 'Float'>
    readonly loadPercentage: FieldRef<"dtr_readings", 'Float'>
    readonly primaryVoltage: FieldRef<"dtr_readings", 'Json'>
    readonly secondaryVoltage: FieldRef<"dtr_readings", 'Json'>
    readonly primaryCurrent: FieldRef<"dtr_readings", 'Json'>
    readonly secondaryCurrent: FieldRef<"dtr_readings", 'Json'>
    readonly powerFactor: FieldRef<"dtr_readings", 'Float'>
    readonly oilTemperature: FieldRef<"dtr_readings", 'Float'>
    readonly windingTemperature: FieldRef<"dtr_readings", 'Float'>
    readonly ambientTemperature: FieldRef<"dtr_readings", 'Float'>
    readonly frequency: FieldRef<"dtr_readings", 'Float'>
    readonly voltageUnbalance: FieldRef<"dtr_readings", 'Float'>
    readonly currentUnbalance: FieldRef<"dtr_readings", 'Float'>
    readonly createdAt: FieldRef<"dtr_readings", 'DateTime'>
    readonly updatedAt: FieldRef<"dtr_readings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * dtr_readings findUnique
   */
  export type dtr_readingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsInclude<ExtArgs> | null
    /**
     * Filter, which dtr_readings to fetch.
     */
    where: dtr_readingsWhereUniqueInput
  }

  /**
   * dtr_readings findUniqueOrThrow
   */
  export type dtr_readingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsInclude<ExtArgs> | null
    /**
     * Filter, which dtr_readings to fetch.
     */
    where: dtr_readingsWhereUniqueInput
  }

  /**
   * dtr_readings findFirst
   */
  export type dtr_readingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsInclude<ExtArgs> | null
    /**
     * Filter, which dtr_readings to fetch.
     */
    where?: dtr_readingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_readings to fetch.
     */
    orderBy?: dtr_readingsOrderByWithRelationInput | dtr_readingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dtr_readings.
     */
    cursor?: dtr_readingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_readings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dtr_readings.
     */
    distinct?: Dtr_readingsScalarFieldEnum | Dtr_readingsScalarFieldEnum[]
  }

  /**
   * dtr_readings findFirstOrThrow
   */
  export type dtr_readingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsInclude<ExtArgs> | null
    /**
     * Filter, which dtr_readings to fetch.
     */
    where?: dtr_readingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_readings to fetch.
     */
    orderBy?: dtr_readingsOrderByWithRelationInput | dtr_readingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dtr_readings.
     */
    cursor?: dtr_readingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_readings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dtr_readings.
     */
    distinct?: Dtr_readingsScalarFieldEnum | Dtr_readingsScalarFieldEnum[]
  }

  /**
   * dtr_readings findMany
   */
  export type dtr_readingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsInclude<ExtArgs> | null
    /**
     * Filter, which dtr_readings to fetch.
     */
    where?: dtr_readingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtr_readings to fetch.
     */
    orderBy?: dtr_readingsOrderByWithRelationInput | dtr_readingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dtr_readings.
     */
    cursor?: dtr_readingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtr_readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtr_readings.
     */
    skip?: number
    distinct?: Dtr_readingsScalarFieldEnum | Dtr_readingsScalarFieldEnum[]
  }

  /**
   * dtr_readings create
   */
  export type dtr_readingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsInclude<ExtArgs> | null
    /**
     * The data needed to create a dtr_readings.
     */
    data: XOR<dtr_readingsCreateInput, dtr_readingsUncheckedCreateInput>
  }

  /**
   * dtr_readings createMany
   */
  export type dtr_readingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dtr_readings.
     */
    data: dtr_readingsCreateManyInput | dtr_readingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dtr_readings createManyAndReturn
   */
  export type dtr_readingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many dtr_readings.
     */
    data: dtr_readingsCreateManyInput | dtr_readingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * dtr_readings update
   */
  export type dtr_readingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsInclude<ExtArgs> | null
    /**
     * The data needed to update a dtr_readings.
     */
    data: XOR<dtr_readingsUpdateInput, dtr_readingsUncheckedUpdateInput>
    /**
     * Choose, which dtr_readings to update.
     */
    where: dtr_readingsWhereUniqueInput
  }

  /**
   * dtr_readings updateMany
   */
  export type dtr_readingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dtr_readings.
     */
    data: XOR<dtr_readingsUpdateManyMutationInput, dtr_readingsUncheckedUpdateManyInput>
    /**
     * Filter which dtr_readings to update
     */
    where?: dtr_readingsWhereInput
  }

  /**
   * dtr_readings upsert
   */
  export type dtr_readingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsInclude<ExtArgs> | null
    /**
     * The filter to search for the dtr_readings to update in case it exists.
     */
    where: dtr_readingsWhereUniqueInput
    /**
     * In case the dtr_readings found by the `where` argument doesn't exist, create a new dtr_readings with this data.
     */
    create: XOR<dtr_readingsCreateInput, dtr_readingsUncheckedCreateInput>
    /**
     * In case the dtr_readings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dtr_readingsUpdateInput, dtr_readingsUncheckedUpdateInput>
  }

  /**
   * dtr_readings delete
   */
  export type dtr_readingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsInclude<ExtArgs> | null
    /**
     * Filter which dtr_readings to delete.
     */
    where: dtr_readingsWhereUniqueInput
  }

  /**
   * dtr_readings deleteMany
   */
  export type dtr_readingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dtr_readings to delete
     */
    where?: dtr_readingsWhereInput
  }

  /**
   * dtr_readings without action
   */
  export type dtr_readingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsInclude<ExtArgs> | null
  }


  /**
   * Model dtrs
   */

  export type AggregateDtrs = {
    _count: DtrsCountAggregateOutputType | null
    _avg: DtrsAvgAggregateOutputType | null
    _sum: DtrsSumAggregateOutputType | null
    _min: DtrsMinAggregateOutputType | null
    _max: DtrsMaxAggregateOutputType | null
  }

  export type DtrsAvgAggregateOutputType = {
    id: number | null
    capacity: number | null
    phase: number | null
    primaryVoltage: number | null
    secondaryVoltage: number | null
    frequency: number | null
    impedance: number | null
    oilCapacity: number | null
    locationId: number | null
    maxLoadLimit: number | null
    alarmThreshold: number | null
    tripThreshold: number | null
    healthIndex: number | null
    temperature: number | null
    loadPercentage: number | null
  }

  export type DtrsSumAggregateOutputType = {
    id: number | null
    capacity: number | null
    phase: number | null
    primaryVoltage: number | null
    secondaryVoltage: number | null
    frequency: number | null
    impedance: number | null
    oilCapacity: number | null
    locationId: number | null
    maxLoadLimit: number | null
    alarmThreshold: number | null
    tripThreshold: number | null
    healthIndex: number | null
    temperature: number | null
    loadPercentage: number | null
  }

  export type DtrsMinAggregateOutputType = {
    id: number | null
    dtrNumber: string | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    capacity: number | null
    type: $Enums.DTRType | null
    phase: number | null
    primaryVoltage: number | null
    secondaryVoltage: number | null
    frequency: number | null
    impedance: number | null
    coolingType: $Enums.CoolingType | null
    oilType: $Enums.OilType | null
    oilCapacity: number | null
    locationId: number | null
    installationDate: Date | null
    commissionDate: Date | null
    lastMaintenanceDate: Date | null
    maxLoadLimit: number | null
    alarmThreshold: number | null
    tripThreshold: number | null
    status: $Enums.DTRStatus | null
    healthIndex: number | null
    temperature: number | null
    loadPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DtrsMaxAggregateOutputType = {
    id: number | null
    dtrNumber: string | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    capacity: number | null
    type: $Enums.DTRType | null
    phase: number | null
    primaryVoltage: number | null
    secondaryVoltage: number | null
    frequency: number | null
    impedance: number | null
    coolingType: $Enums.CoolingType | null
    oilType: $Enums.OilType | null
    oilCapacity: number | null
    locationId: number | null
    installationDate: Date | null
    commissionDate: Date | null
    lastMaintenanceDate: Date | null
    maxLoadLimit: number | null
    alarmThreshold: number | null
    tripThreshold: number | null
    status: $Enums.DTRStatus | null
    healthIndex: number | null
    temperature: number | null
    loadPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DtrsCountAggregateOutputType = {
    id: number
    dtrNumber: number
    serialNumber: number
    manufacturer: number
    model: number
    capacity: number
    type: number
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency: number
    impedance: number
    coolingType: number
    oilType: number
    oilCapacity: number
    locationId: number
    installationDate: number
    commissionDate: number
    lastMaintenanceDate: number
    maxLoadLimit: number
    alarmThreshold: number
    tripThreshold: number
    status: number
    healthIndex: number
    temperature: number
    loadPercentage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DtrsAvgAggregateInputType = {
    id?: true
    capacity?: true
    phase?: true
    primaryVoltage?: true
    secondaryVoltage?: true
    frequency?: true
    impedance?: true
    oilCapacity?: true
    locationId?: true
    maxLoadLimit?: true
    alarmThreshold?: true
    tripThreshold?: true
    healthIndex?: true
    temperature?: true
    loadPercentage?: true
  }

  export type DtrsSumAggregateInputType = {
    id?: true
    capacity?: true
    phase?: true
    primaryVoltage?: true
    secondaryVoltage?: true
    frequency?: true
    impedance?: true
    oilCapacity?: true
    locationId?: true
    maxLoadLimit?: true
    alarmThreshold?: true
    tripThreshold?: true
    healthIndex?: true
    temperature?: true
    loadPercentage?: true
  }

  export type DtrsMinAggregateInputType = {
    id?: true
    dtrNumber?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    capacity?: true
    type?: true
    phase?: true
    primaryVoltage?: true
    secondaryVoltage?: true
    frequency?: true
    impedance?: true
    coolingType?: true
    oilType?: true
    oilCapacity?: true
    locationId?: true
    installationDate?: true
    commissionDate?: true
    lastMaintenanceDate?: true
    maxLoadLimit?: true
    alarmThreshold?: true
    tripThreshold?: true
    status?: true
    healthIndex?: true
    temperature?: true
    loadPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DtrsMaxAggregateInputType = {
    id?: true
    dtrNumber?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    capacity?: true
    type?: true
    phase?: true
    primaryVoltage?: true
    secondaryVoltage?: true
    frequency?: true
    impedance?: true
    coolingType?: true
    oilType?: true
    oilCapacity?: true
    locationId?: true
    installationDate?: true
    commissionDate?: true
    lastMaintenanceDate?: true
    maxLoadLimit?: true
    alarmThreshold?: true
    tripThreshold?: true
    status?: true
    healthIndex?: true
    temperature?: true
    loadPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DtrsCountAggregateInputType = {
    id?: true
    dtrNumber?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    capacity?: true
    type?: true
    phase?: true
    primaryVoltage?: true
    secondaryVoltage?: true
    frequency?: true
    impedance?: true
    coolingType?: true
    oilType?: true
    oilCapacity?: true
    locationId?: true
    installationDate?: true
    commissionDate?: true
    lastMaintenanceDate?: true
    maxLoadLimit?: true
    alarmThreshold?: true
    tripThreshold?: true
    status?: true
    healthIndex?: true
    temperature?: true
    loadPercentage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DtrsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dtrs to aggregate.
     */
    where?: dtrsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtrs to fetch.
     */
    orderBy?: dtrsOrderByWithRelationInput | dtrsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dtrsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dtrs
    **/
    _count?: true | DtrsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DtrsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DtrsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DtrsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DtrsMaxAggregateInputType
  }

  export type GetDtrsAggregateType<T extends DtrsAggregateArgs> = {
        [P in keyof T & keyof AggregateDtrs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDtrs[P]>
      : GetScalarType<T[P], AggregateDtrs[P]>
  }




  export type dtrsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dtrsWhereInput
    orderBy?: dtrsOrderByWithAggregationInput | dtrsOrderByWithAggregationInput[]
    by: DtrsScalarFieldEnum[] | DtrsScalarFieldEnum
    having?: dtrsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DtrsCountAggregateInputType | true
    _avg?: DtrsAvgAggregateInputType
    _sum?: DtrsSumAggregateInputType
    _min?: DtrsMinAggregateInputType
    _max?: DtrsMaxAggregateInputType
  }

  export type DtrsGroupByOutputType = {
    id: number
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency: number
    impedance: number | null
    coolingType: $Enums.CoolingType
    oilType: $Enums.OilType | null
    oilCapacity: number | null
    locationId: number
    installationDate: Date
    commissionDate: Date | null
    lastMaintenanceDate: Date | null
    maxLoadLimit: number | null
    alarmThreshold: number | null
    tripThreshold: number | null
    status: $Enums.DTRStatus
    healthIndex: number | null
    temperature: number | null
    loadPercentage: number | null
    createdAt: Date
    updatedAt: Date
    _count: DtrsCountAggregateOutputType | null
    _avg: DtrsAvgAggregateOutputType | null
    _sum: DtrsSumAggregateOutputType | null
    _min: DtrsMinAggregateOutputType | null
    _max: DtrsMaxAggregateOutputType | null
  }

  type GetDtrsGroupByPayload<T extends dtrsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DtrsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DtrsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DtrsGroupByOutputType[P]>
            : GetScalarType<T[P], DtrsGroupByOutputType[P]>
        }
      >
    >


  export type dtrsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dtrNumber?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    capacity?: boolean
    type?: boolean
    phase?: boolean
    primaryVoltage?: boolean
    secondaryVoltage?: boolean
    frequency?: boolean
    impedance?: boolean
    coolingType?: boolean
    oilType?: boolean
    oilCapacity?: boolean
    locationId?: boolean
    installationDate?: boolean
    commissionDate?: boolean
    lastMaintenanceDate?: boolean
    maxLoadLimit?: boolean
    alarmThreshold?: boolean
    tripThreshold?: boolean
    status?: boolean
    healthIndex?: boolean
    temperature?: boolean
    loadPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dtr_faults?: boolean | dtrs$dtr_faultsArgs<ExtArgs>
    dtr_maintenance?: boolean | dtrs$dtr_maintenanceArgs<ExtArgs>
    dtr_readings?: boolean | dtrs$dtr_readingsArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    meters?: boolean | dtrs$metersArgs<ExtArgs>
    tickets?: boolean | dtrs$ticketsArgs<ExtArgs>
    _count?: boolean | DtrsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dtrs"]>

  export type dtrsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dtrNumber?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    capacity?: boolean
    type?: boolean
    phase?: boolean
    primaryVoltage?: boolean
    secondaryVoltage?: boolean
    frequency?: boolean
    impedance?: boolean
    coolingType?: boolean
    oilType?: boolean
    oilCapacity?: boolean
    locationId?: boolean
    installationDate?: boolean
    commissionDate?: boolean
    lastMaintenanceDate?: boolean
    maxLoadLimit?: boolean
    alarmThreshold?: boolean
    tripThreshold?: boolean
    status?: boolean
    healthIndex?: boolean
    temperature?: boolean
    loadPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locations?: boolean | locationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dtrs"]>

  export type dtrsSelectScalar = {
    id?: boolean
    dtrNumber?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    capacity?: boolean
    type?: boolean
    phase?: boolean
    primaryVoltage?: boolean
    secondaryVoltage?: boolean
    frequency?: boolean
    impedance?: boolean
    coolingType?: boolean
    oilType?: boolean
    oilCapacity?: boolean
    locationId?: boolean
    installationDate?: boolean
    commissionDate?: boolean
    lastMaintenanceDate?: boolean
    maxLoadLimit?: boolean
    alarmThreshold?: boolean
    tripThreshold?: boolean
    status?: boolean
    healthIndex?: boolean
    temperature?: boolean
    loadPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type dtrsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dtr_faults?: boolean | dtrs$dtr_faultsArgs<ExtArgs>
    dtr_maintenance?: boolean | dtrs$dtr_maintenanceArgs<ExtArgs>
    dtr_readings?: boolean | dtrs$dtr_readingsArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    meters?: boolean | dtrs$metersArgs<ExtArgs>
    tickets?: boolean | dtrs$ticketsArgs<ExtArgs>
    _count?: boolean | DtrsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type dtrsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | locationsDefaultArgs<ExtArgs>
  }

  export type $dtrsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dtrs"
    objects: {
      dtr_faults: Prisma.$dtr_faultsPayload<ExtArgs>[]
      dtr_maintenance: Prisma.$dtr_maintenancePayload<ExtArgs>[]
      dtr_readings: Prisma.$dtr_readingsPayload<ExtArgs>[]
      locations: Prisma.$locationsPayload<ExtArgs>
      meters: Prisma.$metersPayload<ExtArgs>[]
      tickets: Prisma.$ticketsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dtrNumber: string
      serialNumber: string
      manufacturer: string
      model: string
      capacity: number
      type: $Enums.DTRType
      phase: number
      primaryVoltage: number
      secondaryVoltage: number
      frequency: number
      impedance: number | null
      coolingType: $Enums.CoolingType
      oilType: $Enums.OilType | null
      oilCapacity: number | null
      locationId: number
      installationDate: Date
      commissionDate: Date | null
      lastMaintenanceDate: Date | null
      maxLoadLimit: number | null
      alarmThreshold: number | null
      tripThreshold: number | null
      status: $Enums.DTRStatus
      healthIndex: number | null
      temperature: number | null
      loadPercentage: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dtrs"]>
    composites: {}
  }

  type dtrsGetPayload<S extends boolean | null | undefined | dtrsDefaultArgs> = $Result.GetResult<Prisma.$dtrsPayload, S>

  type dtrsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<dtrsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DtrsCountAggregateInputType | true
    }

  export interface dtrsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dtrs'], meta: { name: 'dtrs' } }
    /**
     * Find zero or one Dtrs that matches the filter.
     * @param {dtrsFindUniqueArgs} args - Arguments to find a Dtrs
     * @example
     * // Get one Dtrs
     * const dtrs = await prisma.dtrs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dtrsFindUniqueArgs>(args: SelectSubset<T, dtrsFindUniqueArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dtrs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {dtrsFindUniqueOrThrowArgs} args - Arguments to find a Dtrs
     * @example
     * // Get one Dtrs
     * const dtrs = await prisma.dtrs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dtrsFindUniqueOrThrowArgs>(args: SelectSubset<T, dtrsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dtrs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtrsFindFirstArgs} args - Arguments to find a Dtrs
     * @example
     * // Get one Dtrs
     * const dtrs = await prisma.dtrs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dtrsFindFirstArgs>(args?: SelectSubset<T, dtrsFindFirstArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dtrs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtrsFindFirstOrThrowArgs} args - Arguments to find a Dtrs
     * @example
     * // Get one Dtrs
     * const dtrs = await prisma.dtrs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dtrsFindFirstOrThrowArgs>(args?: SelectSubset<T, dtrsFindFirstOrThrowArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dtrs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtrsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dtrs
     * const dtrs = await prisma.dtrs.findMany()
     * 
     * // Get first 10 Dtrs
     * const dtrs = await prisma.dtrs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dtrsWithIdOnly = await prisma.dtrs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dtrsFindManyArgs>(args?: SelectSubset<T, dtrsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dtrs.
     * @param {dtrsCreateArgs} args - Arguments to create a Dtrs.
     * @example
     * // Create one Dtrs
     * const Dtrs = await prisma.dtrs.create({
     *   data: {
     *     // ... data to create a Dtrs
     *   }
     * })
     * 
     */
    create<T extends dtrsCreateArgs>(args: SelectSubset<T, dtrsCreateArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dtrs.
     * @param {dtrsCreateManyArgs} args - Arguments to create many Dtrs.
     * @example
     * // Create many Dtrs
     * const dtrs = await prisma.dtrs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dtrsCreateManyArgs>(args?: SelectSubset<T, dtrsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dtrs and returns the data saved in the database.
     * @param {dtrsCreateManyAndReturnArgs} args - Arguments to create many Dtrs.
     * @example
     * // Create many Dtrs
     * const dtrs = await prisma.dtrs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dtrs and only return the `id`
     * const dtrsWithIdOnly = await prisma.dtrs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends dtrsCreateManyAndReturnArgs>(args?: SelectSubset<T, dtrsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dtrs.
     * @param {dtrsDeleteArgs} args - Arguments to delete one Dtrs.
     * @example
     * // Delete one Dtrs
     * const Dtrs = await prisma.dtrs.delete({
     *   where: {
     *     // ... filter to delete one Dtrs
     *   }
     * })
     * 
     */
    delete<T extends dtrsDeleteArgs>(args: SelectSubset<T, dtrsDeleteArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dtrs.
     * @param {dtrsUpdateArgs} args - Arguments to update one Dtrs.
     * @example
     * // Update one Dtrs
     * const dtrs = await prisma.dtrs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dtrsUpdateArgs>(args: SelectSubset<T, dtrsUpdateArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dtrs.
     * @param {dtrsDeleteManyArgs} args - Arguments to filter Dtrs to delete.
     * @example
     * // Delete a few Dtrs
     * const { count } = await prisma.dtrs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dtrsDeleteManyArgs>(args?: SelectSubset<T, dtrsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dtrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtrsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dtrs
     * const dtrs = await prisma.dtrs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dtrsUpdateManyArgs>(args: SelectSubset<T, dtrsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dtrs.
     * @param {dtrsUpsertArgs} args - Arguments to update or create a Dtrs.
     * @example
     * // Update or create a Dtrs
     * const dtrs = await prisma.dtrs.upsert({
     *   create: {
     *     // ... data to create a Dtrs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dtrs we want to update
     *   }
     * })
     */
    upsert<T extends dtrsUpsertArgs>(args: SelectSubset<T, dtrsUpsertArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dtrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtrsCountArgs} args - Arguments to filter Dtrs to count.
     * @example
     * // Count the number of Dtrs
     * const count = await prisma.dtrs.count({
     *   where: {
     *     // ... the filter for the Dtrs we want to count
     *   }
     * })
    **/
    count<T extends dtrsCountArgs>(
      args?: Subset<T, dtrsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DtrsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dtrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtrsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DtrsAggregateArgs>(args: Subset<T, DtrsAggregateArgs>): Prisma.PrismaPromise<GetDtrsAggregateType<T>>

    /**
     * Group by Dtrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dtrsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dtrsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dtrsGroupByArgs['orderBy'] }
        : { orderBy?: dtrsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dtrsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDtrsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dtrs model
   */
  readonly fields: dtrsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dtrs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dtrsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dtr_faults<T extends dtrs$dtr_faultsArgs<ExtArgs> = {}>(args?: Subset<T, dtrs$dtr_faultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtr_faultsPayload<ExtArgs>, T, "findMany"> | Null>
    dtr_maintenance<T extends dtrs$dtr_maintenanceArgs<ExtArgs> = {}>(args?: Subset<T, dtrs$dtr_maintenanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtr_maintenancePayload<ExtArgs>, T, "findMany"> | Null>
    dtr_readings<T extends dtrs$dtr_readingsArgs<ExtArgs> = {}>(args?: Subset<T, dtrs$dtr_readingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtr_readingsPayload<ExtArgs>, T, "findMany"> | Null>
    locations<T extends locationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, locationsDefaultArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    meters<T extends dtrs$metersArgs<ExtArgs> = {}>(args?: Subset<T, dtrs$metersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findMany"> | Null>
    tickets<T extends dtrs$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, dtrs$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dtrs model
   */ 
  interface dtrsFieldRefs {
    readonly id: FieldRef<"dtrs", 'Int'>
    readonly dtrNumber: FieldRef<"dtrs", 'String'>
    readonly serialNumber: FieldRef<"dtrs", 'String'>
    readonly manufacturer: FieldRef<"dtrs", 'String'>
    readonly model: FieldRef<"dtrs", 'String'>
    readonly capacity: FieldRef<"dtrs", 'Float'>
    readonly type: FieldRef<"dtrs", 'DTRType'>
    readonly phase: FieldRef<"dtrs", 'Int'>
    readonly primaryVoltage: FieldRef<"dtrs", 'Float'>
    readonly secondaryVoltage: FieldRef<"dtrs", 'Float'>
    readonly frequency: FieldRef<"dtrs", 'Float'>
    readonly impedance: FieldRef<"dtrs", 'Float'>
    readonly coolingType: FieldRef<"dtrs", 'CoolingType'>
    readonly oilType: FieldRef<"dtrs", 'OilType'>
    readonly oilCapacity: FieldRef<"dtrs", 'Float'>
    readonly locationId: FieldRef<"dtrs", 'Int'>
    readonly installationDate: FieldRef<"dtrs", 'DateTime'>
    readonly commissionDate: FieldRef<"dtrs", 'DateTime'>
    readonly lastMaintenanceDate: FieldRef<"dtrs", 'DateTime'>
    readonly maxLoadLimit: FieldRef<"dtrs", 'Float'>
    readonly alarmThreshold: FieldRef<"dtrs", 'Float'>
    readonly tripThreshold: FieldRef<"dtrs", 'Float'>
    readonly status: FieldRef<"dtrs", 'DTRStatus'>
    readonly healthIndex: FieldRef<"dtrs", 'Int'>
    readonly temperature: FieldRef<"dtrs", 'Float'>
    readonly loadPercentage: FieldRef<"dtrs", 'Float'>
    readonly createdAt: FieldRef<"dtrs", 'DateTime'>
    readonly updatedAt: FieldRef<"dtrs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * dtrs findUnique
   */
  export type dtrsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    /**
     * Filter, which dtrs to fetch.
     */
    where: dtrsWhereUniqueInput
  }

  /**
   * dtrs findUniqueOrThrow
   */
  export type dtrsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    /**
     * Filter, which dtrs to fetch.
     */
    where: dtrsWhereUniqueInput
  }

  /**
   * dtrs findFirst
   */
  export type dtrsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    /**
     * Filter, which dtrs to fetch.
     */
    where?: dtrsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtrs to fetch.
     */
    orderBy?: dtrsOrderByWithRelationInput | dtrsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dtrs.
     */
    cursor?: dtrsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dtrs.
     */
    distinct?: DtrsScalarFieldEnum | DtrsScalarFieldEnum[]
  }

  /**
   * dtrs findFirstOrThrow
   */
  export type dtrsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    /**
     * Filter, which dtrs to fetch.
     */
    where?: dtrsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtrs to fetch.
     */
    orderBy?: dtrsOrderByWithRelationInput | dtrsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dtrs.
     */
    cursor?: dtrsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dtrs.
     */
    distinct?: DtrsScalarFieldEnum | DtrsScalarFieldEnum[]
  }

  /**
   * dtrs findMany
   */
  export type dtrsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    /**
     * Filter, which dtrs to fetch.
     */
    where?: dtrsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dtrs to fetch.
     */
    orderBy?: dtrsOrderByWithRelationInput | dtrsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dtrs.
     */
    cursor?: dtrsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dtrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dtrs.
     */
    skip?: number
    distinct?: DtrsScalarFieldEnum | DtrsScalarFieldEnum[]
  }

  /**
   * dtrs create
   */
  export type dtrsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    /**
     * The data needed to create a dtrs.
     */
    data: XOR<dtrsCreateInput, dtrsUncheckedCreateInput>
  }

  /**
   * dtrs createMany
   */
  export type dtrsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dtrs.
     */
    data: dtrsCreateManyInput | dtrsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dtrs createManyAndReturn
   */
  export type dtrsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many dtrs.
     */
    data: dtrsCreateManyInput | dtrsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * dtrs update
   */
  export type dtrsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    /**
     * The data needed to update a dtrs.
     */
    data: XOR<dtrsUpdateInput, dtrsUncheckedUpdateInput>
    /**
     * Choose, which dtrs to update.
     */
    where: dtrsWhereUniqueInput
  }

  /**
   * dtrs updateMany
   */
  export type dtrsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dtrs.
     */
    data: XOR<dtrsUpdateManyMutationInput, dtrsUncheckedUpdateManyInput>
    /**
     * Filter which dtrs to update
     */
    where?: dtrsWhereInput
  }

  /**
   * dtrs upsert
   */
  export type dtrsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    /**
     * The filter to search for the dtrs to update in case it exists.
     */
    where: dtrsWhereUniqueInput
    /**
     * In case the dtrs found by the `where` argument doesn't exist, create a new dtrs with this data.
     */
    create: XOR<dtrsCreateInput, dtrsUncheckedCreateInput>
    /**
     * In case the dtrs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dtrsUpdateInput, dtrsUncheckedUpdateInput>
  }

  /**
   * dtrs delete
   */
  export type dtrsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    /**
     * Filter which dtrs to delete.
     */
    where: dtrsWhereUniqueInput
  }

  /**
   * dtrs deleteMany
   */
  export type dtrsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dtrs to delete
     */
    where?: dtrsWhereInput
  }

  /**
   * dtrs.dtr_faults
   */
  export type dtrs$dtr_faultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_faults
     */
    select?: dtr_faultsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_faultsInclude<ExtArgs> | null
    where?: dtr_faultsWhereInput
    orderBy?: dtr_faultsOrderByWithRelationInput | dtr_faultsOrderByWithRelationInput[]
    cursor?: dtr_faultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Dtr_faultsScalarFieldEnum | Dtr_faultsScalarFieldEnum[]
  }

  /**
   * dtrs.dtr_maintenance
   */
  export type dtrs$dtr_maintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_maintenance
     */
    select?: dtr_maintenanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_maintenanceInclude<ExtArgs> | null
    where?: dtr_maintenanceWhereInput
    orderBy?: dtr_maintenanceOrderByWithRelationInput | dtr_maintenanceOrderByWithRelationInput[]
    cursor?: dtr_maintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Dtr_maintenanceScalarFieldEnum | Dtr_maintenanceScalarFieldEnum[]
  }

  /**
   * dtrs.dtr_readings
   */
  export type dtrs$dtr_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtr_readings
     */
    select?: dtr_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtr_readingsInclude<ExtArgs> | null
    where?: dtr_readingsWhereInput
    orderBy?: dtr_readingsOrderByWithRelationInput | dtr_readingsOrderByWithRelationInput[]
    cursor?: dtr_readingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Dtr_readingsScalarFieldEnum | Dtr_readingsScalarFieldEnum[]
  }

  /**
   * dtrs.meters
   */
  export type dtrs$metersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    where?: metersWhereInput
    orderBy?: metersOrderByWithRelationInput | metersOrderByWithRelationInput[]
    cursor?: metersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MetersScalarFieldEnum | MetersScalarFieldEnum[]
  }

  /**
   * dtrs.tickets
   */
  export type dtrs$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    where?: ticketsWhereInput
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    cursor?: ticketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * dtrs without action
   */
  export type dtrsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
  }


  /**
   * Model location_types
   */

  export type AggregateLocation_types = {
    _count: Location_typesCountAggregateOutputType | null
    _avg: Location_typesAvgAggregateOutputType | null
    _sum: Location_typesSumAggregateOutputType | null
    _min: Location_typesMinAggregateOutputType | null
    _max: Location_typesMaxAggregateOutputType | null
  }

  export type Location_typesAvgAggregateOutputType = {
    id: number | null
    level: number | null
  }

  export type Location_typesSumAggregateOutputType = {
    id: number | null
    level: number | null
  }

  export type Location_typesMinAggregateOutputType = {
    id: number | null
    name: string | null
    level: number | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Location_typesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    level: number | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Location_typesCountAggregateOutputType = {
    id: number
    name: number
    level: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Location_typesAvgAggregateInputType = {
    id?: true
    level?: true
  }

  export type Location_typesSumAggregateInputType = {
    id?: true
    level?: true
  }

  export type Location_typesMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Location_typesMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Location_typesCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Location_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which location_types to aggregate.
     */
    where?: location_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_types to fetch.
     */
    orderBy?: location_typesOrderByWithRelationInput | location_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: location_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned location_types
    **/
    _count?: true | Location_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Location_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Location_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Location_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Location_typesMaxAggregateInputType
  }

  export type GetLocation_typesAggregateType<T extends Location_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation_types[P]>
      : GetScalarType<T[P], AggregateLocation_types[P]>
  }




  export type location_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: location_typesWhereInput
    orderBy?: location_typesOrderByWithAggregationInput | location_typesOrderByWithAggregationInput[]
    by: Location_typesScalarFieldEnum[] | Location_typesScalarFieldEnum
    having?: location_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Location_typesCountAggregateInputType | true
    _avg?: Location_typesAvgAggregateInputType
    _sum?: Location_typesSumAggregateInputType
    _min?: Location_typesMinAggregateInputType
    _max?: Location_typesMaxAggregateInputType
  }

  export type Location_typesGroupByOutputType = {
    id: number
    name: string
    level: number
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Location_typesCountAggregateOutputType | null
    _avg: Location_typesAvgAggregateOutputType | null
    _sum: Location_typesSumAggregateOutputType | null
    _min: Location_typesMinAggregateOutputType | null
    _max: Location_typesMaxAggregateOutputType | null
  }

  type GetLocation_typesGroupByPayload<T extends location_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Location_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Location_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Location_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Location_typesGroupByOutputType[P]>
        }
      >
    >


  export type location_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locations?: boolean | location_types$locationsArgs<ExtArgs>
    _count?: boolean | Location_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location_types"]>

  export type location_typesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location_types"]>

  export type location_typesSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type location_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | location_types$locationsArgs<ExtArgs>
    _count?: boolean | Location_typesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type location_typesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $location_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "location_types"
    objects: {
      locations: Prisma.$locationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      level: number
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location_types"]>
    composites: {}
  }

  type location_typesGetPayload<S extends boolean | null | undefined | location_typesDefaultArgs> = $Result.GetResult<Prisma.$location_typesPayload, S>

  type location_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<location_typesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Location_typesCountAggregateInputType | true
    }

  export interface location_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['location_types'], meta: { name: 'location_types' } }
    /**
     * Find zero or one Location_types that matches the filter.
     * @param {location_typesFindUniqueArgs} args - Arguments to find a Location_types
     * @example
     * // Get one Location_types
     * const location_types = await prisma.location_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends location_typesFindUniqueArgs>(args: SelectSubset<T, location_typesFindUniqueArgs<ExtArgs>>): Prisma__location_typesClient<$Result.GetResult<Prisma.$location_typesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Location_types that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {location_typesFindUniqueOrThrowArgs} args - Arguments to find a Location_types
     * @example
     * // Get one Location_types
     * const location_types = await prisma.location_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends location_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, location_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__location_typesClient<$Result.GetResult<Prisma.$location_typesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Location_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_typesFindFirstArgs} args - Arguments to find a Location_types
     * @example
     * // Get one Location_types
     * const location_types = await prisma.location_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends location_typesFindFirstArgs>(args?: SelectSubset<T, location_typesFindFirstArgs<ExtArgs>>): Prisma__location_typesClient<$Result.GetResult<Prisma.$location_typesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Location_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_typesFindFirstOrThrowArgs} args - Arguments to find a Location_types
     * @example
     * // Get one Location_types
     * const location_types = await prisma.location_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends location_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, location_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__location_typesClient<$Result.GetResult<Prisma.$location_typesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Location_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Location_types
     * const location_types = await prisma.location_types.findMany()
     * 
     * // Get first 10 Location_types
     * const location_types = await prisma.location_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const location_typesWithIdOnly = await prisma.location_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends location_typesFindManyArgs>(args?: SelectSubset<T, location_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$location_typesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Location_types.
     * @param {location_typesCreateArgs} args - Arguments to create a Location_types.
     * @example
     * // Create one Location_types
     * const Location_types = await prisma.location_types.create({
     *   data: {
     *     // ... data to create a Location_types
     *   }
     * })
     * 
     */
    create<T extends location_typesCreateArgs>(args: SelectSubset<T, location_typesCreateArgs<ExtArgs>>): Prisma__location_typesClient<$Result.GetResult<Prisma.$location_typesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Location_types.
     * @param {location_typesCreateManyArgs} args - Arguments to create many Location_types.
     * @example
     * // Create many Location_types
     * const location_types = await prisma.location_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends location_typesCreateManyArgs>(args?: SelectSubset<T, location_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Location_types and returns the data saved in the database.
     * @param {location_typesCreateManyAndReturnArgs} args - Arguments to create many Location_types.
     * @example
     * // Create many Location_types
     * const location_types = await prisma.location_types.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Location_types and only return the `id`
     * const location_typesWithIdOnly = await prisma.location_types.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends location_typesCreateManyAndReturnArgs>(args?: SelectSubset<T, location_typesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$location_typesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Location_types.
     * @param {location_typesDeleteArgs} args - Arguments to delete one Location_types.
     * @example
     * // Delete one Location_types
     * const Location_types = await prisma.location_types.delete({
     *   where: {
     *     // ... filter to delete one Location_types
     *   }
     * })
     * 
     */
    delete<T extends location_typesDeleteArgs>(args: SelectSubset<T, location_typesDeleteArgs<ExtArgs>>): Prisma__location_typesClient<$Result.GetResult<Prisma.$location_typesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Location_types.
     * @param {location_typesUpdateArgs} args - Arguments to update one Location_types.
     * @example
     * // Update one Location_types
     * const location_types = await prisma.location_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends location_typesUpdateArgs>(args: SelectSubset<T, location_typesUpdateArgs<ExtArgs>>): Prisma__location_typesClient<$Result.GetResult<Prisma.$location_typesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Location_types.
     * @param {location_typesDeleteManyArgs} args - Arguments to filter Location_types to delete.
     * @example
     * // Delete a few Location_types
     * const { count } = await prisma.location_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends location_typesDeleteManyArgs>(args?: SelectSubset<T, location_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Location_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Location_types
     * const location_types = await prisma.location_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends location_typesUpdateManyArgs>(args: SelectSubset<T, location_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location_types.
     * @param {location_typesUpsertArgs} args - Arguments to update or create a Location_types.
     * @example
     * // Update or create a Location_types
     * const location_types = await prisma.location_types.upsert({
     *   create: {
     *     // ... data to create a Location_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location_types we want to update
     *   }
     * })
     */
    upsert<T extends location_typesUpsertArgs>(args: SelectSubset<T, location_typesUpsertArgs<ExtArgs>>): Prisma__location_typesClient<$Result.GetResult<Prisma.$location_typesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Location_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_typesCountArgs} args - Arguments to filter Location_types to count.
     * @example
     * // Count the number of Location_types
     * const count = await prisma.location_types.count({
     *   where: {
     *     // ... the filter for the Location_types we want to count
     *   }
     * })
    **/
    count<T extends location_typesCountArgs>(
      args?: Subset<T, location_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Location_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Location_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Location_typesAggregateArgs>(args: Subset<T, Location_typesAggregateArgs>): Prisma.PrismaPromise<GetLocation_typesAggregateType<T>>

    /**
     * Group by Location_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends location_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: location_typesGroupByArgs['orderBy'] }
        : { orderBy?: location_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, location_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocation_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the location_types model
   */
  readonly fields: location_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for location_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__location_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locations<T extends location_types$locationsArgs<ExtArgs> = {}>(args?: Subset<T, location_types$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the location_types model
   */ 
  interface location_typesFieldRefs {
    readonly id: FieldRef<"location_types", 'Int'>
    readonly name: FieldRef<"location_types", 'String'>
    readonly level: FieldRef<"location_types", 'Int'>
    readonly description: FieldRef<"location_types", 'String'>
    readonly isActive: FieldRef<"location_types", 'Boolean'>
    readonly createdAt: FieldRef<"location_types", 'DateTime'>
    readonly updatedAt: FieldRef<"location_types", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * location_types findUnique
   */
  export type location_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_types
     */
    select?: location_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_typesInclude<ExtArgs> | null
    /**
     * Filter, which location_types to fetch.
     */
    where: location_typesWhereUniqueInput
  }

  /**
   * location_types findUniqueOrThrow
   */
  export type location_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_types
     */
    select?: location_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_typesInclude<ExtArgs> | null
    /**
     * Filter, which location_types to fetch.
     */
    where: location_typesWhereUniqueInput
  }

  /**
   * location_types findFirst
   */
  export type location_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_types
     */
    select?: location_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_typesInclude<ExtArgs> | null
    /**
     * Filter, which location_types to fetch.
     */
    where?: location_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_types to fetch.
     */
    orderBy?: location_typesOrderByWithRelationInput | location_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for location_types.
     */
    cursor?: location_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of location_types.
     */
    distinct?: Location_typesScalarFieldEnum | Location_typesScalarFieldEnum[]
  }

  /**
   * location_types findFirstOrThrow
   */
  export type location_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_types
     */
    select?: location_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_typesInclude<ExtArgs> | null
    /**
     * Filter, which location_types to fetch.
     */
    where?: location_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_types to fetch.
     */
    orderBy?: location_typesOrderByWithRelationInput | location_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for location_types.
     */
    cursor?: location_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of location_types.
     */
    distinct?: Location_typesScalarFieldEnum | Location_typesScalarFieldEnum[]
  }

  /**
   * location_types findMany
   */
  export type location_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_types
     */
    select?: location_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_typesInclude<ExtArgs> | null
    /**
     * Filter, which location_types to fetch.
     */
    where?: location_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_types to fetch.
     */
    orderBy?: location_typesOrderByWithRelationInput | location_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing location_types.
     */
    cursor?: location_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_types.
     */
    skip?: number
    distinct?: Location_typesScalarFieldEnum | Location_typesScalarFieldEnum[]
  }

  /**
   * location_types create
   */
  export type location_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_types
     */
    select?: location_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a location_types.
     */
    data: XOR<location_typesCreateInput, location_typesUncheckedCreateInput>
  }

  /**
   * location_types createMany
   */
  export type location_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many location_types.
     */
    data: location_typesCreateManyInput | location_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * location_types createManyAndReturn
   */
  export type location_typesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_types
     */
    select?: location_typesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many location_types.
     */
    data: location_typesCreateManyInput | location_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * location_types update
   */
  export type location_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_types
     */
    select?: location_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a location_types.
     */
    data: XOR<location_typesUpdateInput, location_typesUncheckedUpdateInput>
    /**
     * Choose, which location_types to update.
     */
    where: location_typesWhereUniqueInput
  }

  /**
   * location_types updateMany
   */
  export type location_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update location_types.
     */
    data: XOR<location_typesUpdateManyMutationInput, location_typesUncheckedUpdateManyInput>
    /**
     * Filter which location_types to update
     */
    where?: location_typesWhereInput
  }

  /**
   * location_types upsert
   */
  export type location_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_types
     */
    select?: location_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the location_types to update in case it exists.
     */
    where: location_typesWhereUniqueInput
    /**
     * In case the location_types found by the `where` argument doesn't exist, create a new location_types with this data.
     */
    create: XOR<location_typesCreateInput, location_typesUncheckedCreateInput>
    /**
     * In case the location_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<location_typesUpdateInput, location_typesUncheckedUpdateInput>
  }

  /**
   * location_types delete
   */
  export type location_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_types
     */
    select?: location_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_typesInclude<ExtArgs> | null
    /**
     * Filter which location_types to delete.
     */
    where: location_typesWhereUniqueInput
  }

  /**
   * location_types deleteMany
   */
  export type location_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which location_types to delete
     */
    where?: location_typesWhereInput
  }

  /**
   * location_types.locations
   */
  export type location_types$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    where?: locationsWhereInput
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    cursor?: locationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * location_types without action
   */
  export type location_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location_types
     */
    select?: location_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: location_typesInclude<ExtArgs> | null
  }


  /**
   * Model locations
   */

  export type AggregateLocations = {
    _count: LocationsCountAggregateOutputType | null
    _avg: LocationsAvgAggregateOutputType | null
    _sum: LocationsSumAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  export type LocationsAvgAggregateOutputType = {
    id: number | null
    locationTypeId: number | null
    parentId: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LocationsSumAggregateOutputType = {
    id: number | null
    locationTypeId: number | null
    parentId: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LocationsMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    locationTypeId: number | null
    parentId: number | null
    latitude: number | null
    longitude: number | null
    address: string | null
    pincode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    locationTypeId: number | null
    parentId: number | null
    latitude: number | null
    longitude: number | null
    address: string | null
    pincode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationsCountAggregateOutputType = {
    id: number
    name: number
    code: number
    locationTypeId: number
    parentId: number
    latitude: number
    longitude: number
    address: number
    pincode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationsAvgAggregateInputType = {
    id?: true
    locationTypeId?: true
    parentId?: true
    latitude?: true
    longitude?: true
  }

  export type LocationsSumAggregateInputType = {
    id?: true
    locationTypeId?: true
    parentId?: true
    latitude?: true
    longitude?: true
  }

  export type LocationsMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    locationTypeId?: true
    parentId?: true
    latitude?: true
    longitude?: true
    address?: true
    pincode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationsMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    locationTypeId?: true
    parentId?: true
    latitude?: true
    longitude?: true
    address?: true
    pincode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationsCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    locationTypeId?: true
    parentId?: true
    latitude?: true
    longitude?: true
    address?: true
    pincode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to aggregate.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationsMaxAggregateInputType
  }

  export type GetLocationsAggregateType<T extends LocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocations[P]>
      : GetScalarType<T[P], AggregateLocations[P]>
  }




  export type locationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationsWhereInput
    orderBy?: locationsOrderByWithAggregationInput | locationsOrderByWithAggregationInput[]
    by: LocationsScalarFieldEnum[] | LocationsScalarFieldEnum
    having?: locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationsCountAggregateInputType | true
    _avg?: LocationsAvgAggregateInputType
    _sum?: LocationsSumAggregateInputType
    _min?: LocationsMinAggregateInputType
    _max?: LocationsMaxAggregateInputType
  }

  export type LocationsGroupByOutputType = {
    id: number
    name: string
    code: string
    locationTypeId: number
    parentId: number | null
    latitude: number | null
    longitude: number | null
    address: string | null
    pincode: string | null
    createdAt: Date
    updatedAt: Date
    _count: LocationsCountAggregateOutputType | null
    _avg: LocationsAvgAggregateOutputType | null
    _sum: LocationsSumAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  type GetLocationsGroupByPayload<T extends locationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationsGroupByOutputType[P]>
        }
      >
    >


  export type locationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    locationTypeId?: boolean
    parentId?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    pincode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consumers?: boolean | locations$consumersArgs<ExtArgs>
    dtrs?: boolean | locations$dtrsArgs<ExtArgs>
    location_types?: boolean | location_typesDefaultArgs<ExtArgs>
    locations?: boolean | locations$locationsArgs<ExtArgs>
    other_locations?: boolean | locations$other_locationsArgs<ExtArgs>
    meters?: boolean | locations$metersArgs<ExtArgs>
    users?: boolean | locations$usersArgs<ExtArgs>
    _count?: boolean | LocationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>

  export type locationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    locationTypeId?: boolean
    parentId?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    pincode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location_types?: boolean | location_typesDefaultArgs<ExtArgs>
    locations?: boolean | locations$locationsArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>

  export type locationsSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    locationTypeId?: boolean
    parentId?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    pincode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type locationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consumers?: boolean | locations$consumersArgs<ExtArgs>
    dtrs?: boolean | locations$dtrsArgs<ExtArgs>
    location_types?: boolean | location_typesDefaultArgs<ExtArgs>
    locations?: boolean | locations$locationsArgs<ExtArgs>
    other_locations?: boolean | locations$other_locationsArgs<ExtArgs>
    meters?: boolean | locations$metersArgs<ExtArgs>
    users?: boolean | locations$usersArgs<ExtArgs>
    _count?: boolean | LocationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type locationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location_types?: boolean | location_typesDefaultArgs<ExtArgs>
    locations?: boolean | locations$locationsArgs<ExtArgs>
  }

  export type $locationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "locations"
    objects: {
      consumers: Prisma.$consumersPayload<ExtArgs> | null
      dtrs: Prisma.$dtrsPayload<ExtArgs>[]
      location_types: Prisma.$location_typesPayload<ExtArgs>
      locations: Prisma.$locationsPayload<ExtArgs> | null
      other_locations: Prisma.$locationsPayload<ExtArgs>[]
      meters: Prisma.$metersPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      locationTypeId: number
      parentId: number | null
      latitude: number | null
      longitude: number | null
      address: string | null
      pincode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["locations"]>
    composites: {}
  }

  type locationsGetPayload<S extends boolean | null | undefined | locationsDefaultArgs> = $Result.GetResult<Prisma.$locationsPayload, S>

  type locationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<locationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationsCountAggregateInputType | true
    }

  export interface locationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['locations'], meta: { name: 'locations' } }
    /**
     * Find zero or one Locations that matches the filter.
     * @param {locationsFindUniqueArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends locationsFindUniqueArgs>(args: SelectSubset<T, locationsFindUniqueArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Locations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {locationsFindUniqueOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends locationsFindUniqueOrThrowArgs>(args: SelectSubset<T, locationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends locationsFindFirstArgs>(args?: SelectSubset<T, locationsFindFirstArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Locations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends locationsFindFirstOrThrowArgs>(args?: SelectSubset<T, locationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.locations.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationsWithIdOnly = await prisma.locations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends locationsFindManyArgs>(args?: SelectSubset<T, locationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Locations.
     * @param {locationsCreateArgs} args - Arguments to create a Locations.
     * @example
     * // Create one Locations
     * const Locations = await prisma.locations.create({
     *   data: {
     *     // ... data to create a Locations
     *   }
     * })
     * 
     */
    create<T extends locationsCreateArgs>(args: SelectSubset<T, locationsCreateArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Locations.
     * @param {locationsCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends locationsCreateManyArgs>(args?: SelectSubset<T, locationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {locationsCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationsWithIdOnly = await prisma.locations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends locationsCreateManyAndReturnArgs>(args?: SelectSubset<T, locationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Locations.
     * @param {locationsDeleteArgs} args - Arguments to delete one Locations.
     * @example
     * // Delete one Locations
     * const Locations = await prisma.locations.delete({
     *   where: {
     *     // ... filter to delete one Locations
     *   }
     * })
     * 
     */
    delete<T extends locationsDeleteArgs>(args: SelectSubset<T, locationsDeleteArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Locations.
     * @param {locationsUpdateArgs} args - Arguments to update one Locations.
     * @example
     * // Update one Locations
     * const locations = await prisma.locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends locationsUpdateArgs>(args: SelectSubset<T, locationsUpdateArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {locationsDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends locationsDeleteManyArgs>(args?: SelectSubset<T, locationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends locationsUpdateManyArgs>(args: SelectSubset<T, locationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Locations.
     * @param {locationsUpsertArgs} args - Arguments to update or create a Locations.
     * @example
     * // Update or create a Locations
     * const locations = await prisma.locations.upsert({
     *   create: {
     *     // ... data to create a Locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locations we want to update
     *   }
     * })
     */
    upsert<T extends locationsUpsertArgs>(args: SelectSubset<T, locationsUpsertArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.locations.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationsCountArgs>(
      args?: Subset<T, locationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationsAggregateArgs>(args: Subset<T, LocationsAggregateArgs>): Prisma.PrismaPromise<GetLocationsAggregateType<T>>

    /**
     * Group by Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends locationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: locationsGroupByArgs['orderBy'] }
        : { orderBy?: locationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, locationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the locations model
   */
  readonly fields: locationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__locationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consumers<T extends locations$consumersArgs<ExtArgs> = {}>(args?: Subset<T, locations$consumersArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    dtrs<T extends locations$dtrsArgs<ExtArgs> = {}>(args?: Subset<T, locations$dtrsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "findMany"> | Null>
    location_types<T extends location_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, location_typesDefaultArgs<ExtArgs>>): Prisma__location_typesClient<$Result.GetResult<Prisma.$location_typesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    locations<T extends locations$locationsArgs<ExtArgs> = {}>(args?: Subset<T, locations$locationsArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    other_locations<T extends locations$other_locationsArgs<ExtArgs> = {}>(args?: Subset<T, locations$other_locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findMany"> | Null>
    meters<T extends locations$metersArgs<ExtArgs> = {}>(args?: Subset<T, locations$metersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends locations$usersArgs<ExtArgs> = {}>(args?: Subset<T, locations$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the locations model
   */ 
  interface locationsFieldRefs {
    readonly id: FieldRef<"locations", 'Int'>
    readonly name: FieldRef<"locations", 'String'>
    readonly code: FieldRef<"locations", 'String'>
    readonly locationTypeId: FieldRef<"locations", 'Int'>
    readonly parentId: FieldRef<"locations", 'Int'>
    readonly latitude: FieldRef<"locations", 'Float'>
    readonly longitude: FieldRef<"locations", 'Float'>
    readonly address: FieldRef<"locations", 'String'>
    readonly pincode: FieldRef<"locations", 'String'>
    readonly createdAt: FieldRef<"locations", 'DateTime'>
    readonly updatedAt: FieldRef<"locations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * locations findUnique
   */
  export type locationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations findUniqueOrThrow
   */
  export type locationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations findFirst
   */
  export type locationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations findFirstOrThrow
   */
  export type locationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations findMany
   */
  export type locationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations create
   */
  export type locationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * The data needed to create a locations.
     */
    data: XOR<locationsCreateInput, locationsUncheckedCreateInput>
  }

  /**
   * locations createMany
   */
  export type locationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many locations.
     */
    data: locationsCreateManyInput | locationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * locations createManyAndReturn
   */
  export type locationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many locations.
     */
    data: locationsCreateManyInput | locationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * locations update
   */
  export type locationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * The data needed to update a locations.
     */
    data: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
    /**
     * Choose, which locations to update.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations updateMany
   */
  export type locationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationsWhereInput
  }

  /**
   * locations upsert
   */
  export type locationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * The filter to search for the locations to update in case it exists.
     */
    where: locationsWhereUniqueInput
    /**
     * In case the locations found by the `where` argument doesn't exist, create a new locations with this data.
     */
    create: XOR<locationsCreateInput, locationsUncheckedCreateInput>
    /**
     * In case the locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
  }

  /**
   * locations delete
   */
  export type locationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    /**
     * Filter which locations to delete.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations deleteMany
   */
  export type locationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to delete
     */
    where?: locationsWhereInput
  }

  /**
   * locations.consumers
   */
  export type locations$consumersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consumers
     */
    select?: consumersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: consumersInclude<ExtArgs> | null
    where?: consumersWhereInput
  }

  /**
   * locations.dtrs
   */
  export type locations$dtrsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    where?: dtrsWhereInput
    orderBy?: dtrsOrderByWithRelationInput | dtrsOrderByWithRelationInput[]
    cursor?: dtrsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DtrsScalarFieldEnum | DtrsScalarFieldEnum[]
  }

  /**
   * locations.locations
   */
  export type locations$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    where?: locationsWhereInput
  }

  /**
   * locations.other_locations
   */
  export type locations$other_locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    where?: locationsWhereInput
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    cursor?: locationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations.meters
   */
  export type locations$metersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    where?: metersWhereInput
    orderBy?: metersOrderByWithRelationInput | metersOrderByWithRelationInput[]
    cursor?: metersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MetersScalarFieldEnum | MetersScalarFieldEnum[]
  }

  /**
   * locations.users
   */
  export type locations$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * locations without action
   */
  export type locationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
  }


  /**
   * Model login_history
   */

  export type AggregateLogin_history = {
    _count: Login_historyCountAggregateOutputType | null
    _avg: Login_historyAvgAggregateOutputType | null
    _sum: Login_historySumAggregateOutputType | null
    _min: Login_historyMinAggregateOutputType | null
    _max: Login_historyMaxAggregateOutputType | null
  }

  export type Login_historyAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Login_historySumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Login_historyMinAggregateOutputType = {
    id: number | null
    userId: number | null
    status: string | null
    ipAddress: string | null
    location: string | null
    failureReason: string | null
    createdAt: Date | null
  }

  export type Login_historyMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    status: string | null
    ipAddress: string | null
    location: string | null
    failureReason: string | null
    createdAt: Date | null
  }

  export type Login_historyCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    ipAddress: number
    deviceInfo: number
    location: number
    failureReason: number
    createdAt: number
    _all: number
  }


  export type Login_historyAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Login_historySumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Login_historyMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    ipAddress?: true
    location?: true
    failureReason?: true
    createdAt?: true
  }

  export type Login_historyMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    ipAddress?: true
    location?: true
    failureReason?: true
    createdAt?: true
  }

  export type Login_historyCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    ipAddress?: true
    deviceInfo?: true
    location?: true
    failureReason?: true
    createdAt?: true
    _all?: true
  }

  export type Login_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which login_history to aggregate.
     */
    where?: login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_histories to fetch.
     */
    orderBy?: login_historyOrderByWithRelationInput | login_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned login_histories
    **/
    _count?: true | Login_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Login_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Login_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Login_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Login_historyMaxAggregateInputType
  }

  export type GetLogin_historyAggregateType<T extends Login_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateLogin_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogin_history[P]>
      : GetScalarType<T[P], AggregateLogin_history[P]>
  }




  export type login_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: login_historyWhereInput
    orderBy?: login_historyOrderByWithAggregationInput | login_historyOrderByWithAggregationInput[]
    by: Login_historyScalarFieldEnum[] | Login_historyScalarFieldEnum
    having?: login_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Login_historyCountAggregateInputType | true
    _avg?: Login_historyAvgAggregateInputType
    _sum?: Login_historySumAggregateInputType
    _min?: Login_historyMinAggregateInputType
    _max?: Login_historyMaxAggregateInputType
  }

  export type Login_historyGroupByOutputType = {
    id: number
    userId: number
    status: string
    ipAddress: string | null
    deviceInfo: JsonValue | null
    location: string | null
    failureReason: string | null
    createdAt: Date
    _count: Login_historyCountAggregateOutputType | null
    _avg: Login_historyAvgAggregateOutputType | null
    _sum: Login_historySumAggregateOutputType | null
    _min: Login_historyMinAggregateOutputType | null
    _max: Login_historyMaxAggregateOutputType | null
  }

  type GetLogin_historyGroupByPayload<T extends login_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Login_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Login_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Login_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Login_historyGroupByOutputType[P]>
        }
      >
    >


  export type login_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    location?: boolean
    failureReason?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["login_history"]>

  export type login_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    location?: boolean
    failureReason?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["login_history"]>

  export type login_historySelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    location?: boolean
    failureReason?: boolean
    createdAt?: boolean
  }

  export type login_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type login_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $login_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "login_history"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      status: string
      ipAddress: string | null
      deviceInfo: Prisma.JsonValue | null
      location: string | null
      failureReason: string | null
      createdAt: Date
    }, ExtArgs["result"]["login_history"]>
    composites: {}
  }

  type login_historyGetPayload<S extends boolean | null | undefined | login_historyDefaultArgs> = $Result.GetResult<Prisma.$login_historyPayload, S>

  type login_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<login_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Login_historyCountAggregateInputType | true
    }

  export interface login_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['login_history'], meta: { name: 'login_history' } }
    /**
     * Find zero or one Login_history that matches the filter.
     * @param {login_historyFindUniqueArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends login_historyFindUniqueArgs>(args: SelectSubset<T, login_historyFindUniqueArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Login_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {login_historyFindUniqueOrThrowArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends login_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, login_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Login_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyFindFirstArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends login_historyFindFirstArgs>(args?: SelectSubset<T, login_historyFindFirstArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Login_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyFindFirstOrThrowArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends login_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, login_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Login_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Login_histories
     * const login_histories = await prisma.login_history.findMany()
     * 
     * // Get first 10 Login_histories
     * const login_histories = await prisma.login_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const login_historyWithIdOnly = await prisma.login_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends login_historyFindManyArgs>(args?: SelectSubset<T, login_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Login_history.
     * @param {login_historyCreateArgs} args - Arguments to create a Login_history.
     * @example
     * // Create one Login_history
     * const Login_history = await prisma.login_history.create({
     *   data: {
     *     // ... data to create a Login_history
     *   }
     * })
     * 
     */
    create<T extends login_historyCreateArgs>(args: SelectSubset<T, login_historyCreateArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Login_histories.
     * @param {login_historyCreateManyArgs} args - Arguments to create many Login_histories.
     * @example
     * // Create many Login_histories
     * const login_history = await prisma.login_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends login_historyCreateManyArgs>(args?: SelectSubset<T, login_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Login_histories and returns the data saved in the database.
     * @param {login_historyCreateManyAndReturnArgs} args - Arguments to create many Login_histories.
     * @example
     * // Create many Login_histories
     * const login_history = await prisma.login_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Login_histories and only return the `id`
     * const login_historyWithIdOnly = await prisma.login_history.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends login_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, login_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Login_history.
     * @param {login_historyDeleteArgs} args - Arguments to delete one Login_history.
     * @example
     * // Delete one Login_history
     * const Login_history = await prisma.login_history.delete({
     *   where: {
     *     // ... filter to delete one Login_history
     *   }
     * })
     * 
     */
    delete<T extends login_historyDeleteArgs>(args: SelectSubset<T, login_historyDeleteArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Login_history.
     * @param {login_historyUpdateArgs} args - Arguments to update one Login_history.
     * @example
     * // Update one Login_history
     * const login_history = await prisma.login_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends login_historyUpdateArgs>(args: SelectSubset<T, login_historyUpdateArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Login_histories.
     * @param {login_historyDeleteManyArgs} args - Arguments to filter Login_histories to delete.
     * @example
     * // Delete a few Login_histories
     * const { count } = await prisma.login_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends login_historyDeleteManyArgs>(args?: SelectSubset<T, login_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Login_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Login_histories
     * const login_history = await prisma.login_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends login_historyUpdateManyArgs>(args: SelectSubset<T, login_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Login_history.
     * @param {login_historyUpsertArgs} args - Arguments to update or create a Login_history.
     * @example
     * // Update or create a Login_history
     * const login_history = await prisma.login_history.upsert({
     *   create: {
     *     // ... data to create a Login_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Login_history we want to update
     *   }
     * })
     */
    upsert<T extends login_historyUpsertArgs>(args: SelectSubset<T, login_historyUpsertArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Login_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyCountArgs} args - Arguments to filter Login_histories to count.
     * @example
     * // Count the number of Login_histories
     * const count = await prisma.login_history.count({
     *   where: {
     *     // ... the filter for the Login_histories we want to count
     *   }
     * })
    **/
    count<T extends login_historyCountArgs>(
      args?: Subset<T, login_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Login_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Login_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Login_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Login_historyAggregateArgs>(args: Subset<T, Login_historyAggregateArgs>): Prisma.PrismaPromise<GetLogin_historyAggregateType<T>>

    /**
     * Group by Login_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends login_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: login_historyGroupByArgs['orderBy'] }
        : { orderBy?: login_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, login_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogin_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the login_history model
   */
  readonly fields: login_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for login_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__login_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the login_history model
   */ 
  interface login_historyFieldRefs {
    readonly id: FieldRef<"login_history", 'Int'>
    readonly userId: FieldRef<"login_history", 'Int'>
    readonly status: FieldRef<"login_history", 'String'>
    readonly ipAddress: FieldRef<"login_history", 'String'>
    readonly deviceInfo: FieldRef<"login_history", 'Json'>
    readonly location: FieldRef<"login_history", 'String'>
    readonly failureReason: FieldRef<"login_history", 'String'>
    readonly createdAt: FieldRef<"login_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * login_history findUnique
   */
  export type login_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyInclude<ExtArgs> | null
    /**
     * Filter, which login_history to fetch.
     */
    where: login_historyWhereUniqueInput
  }

  /**
   * login_history findUniqueOrThrow
   */
  export type login_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyInclude<ExtArgs> | null
    /**
     * Filter, which login_history to fetch.
     */
    where: login_historyWhereUniqueInput
  }

  /**
   * login_history findFirst
   */
  export type login_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyInclude<ExtArgs> | null
    /**
     * Filter, which login_history to fetch.
     */
    where?: login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_histories to fetch.
     */
    orderBy?: login_historyOrderByWithRelationInput | login_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for login_histories.
     */
    cursor?: login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of login_histories.
     */
    distinct?: Login_historyScalarFieldEnum | Login_historyScalarFieldEnum[]
  }

  /**
   * login_history findFirstOrThrow
   */
  export type login_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyInclude<ExtArgs> | null
    /**
     * Filter, which login_history to fetch.
     */
    where?: login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_histories to fetch.
     */
    orderBy?: login_historyOrderByWithRelationInput | login_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for login_histories.
     */
    cursor?: login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of login_histories.
     */
    distinct?: Login_historyScalarFieldEnum | Login_historyScalarFieldEnum[]
  }

  /**
   * login_history findMany
   */
  export type login_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyInclude<ExtArgs> | null
    /**
     * Filter, which login_histories to fetch.
     */
    where?: login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_histories to fetch.
     */
    orderBy?: login_historyOrderByWithRelationInput | login_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing login_histories.
     */
    cursor?: login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_histories.
     */
    skip?: number
    distinct?: Login_historyScalarFieldEnum | Login_historyScalarFieldEnum[]
  }

  /**
   * login_history create
   */
  export type login_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a login_history.
     */
    data: XOR<login_historyCreateInput, login_historyUncheckedCreateInput>
  }

  /**
   * login_history createMany
   */
  export type login_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many login_histories.
     */
    data: login_historyCreateManyInput | login_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * login_history createManyAndReturn
   */
  export type login_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many login_histories.
     */
    data: login_historyCreateManyInput | login_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * login_history update
   */
  export type login_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a login_history.
     */
    data: XOR<login_historyUpdateInput, login_historyUncheckedUpdateInput>
    /**
     * Choose, which login_history to update.
     */
    where: login_historyWhereUniqueInput
  }

  /**
   * login_history updateMany
   */
  export type login_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update login_histories.
     */
    data: XOR<login_historyUpdateManyMutationInput, login_historyUncheckedUpdateManyInput>
    /**
     * Filter which login_histories to update
     */
    where?: login_historyWhereInput
  }

  /**
   * login_history upsert
   */
  export type login_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the login_history to update in case it exists.
     */
    where: login_historyWhereUniqueInput
    /**
     * In case the login_history found by the `where` argument doesn't exist, create a new login_history with this data.
     */
    create: XOR<login_historyCreateInput, login_historyUncheckedCreateInput>
    /**
     * In case the login_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<login_historyUpdateInput, login_historyUncheckedUpdateInput>
  }

  /**
   * login_history delete
   */
  export type login_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyInclude<ExtArgs> | null
    /**
     * Filter which login_history to delete.
     */
    where: login_historyWhereUniqueInput
  }

  /**
   * login_history deleteMany
   */
  export type login_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which login_histories to delete
     */
    where?: login_historyWhereInput
  }

  /**
   * login_history without action
   */
  export type login_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyInclude<ExtArgs> | null
  }


  /**
   * Model meter_configurations
   */

  export type AggregateMeter_configurations = {
    _count: Meter_configurationsCountAggregateOutputType | null
    _avg: Meter_configurationsAvgAggregateOutputType | null
    _sum: Meter_configurationsSumAggregateOutputType | null
    _min: Meter_configurationsMinAggregateOutputType | null
    _max: Meter_configurationsMaxAggregateOutputType | null
  }

  export type Meter_configurationsAvgAggregateOutputType = {
    id: number | null
    meterId: number | null
    ctRatioPrimary: number | null
    ctRatioSecondary: number | null
    ctBurden: number | null
    ptRatioPrimary: number | null
    ptRatioSecondary: number | null
    ptBurden: number | null
    mf: number | null
    vmf: number | null
    cmf: number | null
  }

  export type Meter_configurationsSumAggregateOutputType = {
    id: number | null
    meterId: number | null
    ctRatioPrimary: number | null
    ctRatioSecondary: number | null
    ctBurden: number | null
    ptRatioPrimary: number | null
    ptRatioSecondary: number | null
    ptBurden: number | null
    mf: number | null
    vmf: number | null
    cmf: number | null
  }

  export type Meter_configurationsMinAggregateOutputType = {
    id: number | null
    meterId: number | null
    ctRatio: string | null
    ctRatioPrimary: number | null
    ctRatioSecondary: number | null
    adoptedCTRatio: string | null
    ctAccuracyClass: string | null
    ctBurden: number | null
    ptRatio: string | null
    ptRatioPrimary: number | null
    ptRatioSecondary: number | null
    adoptedPTRatio: string | null
    ptAccuracyClass: string | null
    ptBurden: number | null
    mf: number | null
    vmf: number | null
    cmf: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Meter_configurationsMaxAggregateOutputType = {
    id: number | null
    meterId: number | null
    ctRatio: string | null
    ctRatioPrimary: number | null
    ctRatioSecondary: number | null
    adoptedCTRatio: string | null
    ctAccuracyClass: string | null
    ctBurden: number | null
    ptRatio: string | null
    ptRatioPrimary: number | null
    ptRatioSecondary: number | null
    adoptedPTRatio: string | null
    ptAccuracyClass: string | null
    ptBurden: number | null
    mf: number | null
    vmf: number | null
    cmf: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Meter_configurationsCountAggregateOutputType = {
    id: number
    meterId: number
    ctRatio: number
    ctRatioPrimary: number
    ctRatioSecondary: number
    adoptedCTRatio: number
    ctAccuracyClass: number
    ctBurden: number
    ptRatio: number
    ptRatioPrimary: number
    ptRatioSecondary: number
    adoptedPTRatio: number
    ptAccuracyClass: number
    ptBurden: number
    mf: number
    vmf: number
    cmf: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Meter_configurationsAvgAggregateInputType = {
    id?: true
    meterId?: true
    ctRatioPrimary?: true
    ctRatioSecondary?: true
    ctBurden?: true
    ptRatioPrimary?: true
    ptRatioSecondary?: true
    ptBurden?: true
    mf?: true
    vmf?: true
    cmf?: true
  }

  export type Meter_configurationsSumAggregateInputType = {
    id?: true
    meterId?: true
    ctRatioPrimary?: true
    ctRatioSecondary?: true
    ctBurden?: true
    ptRatioPrimary?: true
    ptRatioSecondary?: true
    ptBurden?: true
    mf?: true
    vmf?: true
    cmf?: true
  }

  export type Meter_configurationsMinAggregateInputType = {
    id?: true
    meterId?: true
    ctRatio?: true
    ctRatioPrimary?: true
    ctRatioSecondary?: true
    adoptedCTRatio?: true
    ctAccuracyClass?: true
    ctBurden?: true
    ptRatio?: true
    ptRatioPrimary?: true
    ptRatioSecondary?: true
    adoptedPTRatio?: true
    ptAccuracyClass?: true
    ptBurden?: true
    mf?: true
    vmf?: true
    cmf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Meter_configurationsMaxAggregateInputType = {
    id?: true
    meterId?: true
    ctRatio?: true
    ctRatioPrimary?: true
    ctRatioSecondary?: true
    adoptedCTRatio?: true
    ctAccuracyClass?: true
    ctBurden?: true
    ptRatio?: true
    ptRatioPrimary?: true
    ptRatioSecondary?: true
    adoptedPTRatio?: true
    ptAccuracyClass?: true
    ptBurden?: true
    mf?: true
    vmf?: true
    cmf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Meter_configurationsCountAggregateInputType = {
    id?: true
    meterId?: true
    ctRatio?: true
    ctRatioPrimary?: true
    ctRatioSecondary?: true
    adoptedCTRatio?: true
    ctAccuracyClass?: true
    ctBurden?: true
    ptRatio?: true
    ptRatioPrimary?: true
    ptRatioSecondary?: true
    adoptedPTRatio?: true
    ptAccuracyClass?: true
    ptBurden?: true
    mf?: true
    vmf?: true
    cmf?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Meter_configurationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_configurations to aggregate.
     */
    where?: meter_configurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_configurations to fetch.
     */
    orderBy?: meter_configurationsOrderByWithRelationInput | meter_configurationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meter_configurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meter_configurations
    **/
    _count?: true | Meter_configurationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Meter_configurationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Meter_configurationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Meter_configurationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Meter_configurationsMaxAggregateInputType
  }

  export type GetMeter_configurationsAggregateType<T extends Meter_configurationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMeter_configurations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeter_configurations[P]>
      : GetScalarType<T[P], AggregateMeter_configurations[P]>
  }




  export type meter_configurationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meter_configurationsWhereInput
    orderBy?: meter_configurationsOrderByWithAggregationInput | meter_configurationsOrderByWithAggregationInput[]
    by: Meter_configurationsScalarFieldEnum[] | Meter_configurationsScalarFieldEnum
    having?: meter_configurationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Meter_configurationsCountAggregateInputType | true
    _avg?: Meter_configurationsAvgAggregateInputType
    _sum?: Meter_configurationsSumAggregateInputType
    _min?: Meter_configurationsMinAggregateInputType
    _max?: Meter_configurationsMaxAggregateInputType
  }

  export type Meter_configurationsGroupByOutputType = {
    id: number
    meterId: number
    ctRatio: string
    ctRatioPrimary: number
    ctRatioSecondary: number
    adoptedCTRatio: string | null
    ctAccuracyClass: string | null
    ctBurden: number | null
    ptRatio: string
    ptRatioPrimary: number
    ptRatioSecondary: number
    adoptedPTRatio: string | null
    ptAccuracyClass: string | null
    ptBurden: number | null
    mf: number
    vmf: number
    cmf: number
    createdAt: Date
    updatedAt: Date
    _count: Meter_configurationsCountAggregateOutputType | null
    _avg: Meter_configurationsAvgAggregateOutputType | null
    _sum: Meter_configurationsSumAggregateOutputType | null
    _min: Meter_configurationsMinAggregateOutputType | null
    _max: Meter_configurationsMaxAggregateOutputType | null
  }

  type GetMeter_configurationsGroupByPayload<T extends meter_configurationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Meter_configurationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Meter_configurationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Meter_configurationsGroupByOutputType[P]>
            : GetScalarType<T[P], Meter_configurationsGroupByOutputType[P]>
        }
      >
    >


  export type meter_configurationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterId?: boolean
    ctRatio?: boolean
    ctRatioPrimary?: boolean
    ctRatioSecondary?: boolean
    adoptedCTRatio?: boolean
    ctAccuracyClass?: boolean
    ctBurden?: boolean
    ptRatio?: boolean
    ptRatioPrimary?: boolean
    ptRatioSecondary?: boolean
    adoptedPTRatio?: boolean
    ptAccuracyClass?: boolean
    ptBurden?: boolean
    mf?: boolean
    vmf?: boolean
    cmf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meter_configurations"]>

  export type meter_configurationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterId?: boolean
    ctRatio?: boolean
    ctRatioPrimary?: boolean
    ctRatioSecondary?: boolean
    adoptedCTRatio?: boolean
    ctAccuracyClass?: boolean
    ctBurden?: boolean
    ptRatio?: boolean
    ptRatioPrimary?: boolean
    ptRatioSecondary?: boolean
    adoptedPTRatio?: boolean
    ptAccuracyClass?: boolean
    ptBurden?: boolean
    mf?: boolean
    vmf?: boolean
    cmf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meter_configurations"]>

  export type meter_configurationsSelectScalar = {
    id?: boolean
    meterId?: boolean
    ctRatio?: boolean
    ctRatioPrimary?: boolean
    ctRatioSecondary?: boolean
    adoptedCTRatio?: boolean
    ctAccuracyClass?: boolean
    ctBurden?: boolean
    ptRatio?: boolean
    ptRatioPrimary?: boolean
    ptRatioSecondary?: boolean
    adoptedPTRatio?: boolean
    ptAccuracyClass?: boolean
    ptBurden?: boolean
    mf?: boolean
    vmf?: boolean
    cmf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type meter_configurationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }
  export type meter_configurationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }

  export type $meter_configurationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meter_configurations"
    objects: {
      meters: Prisma.$metersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      meterId: number
      ctRatio: string
      ctRatioPrimary: number
      ctRatioSecondary: number
      adoptedCTRatio: string | null
      ctAccuracyClass: string | null
      ctBurden: number | null
      ptRatio: string
      ptRatioPrimary: number
      ptRatioSecondary: number
      adoptedPTRatio: string | null
      ptAccuracyClass: string | null
      ptBurden: number | null
      mf: number
      vmf: number
      cmf: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meter_configurations"]>
    composites: {}
  }

  type meter_configurationsGetPayload<S extends boolean | null | undefined | meter_configurationsDefaultArgs> = $Result.GetResult<Prisma.$meter_configurationsPayload, S>

  type meter_configurationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<meter_configurationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Meter_configurationsCountAggregateInputType | true
    }

  export interface meter_configurationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meter_configurations'], meta: { name: 'meter_configurations' } }
    /**
     * Find zero or one Meter_configurations that matches the filter.
     * @param {meter_configurationsFindUniqueArgs} args - Arguments to find a Meter_configurations
     * @example
     * // Get one Meter_configurations
     * const meter_configurations = await prisma.meter_configurations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends meter_configurationsFindUniqueArgs>(args: SelectSubset<T, meter_configurationsFindUniqueArgs<ExtArgs>>): Prisma__meter_configurationsClient<$Result.GetResult<Prisma.$meter_configurationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Meter_configurations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {meter_configurationsFindUniqueOrThrowArgs} args - Arguments to find a Meter_configurations
     * @example
     * // Get one Meter_configurations
     * const meter_configurations = await prisma.meter_configurations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends meter_configurationsFindUniqueOrThrowArgs>(args: SelectSubset<T, meter_configurationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__meter_configurationsClient<$Result.GetResult<Prisma.$meter_configurationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Meter_configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_configurationsFindFirstArgs} args - Arguments to find a Meter_configurations
     * @example
     * // Get one Meter_configurations
     * const meter_configurations = await prisma.meter_configurations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends meter_configurationsFindFirstArgs>(args?: SelectSubset<T, meter_configurationsFindFirstArgs<ExtArgs>>): Prisma__meter_configurationsClient<$Result.GetResult<Prisma.$meter_configurationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Meter_configurations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_configurationsFindFirstOrThrowArgs} args - Arguments to find a Meter_configurations
     * @example
     * // Get one Meter_configurations
     * const meter_configurations = await prisma.meter_configurations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends meter_configurationsFindFirstOrThrowArgs>(args?: SelectSubset<T, meter_configurationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__meter_configurationsClient<$Result.GetResult<Prisma.$meter_configurationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Meter_configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_configurationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meter_configurations
     * const meter_configurations = await prisma.meter_configurations.findMany()
     * 
     * // Get first 10 Meter_configurations
     * const meter_configurations = await prisma.meter_configurations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meter_configurationsWithIdOnly = await prisma.meter_configurations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends meter_configurationsFindManyArgs>(args?: SelectSubset<T, meter_configurationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meter_configurationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Meter_configurations.
     * @param {meter_configurationsCreateArgs} args - Arguments to create a Meter_configurations.
     * @example
     * // Create one Meter_configurations
     * const Meter_configurations = await prisma.meter_configurations.create({
     *   data: {
     *     // ... data to create a Meter_configurations
     *   }
     * })
     * 
     */
    create<T extends meter_configurationsCreateArgs>(args: SelectSubset<T, meter_configurationsCreateArgs<ExtArgs>>): Prisma__meter_configurationsClient<$Result.GetResult<Prisma.$meter_configurationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Meter_configurations.
     * @param {meter_configurationsCreateManyArgs} args - Arguments to create many Meter_configurations.
     * @example
     * // Create many Meter_configurations
     * const meter_configurations = await prisma.meter_configurations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends meter_configurationsCreateManyArgs>(args?: SelectSubset<T, meter_configurationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meter_configurations and returns the data saved in the database.
     * @param {meter_configurationsCreateManyAndReturnArgs} args - Arguments to create many Meter_configurations.
     * @example
     * // Create many Meter_configurations
     * const meter_configurations = await prisma.meter_configurations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meter_configurations and only return the `id`
     * const meter_configurationsWithIdOnly = await prisma.meter_configurations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends meter_configurationsCreateManyAndReturnArgs>(args?: SelectSubset<T, meter_configurationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meter_configurationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Meter_configurations.
     * @param {meter_configurationsDeleteArgs} args - Arguments to delete one Meter_configurations.
     * @example
     * // Delete one Meter_configurations
     * const Meter_configurations = await prisma.meter_configurations.delete({
     *   where: {
     *     // ... filter to delete one Meter_configurations
     *   }
     * })
     * 
     */
    delete<T extends meter_configurationsDeleteArgs>(args: SelectSubset<T, meter_configurationsDeleteArgs<ExtArgs>>): Prisma__meter_configurationsClient<$Result.GetResult<Prisma.$meter_configurationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Meter_configurations.
     * @param {meter_configurationsUpdateArgs} args - Arguments to update one Meter_configurations.
     * @example
     * // Update one Meter_configurations
     * const meter_configurations = await prisma.meter_configurations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends meter_configurationsUpdateArgs>(args: SelectSubset<T, meter_configurationsUpdateArgs<ExtArgs>>): Prisma__meter_configurationsClient<$Result.GetResult<Prisma.$meter_configurationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Meter_configurations.
     * @param {meter_configurationsDeleteManyArgs} args - Arguments to filter Meter_configurations to delete.
     * @example
     * // Delete a few Meter_configurations
     * const { count } = await prisma.meter_configurations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends meter_configurationsDeleteManyArgs>(args?: SelectSubset<T, meter_configurationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meter_configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_configurationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meter_configurations
     * const meter_configurations = await prisma.meter_configurations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends meter_configurationsUpdateManyArgs>(args: SelectSubset<T, meter_configurationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meter_configurations.
     * @param {meter_configurationsUpsertArgs} args - Arguments to update or create a Meter_configurations.
     * @example
     * // Update or create a Meter_configurations
     * const meter_configurations = await prisma.meter_configurations.upsert({
     *   create: {
     *     // ... data to create a Meter_configurations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meter_configurations we want to update
     *   }
     * })
     */
    upsert<T extends meter_configurationsUpsertArgs>(args: SelectSubset<T, meter_configurationsUpsertArgs<ExtArgs>>): Prisma__meter_configurationsClient<$Result.GetResult<Prisma.$meter_configurationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Meter_configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_configurationsCountArgs} args - Arguments to filter Meter_configurations to count.
     * @example
     * // Count the number of Meter_configurations
     * const count = await prisma.meter_configurations.count({
     *   where: {
     *     // ... the filter for the Meter_configurations we want to count
     *   }
     * })
    **/
    count<T extends meter_configurationsCountArgs>(
      args?: Subset<T, meter_configurationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Meter_configurationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meter_configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Meter_configurationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Meter_configurationsAggregateArgs>(args: Subset<T, Meter_configurationsAggregateArgs>): Prisma.PrismaPromise<GetMeter_configurationsAggregateType<T>>

    /**
     * Group by Meter_configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_configurationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends meter_configurationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: meter_configurationsGroupByArgs['orderBy'] }
        : { orderBy?: meter_configurationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, meter_configurationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeter_configurationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meter_configurations model
   */
  readonly fields: meter_configurationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meter_configurations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__meter_configurationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meters<T extends metersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, metersDefaultArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meter_configurations model
   */ 
  interface meter_configurationsFieldRefs {
    readonly id: FieldRef<"meter_configurations", 'Int'>
    readonly meterId: FieldRef<"meter_configurations", 'Int'>
    readonly ctRatio: FieldRef<"meter_configurations", 'String'>
    readonly ctRatioPrimary: FieldRef<"meter_configurations", 'Float'>
    readonly ctRatioSecondary: FieldRef<"meter_configurations", 'Float'>
    readonly adoptedCTRatio: FieldRef<"meter_configurations", 'String'>
    readonly ctAccuracyClass: FieldRef<"meter_configurations", 'String'>
    readonly ctBurden: FieldRef<"meter_configurations", 'Float'>
    readonly ptRatio: FieldRef<"meter_configurations", 'String'>
    readonly ptRatioPrimary: FieldRef<"meter_configurations", 'Float'>
    readonly ptRatioSecondary: FieldRef<"meter_configurations", 'Float'>
    readonly adoptedPTRatio: FieldRef<"meter_configurations", 'String'>
    readonly ptAccuracyClass: FieldRef<"meter_configurations", 'String'>
    readonly ptBurden: FieldRef<"meter_configurations", 'Float'>
    readonly mf: FieldRef<"meter_configurations", 'Float'>
    readonly vmf: FieldRef<"meter_configurations", 'Float'>
    readonly cmf: FieldRef<"meter_configurations", 'Float'>
    readonly createdAt: FieldRef<"meter_configurations", 'DateTime'>
    readonly updatedAt: FieldRef<"meter_configurations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * meter_configurations findUnique
   */
  export type meter_configurationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsInclude<ExtArgs> | null
    /**
     * Filter, which meter_configurations to fetch.
     */
    where: meter_configurationsWhereUniqueInput
  }

  /**
   * meter_configurations findUniqueOrThrow
   */
  export type meter_configurationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsInclude<ExtArgs> | null
    /**
     * Filter, which meter_configurations to fetch.
     */
    where: meter_configurationsWhereUniqueInput
  }

  /**
   * meter_configurations findFirst
   */
  export type meter_configurationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsInclude<ExtArgs> | null
    /**
     * Filter, which meter_configurations to fetch.
     */
    where?: meter_configurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_configurations to fetch.
     */
    orderBy?: meter_configurationsOrderByWithRelationInput | meter_configurationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_configurations.
     */
    cursor?: meter_configurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_configurations.
     */
    distinct?: Meter_configurationsScalarFieldEnum | Meter_configurationsScalarFieldEnum[]
  }

  /**
   * meter_configurations findFirstOrThrow
   */
  export type meter_configurationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsInclude<ExtArgs> | null
    /**
     * Filter, which meter_configurations to fetch.
     */
    where?: meter_configurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_configurations to fetch.
     */
    orderBy?: meter_configurationsOrderByWithRelationInput | meter_configurationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_configurations.
     */
    cursor?: meter_configurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_configurations.
     */
    distinct?: Meter_configurationsScalarFieldEnum | Meter_configurationsScalarFieldEnum[]
  }

  /**
   * meter_configurations findMany
   */
  export type meter_configurationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsInclude<ExtArgs> | null
    /**
     * Filter, which meter_configurations to fetch.
     */
    where?: meter_configurationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_configurations to fetch.
     */
    orderBy?: meter_configurationsOrderByWithRelationInput | meter_configurationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meter_configurations.
     */
    cursor?: meter_configurationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_configurations.
     */
    skip?: number
    distinct?: Meter_configurationsScalarFieldEnum | Meter_configurationsScalarFieldEnum[]
  }

  /**
   * meter_configurations create
   */
  export type meter_configurationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsInclude<ExtArgs> | null
    /**
     * The data needed to create a meter_configurations.
     */
    data: XOR<meter_configurationsCreateInput, meter_configurationsUncheckedCreateInput>
  }

  /**
   * meter_configurations createMany
   */
  export type meter_configurationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meter_configurations.
     */
    data: meter_configurationsCreateManyInput | meter_configurationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meter_configurations createManyAndReturn
   */
  export type meter_configurationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many meter_configurations.
     */
    data: meter_configurationsCreateManyInput | meter_configurationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * meter_configurations update
   */
  export type meter_configurationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsInclude<ExtArgs> | null
    /**
     * The data needed to update a meter_configurations.
     */
    data: XOR<meter_configurationsUpdateInput, meter_configurationsUncheckedUpdateInput>
    /**
     * Choose, which meter_configurations to update.
     */
    where: meter_configurationsWhereUniqueInput
  }

  /**
   * meter_configurations updateMany
   */
  export type meter_configurationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meter_configurations.
     */
    data: XOR<meter_configurationsUpdateManyMutationInput, meter_configurationsUncheckedUpdateManyInput>
    /**
     * Filter which meter_configurations to update
     */
    where?: meter_configurationsWhereInput
  }

  /**
   * meter_configurations upsert
   */
  export type meter_configurationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsInclude<ExtArgs> | null
    /**
     * The filter to search for the meter_configurations to update in case it exists.
     */
    where: meter_configurationsWhereUniqueInput
    /**
     * In case the meter_configurations found by the `where` argument doesn't exist, create a new meter_configurations with this data.
     */
    create: XOR<meter_configurationsCreateInput, meter_configurationsUncheckedCreateInput>
    /**
     * In case the meter_configurations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meter_configurationsUpdateInput, meter_configurationsUncheckedUpdateInput>
  }

  /**
   * meter_configurations delete
   */
  export type meter_configurationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsInclude<ExtArgs> | null
    /**
     * Filter which meter_configurations to delete.
     */
    where: meter_configurationsWhereUniqueInput
  }

  /**
   * meter_configurations deleteMany
   */
  export type meter_configurationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_configurations to delete
     */
    where?: meter_configurationsWhereInput
  }

  /**
   * meter_configurations without action
   */
  export type meter_configurationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsInclude<ExtArgs> | null
  }


  /**
   * Model meter_readings
   */

  export type AggregateMeter_readings = {
    _count: Meter_readingsCountAggregateOutputType | null
    _avg: Meter_readingsAvgAggregateOutputType | null
    _sum: Meter_readingsSumAggregateOutputType | null
    _min: Meter_readingsMinAggregateOutputType | null
    _max: Meter_readingsMaxAggregateOutputType | null
  }

  export type Meter_readingsAvgAggregateOutputType = {
    id: number | null
    meterId: number | null
    currentReading: number | null
    previousReading: number | null
    consumption: number | null
    kWh: number | null
    kVAh: number | null
    kVARh: number | null
    powerFactor: number | null
    averagePF: number | null
    minimumPF: number | null
    voltageR: number | null
    voltageY: number | null
    voltageB: number | null
    averageVoltage: number | null
    currentR: number | null
    currentY: number | null
    currentB: number | null
    averageCurrent: number | null
    billId: number | null
    kVA: number | null
    kW: number | null
    bphPowerFactor: number | null
    frequency: number | null
    rphPowerFactor: number | null
    yphPowerFactor: number | null
  }

  export type Meter_readingsSumAggregateOutputType = {
    id: number | null
    meterId: number | null
    currentReading: number | null
    previousReading: number | null
    consumption: number | null
    kWh: number | null
    kVAh: number | null
    kVARh: number | null
    powerFactor: number | null
    averagePF: number | null
    minimumPF: number | null
    voltageR: number | null
    voltageY: number | null
    voltageB: number | null
    averageVoltage: number | null
    currentR: number | null
    currentY: number | null
    currentB: number | null
    averageCurrent: number | null
    billId: number | null
    kVA: number | null
    kW: number | null
    bphPowerFactor: number | null
    frequency: number | null
    rphPowerFactor: number | null
    yphPowerFactor: number | null
  }

  export type Meter_readingsMinAggregateOutputType = {
    id: number | null
    meterId: number | null
    readingDate: Date | null
    readingType: $Enums.ReadingType | null
    readingSource: $Enums.ReadingSource | null
    currentReading: number | null
    previousReading: number | null
    consumption: number | null
    kWh: number | null
    kVAh: number | null
    kVARh: number | null
    powerFactor: number | null
    averagePF: number | null
    minimumPF: number | null
    voltageR: number | null
    voltageY: number | null
    voltageB: number | null
    averageVoltage: number | null
    currentR: number | null
    currentY: number | null
    currentB: number | null
    averageCurrent: number | null
    isValid: boolean | null
    validatedBy: string | null
    validatedAt: Date | null
    billId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    kVA: number | null
    kW: number | null
    bphPowerFactor: number | null
    frequency: number | null
    rphPowerFactor: number | null
    yphPowerFactor: number | null
  }

  export type Meter_readingsMaxAggregateOutputType = {
    id: number | null
    meterId: number | null
    readingDate: Date | null
    readingType: $Enums.ReadingType | null
    readingSource: $Enums.ReadingSource | null
    currentReading: number | null
    previousReading: number | null
    consumption: number | null
    kWh: number | null
    kVAh: number | null
    kVARh: number | null
    powerFactor: number | null
    averagePF: number | null
    minimumPF: number | null
    voltageR: number | null
    voltageY: number | null
    voltageB: number | null
    averageVoltage: number | null
    currentR: number | null
    currentY: number | null
    currentB: number | null
    averageCurrent: number | null
    isValid: boolean | null
    validatedBy: string | null
    validatedAt: Date | null
    billId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    kVA: number | null
    kW: number | null
    bphPowerFactor: number | null
    frequency: number | null
    rphPowerFactor: number | null
    yphPowerFactor: number | null
  }

  export type Meter_readingsCountAggregateOutputType = {
    id: number
    meterId: number
    readingDate: number
    readingType: number
    readingSource: number
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh: number
    kVARh: number
    powerFactor: number
    averagePF: number
    minimumPF: number
    voltageR: number
    voltageY: number
    voltageB: number
    averageVoltage: number
    currentR: number
    currentY: number
    currentB: number
    averageCurrent: number
    isValid: number
    validatedBy: number
    validatedAt: number
    billId: number
    createdAt: number
    updatedAt: number
    kVA: number
    kW: number
    bphPowerFactor: number
    frequency: number
    rphPowerFactor: number
    yphPowerFactor: number
    _all: number
  }


  export type Meter_readingsAvgAggregateInputType = {
    id?: true
    meterId?: true
    currentReading?: true
    previousReading?: true
    consumption?: true
    kWh?: true
    kVAh?: true
    kVARh?: true
    powerFactor?: true
    averagePF?: true
    minimumPF?: true
    voltageR?: true
    voltageY?: true
    voltageB?: true
    averageVoltage?: true
    currentR?: true
    currentY?: true
    currentB?: true
    averageCurrent?: true
    billId?: true
    kVA?: true
    kW?: true
    bphPowerFactor?: true
    frequency?: true
    rphPowerFactor?: true
    yphPowerFactor?: true
  }

  export type Meter_readingsSumAggregateInputType = {
    id?: true
    meterId?: true
    currentReading?: true
    previousReading?: true
    consumption?: true
    kWh?: true
    kVAh?: true
    kVARh?: true
    powerFactor?: true
    averagePF?: true
    minimumPF?: true
    voltageR?: true
    voltageY?: true
    voltageB?: true
    averageVoltage?: true
    currentR?: true
    currentY?: true
    currentB?: true
    averageCurrent?: true
    billId?: true
    kVA?: true
    kW?: true
    bphPowerFactor?: true
    frequency?: true
    rphPowerFactor?: true
    yphPowerFactor?: true
  }

  export type Meter_readingsMinAggregateInputType = {
    id?: true
    meterId?: true
    readingDate?: true
    readingType?: true
    readingSource?: true
    currentReading?: true
    previousReading?: true
    consumption?: true
    kWh?: true
    kVAh?: true
    kVARh?: true
    powerFactor?: true
    averagePF?: true
    minimumPF?: true
    voltageR?: true
    voltageY?: true
    voltageB?: true
    averageVoltage?: true
    currentR?: true
    currentY?: true
    currentB?: true
    averageCurrent?: true
    isValid?: true
    validatedBy?: true
    validatedAt?: true
    billId?: true
    createdAt?: true
    updatedAt?: true
    kVA?: true
    kW?: true
    bphPowerFactor?: true
    frequency?: true
    rphPowerFactor?: true
    yphPowerFactor?: true
  }

  export type Meter_readingsMaxAggregateInputType = {
    id?: true
    meterId?: true
    readingDate?: true
    readingType?: true
    readingSource?: true
    currentReading?: true
    previousReading?: true
    consumption?: true
    kWh?: true
    kVAh?: true
    kVARh?: true
    powerFactor?: true
    averagePF?: true
    minimumPF?: true
    voltageR?: true
    voltageY?: true
    voltageB?: true
    averageVoltage?: true
    currentR?: true
    currentY?: true
    currentB?: true
    averageCurrent?: true
    isValid?: true
    validatedBy?: true
    validatedAt?: true
    billId?: true
    createdAt?: true
    updatedAt?: true
    kVA?: true
    kW?: true
    bphPowerFactor?: true
    frequency?: true
    rphPowerFactor?: true
    yphPowerFactor?: true
  }

  export type Meter_readingsCountAggregateInputType = {
    id?: true
    meterId?: true
    readingDate?: true
    readingType?: true
    readingSource?: true
    currentReading?: true
    previousReading?: true
    consumption?: true
    kWh?: true
    kVAh?: true
    kVARh?: true
    powerFactor?: true
    averagePF?: true
    minimumPF?: true
    voltageR?: true
    voltageY?: true
    voltageB?: true
    averageVoltage?: true
    currentR?: true
    currentY?: true
    currentB?: true
    averageCurrent?: true
    isValid?: true
    validatedBy?: true
    validatedAt?: true
    billId?: true
    createdAt?: true
    updatedAt?: true
    kVA?: true
    kW?: true
    bphPowerFactor?: true
    frequency?: true
    rphPowerFactor?: true
    yphPowerFactor?: true
    _all?: true
  }

  export type Meter_readingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_readings to aggregate.
     */
    where?: meter_readingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_readings to fetch.
     */
    orderBy?: meter_readingsOrderByWithRelationInput | meter_readingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meter_readingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_readings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meter_readings
    **/
    _count?: true | Meter_readingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Meter_readingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Meter_readingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Meter_readingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Meter_readingsMaxAggregateInputType
  }

  export type GetMeter_readingsAggregateType<T extends Meter_readingsAggregateArgs> = {
        [P in keyof T & keyof AggregateMeter_readings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeter_readings[P]>
      : GetScalarType<T[P], AggregateMeter_readings[P]>
  }




  export type meter_readingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meter_readingsWhereInput
    orderBy?: meter_readingsOrderByWithAggregationInput | meter_readingsOrderByWithAggregationInput[]
    by: Meter_readingsScalarFieldEnum[] | Meter_readingsScalarFieldEnum
    having?: meter_readingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Meter_readingsCountAggregateInputType | true
    _avg?: Meter_readingsAvgAggregateInputType
    _sum?: Meter_readingsSumAggregateInputType
    _min?: Meter_readingsMinAggregateInputType
    _max?: Meter_readingsMaxAggregateInputType
  }

  export type Meter_readingsGroupByOutputType = {
    id: number
    meterId: number
    readingDate: Date
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh: number | null
    kVARh: number | null
    powerFactor: number | null
    averagePF: number | null
    minimumPF: number | null
    voltageR: number | null
    voltageY: number | null
    voltageB: number | null
    averageVoltage: number | null
    currentR: number | null
    currentY: number | null
    currentB: number | null
    averageCurrent: number | null
    isValid: boolean
    validatedBy: string | null
    validatedAt: Date | null
    billId: number | null
    createdAt: Date
    updatedAt: Date
    kVA: number | null
    kW: number | null
    bphPowerFactor: number | null
    frequency: number | null
    rphPowerFactor: number | null
    yphPowerFactor: number | null
    _count: Meter_readingsCountAggregateOutputType | null
    _avg: Meter_readingsAvgAggregateOutputType | null
    _sum: Meter_readingsSumAggregateOutputType | null
    _min: Meter_readingsMinAggregateOutputType | null
    _max: Meter_readingsMaxAggregateOutputType | null
  }

  type GetMeter_readingsGroupByPayload<T extends meter_readingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Meter_readingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Meter_readingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Meter_readingsGroupByOutputType[P]>
            : GetScalarType<T[P], Meter_readingsGroupByOutputType[P]>
        }
      >
    >


  export type meter_readingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterId?: boolean
    readingDate?: boolean
    readingType?: boolean
    readingSource?: boolean
    currentReading?: boolean
    previousReading?: boolean
    consumption?: boolean
    kWh?: boolean
    kVAh?: boolean
    kVARh?: boolean
    powerFactor?: boolean
    averagePF?: boolean
    minimumPF?: boolean
    voltageR?: boolean
    voltageY?: boolean
    voltageB?: boolean
    averageVoltage?: boolean
    currentR?: boolean
    currentY?: boolean
    currentB?: boolean
    averageCurrent?: boolean
    isValid?: boolean
    validatedBy?: boolean
    validatedAt?: boolean
    billId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kVA?: boolean
    kW?: boolean
    bphPowerFactor?: boolean
    frequency?: boolean
    rphPowerFactor?: boolean
    yphPowerFactor?: boolean
    bills?: boolean | meter_readings$billsArgs<ExtArgs>
    meters?: boolean | metersDefaultArgs<ExtArgs>
    prepaid_transactions?: boolean | meter_readings$prepaid_transactionsArgs<ExtArgs>
    _count?: boolean | Meter_readingsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meter_readings"]>

  export type meter_readingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterId?: boolean
    readingDate?: boolean
    readingType?: boolean
    readingSource?: boolean
    currentReading?: boolean
    previousReading?: boolean
    consumption?: boolean
    kWh?: boolean
    kVAh?: boolean
    kVARh?: boolean
    powerFactor?: boolean
    averagePF?: boolean
    minimumPF?: boolean
    voltageR?: boolean
    voltageY?: boolean
    voltageB?: boolean
    averageVoltage?: boolean
    currentR?: boolean
    currentY?: boolean
    currentB?: boolean
    averageCurrent?: boolean
    isValid?: boolean
    validatedBy?: boolean
    validatedAt?: boolean
    billId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kVA?: boolean
    kW?: boolean
    bphPowerFactor?: boolean
    frequency?: boolean
    rphPowerFactor?: boolean
    yphPowerFactor?: boolean
    bills?: boolean | meter_readings$billsArgs<ExtArgs>
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meter_readings"]>

  export type meter_readingsSelectScalar = {
    id?: boolean
    meterId?: boolean
    readingDate?: boolean
    readingType?: boolean
    readingSource?: boolean
    currentReading?: boolean
    previousReading?: boolean
    consumption?: boolean
    kWh?: boolean
    kVAh?: boolean
    kVARh?: boolean
    powerFactor?: boolean
    averagePF?: boolean
    minimumPF?: boolean
    voltageR?: boolean
    voltageY?: boolean
    voltageB?: boolean
    averageVoltage?: boolean
    currentR?: boolean
    currentY?: boolean
    currentB?: boolean
    averageCurrent?: boolean
    isValid?: boolean
    validatedBy?: boolean
    validatedAt?: boolean
    billId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kVA?: boolean
    kW?: boolean
    bphPowerFactor?: boolean
    frequency?: boolean
    rphPowerFactor?: boolean
    yphPowerFactor?: boolean
  }

  export type meter_readingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | meter_readings$billsArgs<ExtArgs>
    meters?: boolean | metersDefaultArgs<ExtArgs>
    prepaid_transactions?: boolean | meter_readings$prepaid_transactionsArgs<ExtArgs>
    _count?: boolean | Meter_readingsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type meter_readingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | meter_readings$billsArgs<ExtArgs>
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }

  export type $meter_readingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meter_readings"
    objects: {
      bills: Prisma.$billsPayload<ExtArgs> | null
      meters: Prisma.$metersPayload<ExtArgs>
      prepaid_transactions: Prisma.$prepaid_transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      meterId: number
      readingDate: Date
      readingType: $Enums.ReadingType
      readingSource: $Enums.ReadingSource
      currentReading: number
      previousReading: number
      consumption: number
      kWh: number
      kVAh: number | null
      kVARh: number | null
      powerFactor: number | null
      averagePF: number | null
      minimumPF: number | null
      voltageR: number | null
      voltageY: number | null
      voltageB: number | null
      averageVoltage: number | null
      currentR: number | null
      currentY: number | null
      currentB: number | null
      averageCurrent: number | null
      isValid: boolean
      validatedBy: string | null
      validatedAt: Date | null
      billId: number | null
      createdAt: Date
      updatedAt: Date
      kVA: number | null
      kW: number | null
      bphPowerFactor: number | null
      frequency: number | null
      rphPowerFactor: number | null
      yphPowerFactor: number | null
    }, ExtArgs["result"]["meter_readings"]>
    composites: {}
  }

  type meter_readingsGetPayload<S extends boolean | null | undefined | meter_readingsDefaultArgs> = $Result.GetResult<Prisma.$meter_readingsPayload, S>

  type meter_readingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<meter_readingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Meter_readingsCountAggregateInputType | true
    }

  export interface meter_readingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meter_readings'], meta: { name: 'meter_readings' } }
    /**
     * Find zero or one Meter_readings that matches the filter.
     * @param {meter_readingsFindUniqueArgs} args - Arguments to find a Meter_readings
     * @example
     * // Get one Meter_readings
     * const meter_readings = await prisma.meter_readings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends meter_readingsFindUniqueArgs>(args: SelectSubset<T, meter_readingsFindUniqueArgs<ExtArgs>>): Prisma__meter_readingsClient<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Meter_readings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {meter_readingsFindUniqueOrThrowArgs} args - Arguments to find a Meter_readings
     * @example
     * // Get one Meter_readings
     * const meter_readings = await prisma.meter_readings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends meter_readingsFindUniqueOrThrowArgs>(args: SelectSubset<T, meter_readingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__meter_readingsClient<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Meter_readings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_readingsFindFirstArgs} args - Arguments to find a Meter_readings
     * @example
     * // Get one Meter_readings
     * const meter_readings = await prisma.meter_readings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends meter_readingsFindFirstArgs>(args?: SelectSubset<T, meter_readingsFindFirstArgs<ExtArgs>>): Prisma__meter_readingsClient<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Meter_readings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_readingsFindFirstOrThrowArgs} args - Arguments to find a Meter_readings
     * @example
     * // Get one Meter_readings
     * const meter_readings = await prisma.meter_readings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends meter_readingsFindFirstOrThrowArgs>(args?: SelectSubset<T, meter_readingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__meter_readingsClient<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Meter_readings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_readingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meter_readings
     * const meter_readings = await prisma.meter_readings.findMany()
     * 
     * // Get first 10 Meter_readings
     * const meter_readings = await prisma.meter_readings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meter_readingsWithIdOnly = await prisma.meter_readings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends meter_readingsFindManyArgs>(args?: SelectSubset<T, meter_readingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Meter_readings.
     * @param {meter_readingsCreateArgs} args - Arguments to create a Meter_readings.
     * @example
     * // Create one Meter_readings
     * const Meter_readings = await prisma.meter_readings.create({
     *   data: {
     *     // ... data to create a Meter_readings
     *   }
     * })
     * 
     */
    create<T extends meter_readingsCreateArgs>(args: SelectSubset<T, meter_readingsCreateArgs<ExtArgs>>): Prisma__meter_readingsClient<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Meter_readings.
     * @param {meter_readingsCreateManyArgs} args - Arguments to create many Meter_readings.
     * @example
     * // Create many Meter_readings
     * const meter_readings = await prisma.meter_readings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends meter_readingsCreateManyArgs>(args?: SelectSubset<T, meter_readingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meter_readings and returns the data saved in the database.
     * @param {meter_readingsCreateManyAndReturnArgs} args - Arguments to create many Meter_readings.
     * @example
     * // Create many Meter_readings
     * const meter_readings = await prisma.meter_readings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meter_readings and only return the `id`
     * const meter_readingsWithIdOnly = await prisma.meter_readings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends meter_readingsCreateManyAndReturnArgs>(args?: SelectSubset<T, meter_readingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Meter_readings.
     * @param {meter_readingsDeleteArgs} args - Arguments to delete one Meter_readings.
     * @example
     * // Delete one Meter_readings
     * const Meter_readings = await prisma.meter_readings.delete({
     *   where: {
     *     // ... filter to delete one Meter_readings
     *   }
     * })
     * 
     */
    delete<T extends meter_readingsDeleteArgs>(args: SelectSubset<T, meter_readingsDeleteArgs<ExtArgs>>): Prisma__meter_readingsClient<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Meter_readings.
     * @param {meter_readingsUpdateArgs} args - Arguments to update one Meter_readings.
     * @example
     * // Update one Meter_readings
     * const meter_readings = await prisma.meter_readings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends meter_readingsUpdateArgs>(args: SelectSubset<T, meter_readingsUpdateArgs<ExtArgs>>): Prisma__meter_readingsClient<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Meter_readings.
     * @param {meter_readingsDeleteManyArgs} args - Arguments to filter Meter_readings to delete.
     * @example
     * // Delete a few Meter_readings
     * const { count } = await prisma.meter_readings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends meter_readingsDeleteManyArgs>(args?: SelectSubset<T, meter_readingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meter_readings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_readingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meter_readings
     * const meter_readings = await prisma.meter_readings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends meter_readingsUpdateManyArgs>(args: SelectSubset<T, meter_readingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meter_readings.
     * @param {meter_readingsUpsertArgs} args - Arguments to update or create a Meter_readings.
     * @example
     * // Update or create a Meter_readings
     * const meter_readings = await prisma.meter_readings.upsert({
     *   create: {
     *     // ... data to create a Meter_readings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meter_readings we want to update
     *   }
     * })
     */
    upsert<T extends meter_readingsUpsertArgs>(args: SelectSubset<T, meter_readingsUpsertArgs<ExtArgs>>): Prisma__meter_readingsClient<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Meter_readings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_readingsCountArgs} args - Arguments to filter Meter_readings to count.
     * @example
     * // Count the number of Meter_readings
     * const count = await prisma.meter_readings.count({
     *   where: {
     *     // ... the filter for the Meter_readings we want to count
     *   }
     * })
    **/
    count<T extends meter_readingsCountArgs>(
      args?: Subset<T, meter_readingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Meter_readingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meter_readings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Meter_readingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Meter_readingsAggregateArgs>(args: Subset<T, Meter_readingsAggregateArgs>): Prisma.PrismaPromise<GetMeter_readingsAggregateType<T>>

    /**
     * Group by Meter_readings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meter_readingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends meter_readingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: meter_readingsGroupByArgs['orderBy'] }
        : { orderBy?: meter_readingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, meter_readingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeter_readingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meter_readings model
   */
  readonly fields: meter_readingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meter_readings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__meter_readingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bills<T extends meter_readings$billsArgs<ExtArgs> = {}>(args?: Subset<T, meter_readings$billsArgs<ExtArgs>>): Prisma__billsClient<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    meters<T extends metersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, metersDefaultArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prepaid_transactions<T extends meter_readings$prepaid_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, meter_readings$prepaid_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meter_readings model
   */ 
  interface meter_readingsFieldRefs {
    readonly id: FieldRef<"meter_readings", 'Int'>
    readonly meterId: FieldRef<"meter_readings", 'Int'>
    readonly readingDate: FieldRef<"meter_readings", 'DateTime'>
    readonly readingType: FieldRef<"meter_readings", 'ReadingType'>
    readonly readingSource: FieldRef<"meter_readings", 'ReadingSource'>
    readonly currentReading: FieldRef<"meter_readings", 'Float'>
    readonly previousReading: FieldRef<"meter_readings", 'Float'>
    readonly consumption: FieldRef<"meter_readings", 'Float'>
    readonly kWh: FieldRef<"meter_readings", 'Float'>
    readonly kVAh: FieldRef<"meter_readings", 'Float'>
    readonly kVARh: FieldRef<"meter_readings", 'Float'>
    readonly powerFactor: FieldRef<"meter_readings", 'Float'>
    readonly averagePF: FieldRef<"meter_readings", 'Float'>
    readonly minimumPF: FieldRef<"meter_readings", 'Float'>
    readonly voltageR: FieldRef<"meter_readings", 'Float'>
    readonly voltageY: FieldRef<"meter_readings", 'Float'>
    readonly voltageB: FieldRef<"meter_readings", 'Float'>
    readonly averageVoltage: FieldRef<"meter_readings", 'Float'>
    readonly currentR: FieldRef<"meter_readings", 'Float'>
    readonly currentY: FieldRef<"meter_readings", 'Float'>
    readonly currentB: FieldRef<"meter_readings", 'Float'>
    readonly averageCurrent: FieldRef<"meter_readings", 'Float'>
    readonly isValid: FieldRef<"meter_readings", 'Boolean'>
    readonly validatedBy: FieldRef<"meter_readings", 'String'>
    readonly validatedAt: FieldRef<"meter_readings", 'DateTime'>
    readonly billId: FieldRef<"meter_readings", 'Int'>
    readonly createdAt: FieldRef<"meter_readings", 'DateTime'>
    readonly updatedAt: FieldRef<"meter_readings", 'DateTime'>
    readonly kVA: FieldRef<"meter_readings", 'Float'>
    readonly kW: FieldRef<"meter_readings", 'Float'>
    readonly bphPowerFactor: FieldRef<"meter_readings", 'Float'>
    readonly frequency: FieldRef<"meter_readings", 'Float'>
    readonly rphPowerFactor: FieldRef<"meter_readings", 'Float'>
    readonly yphPowerFactor: FieldRef<"meter_readings", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * meter_readings findUnique
   */
  export type meter_readingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    /**
     * Filter, which meter_readings to fetch.
     */
    where: meter_readingsWhereUniqueInput
  }

  /**
   * meter_readings findUniqueOrThrow
   */
  export type meter_readingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    /**
     * Filter, which meter_readings to fetch.
     */
    where: meter_readingsWhereUniqueInput
  }

  /**
   * meter_readings findFirst
   */
  export type meter_readingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    /**
     * Filter, which meter_readings to fetch.
     */
    where?: meter_readingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_readings to fetch.
     */
    orderBy?: meter_readingsOrderByWithRelationInput | meter_readingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_readings.
     */
    cursor?: meter_readingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_readings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_readings.
     */
    distinct?: Meter_readingsScalarFieldEnum | Meter_readingsScalarFieldEnum[]
  }

  /**
   * meter_readings findFirstOrThrow
   */
  export type meter_readingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    /**
     * Filter, which meter_readings to fetch.
     */
    where?: meter_readingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_readings to fetch.
     */
    orderBy?: meter_readingsOrderByWithRelationInput | meter_readingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meter_readings.
     */
    cursor?: meter_readingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_readings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meter_readings.
     */
    distinct?: Meter_readingsScalarFieldEnum | Meter_readingsScalarFieldEnum[]
  }

  /**
   * meter_readings findMany
   */
  export type meter_readingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    /**
     * Filter, which meter_readings to fetch.
     */
    where?: meter_readingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meter_readings to fetch.
     */
    orderBy?: meter_readingsOrderByWithRelationInput | meter_readingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meter_readings.
     */
    cursor?: meter_readingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meter_readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meter_readings.
     */
    skip?: number
    distinct?: Meter_readingsScalarFieldEnum | Meter_readingsScalarFieldEnum[]
  }

  /**
   * meter_readings create
   */
  export type meter_readingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    /**
     * The data needed to create a meter_readings.
     */
    data: XOR<meter_readingsCreateInput, meter_readingsUncheckedCreateInput>
  }

  /**
   * meter_readings createMany
   */
  export type meter_readingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meter_readings.
     */
    data: meter_readingsCreateManyInput | meter_readingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meter_readings createManyAndReturn
   */
  export type meter_readingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many meter_readings.
     */
    data: meter_readingsCreateManyInput | meter_readingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * meter_readings update
   */
  export type meter_readingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    /**
     * The data needed to update a meter_readings.
     */
    data: XOR<meter_readingsUpdateInput, meter_readingsUncheckedUpdateInput>
    /**
     * Choose, which meter_readings to update.
     */
    where: meter_readingsWhereUniqueInput
  }

  /**
   * meter_readings updateMany
   */
  export type meter_readingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meter_readings.
     */
    data: XOR<meter_readingsUpdateManyMutationInput, meter_readingsUncheckedUpdateManyInput>
    /**
     * Filter which meter_readings to update
     */
    where?: meter_readingsWhereInput
  }

  /**
   * meter_readings upsert
   */
  export type meter_readingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    /**
     * The filter to search for the meter_readings to update in case it exists.
     */
    where: meter_readingsWhereUniqueInput
    /**
     * In case the meter_readings found by the `where` argument doesn't exist, create a new meter_readings with this data.
     */
    create: XOR<meter_readingsCreateInput, meter_readingsUncheckedCreateInput>
    /**
     * In case the meter_readings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meter_readingsUpdateInput, meter_readingsUncheckedUpdateInput>
  }

  /**
   * meter_readings delete
   */
  export type meter_readingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    /**
     * Filter which meter_readings to delete.
     */
    where: meter_readingsWhereUniqueInput
  }

  /**
   * meter_readings deleteMany
   */
  export type meter_readingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meter_readings to delete
     */
    where?: meter_readingsWhereInput
  }

  /**
   * meter_readings.bills
   */
  export type meter_readings$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    where?: billsWhereInput
  }

  /**
   * meter_readings.prepaid_transactions
   */
  export type meter_readings$prepaid_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
    where?: prepaid_transactionsWhereInput
    orderBy?: prepaid_transactionsOrderByWithRelationInput | prepaid_transactionsOrderByWithRelationInput[]
    cursor?: prepaid_transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Prepaid_transactionsScalarFieldEnum | Prepaid_transactionsScalarFieldEnum[]
  }

  /**
   * meter_readings without action
   */
  export type meter_readingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
  }


  /**
   * Model meters
   */

  export type AggregateMeters = {
    _count: MetersCountAggregateOutputType | null
    _avg: MetersAvgAggregateOutputType | null
    _sum: MetersSumAggregateOutputType | null
    _min: MetersMinAggregateOutputType | null
    _max: MetersMaxAggregateOutputType | null
  }

  export type MetersAvgAggregateOutputType = {
    id: number | null
    phase: number | null
    locationId: number | null
    dtrId: number | null
  }

  export type MetersSumAggregateOutputType = {
    id: number | null
    phase: number | null
    locationId: number | null
    dtrId: number | null
  }

  export type MetersMinAggregateOutputType = {
    id: number | null
    meterNumber: string | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    type: $Enums.MeterType | null
    phase: number | null
    status: $Enums.MeterStatus | null
    isInUse: boolean | null
    installationDate: Date | null
    lastMaintenanceDate: Date | null
    decommissionDate: Date | null
    locationId: number | null
    dtrId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetersMaxAggregateOutputType = {
    id: number | null
    meterNumber: string | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    type: $Enums.MeterType | null
    phase: number | null
    status: $Enums.MeterStatus | null
    isInUse: boolean | null
    installationDate: Date | null
    lastMaintenanceDate: Date | null
    decommissionDate: Date | null
    locationId: number | null
    dtrId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetersCountAggregateOutputType = {
    id: number
    meterNumber: number
    serialNumber: number
    manufacturer: number
    model: number
    type: number
    phase: number
    status: number
    isInUse: number
    installationDate: number
    lastMaintenanceDate: number
    decommissionDate: number
    locationId: number
    dtrId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MetersAvgAggregateInputType = {
    id?: true
    phase?: true
    locationId?: true
    dtrId?: true
  }

  export type MetersSumAggregateInputType = {
    id?: true
    phase?: true
    locationId?: true
    dtrId?: true
  }

  export type MetersMinAggregateInputType = {
    id?: true
    meterNumber?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    type?: true
    phase?: true
    status?: true
    isInUse?: true
    installationDate?: true
    lastMaintenanceDate?: true
    decommissionDate?: true
    locationId?: true
    dtrId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetersMaxAggregateInputType = {
    id?: true
    meterNumber?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    type?: true
    phase?: true
    status?: true
    isInUse?: true
    installationDate?: true
    lastMaintenanceDate?: true
    decommissionDate?: true
    locationId?: true
    dtrId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetersCountAggregateInputType = {
    id?: true
    meterNumber?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    type?: true
    phase?: true
    status?: true
    isInUse?: true
    installationDate?: true
    lastMaintenanceDate?: true
    decommissionDate?: true
    locationId?: true
    dtrId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MetersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meters to aggregate.
     */
    where?: metersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meters to fetch.
     */
    orderBy?: metersOrderByWithRelationInput | metersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: metersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meters
    **/
    _count?: true | MetersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetersMaxAggregateInputType
  }

  export type GetMetersAggregateType<T extends MetersAggregateArgs> = {
        [P in keyof T & keyof AggregateMeters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeters[P]>
      : GetScalarType<T[P], AggregateMeters[P]>
  }




  export type metersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: metersWhereInput
    orderBy?: metersOrderByWithAggregationInput | metersOrderByWithAggregationInput[]
    by: MetersScalarFieldEnum[] | MetersScalarFieldEnum
    having?: metersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetersCountAggregateInputType | true
    _avg?: MetersAvgAggregateInputType
    _sum?: MetersSumAggregateInputType
    _min?: MetersMinAggregateInputType
    _max?: MetersMaxAggregateInputType
  }

  export type MetersGroupByOutputType = {
    id: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status: $Enums.MeterStatus
    isInUse: boolean
    installationDate: Date
    lastMaintenanceDate: Date | null
    decommissionDate: Date | null
    locationId: number
    dtrId: number | null
    createdAt: Date
    updatedAt: Date
    _count: MetersCountAggregateOutputType | null
    _avg: MetersAvgAggregateOutputType | null
    _sum: MetersSumAggregateOutputType | null
    _min: MetersMinAggregateOutputType | null
    _max: MetersMaxAggregateOutputType | null
  }

  type GetMetersGroupByPayload<T extends metersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetersGroupByOutputType[P]>
            : GetScalarType<T[P], MetersGroupByOutputType[P]>
        }
      >
    >


  export type metersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterNumber?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    type?: boolean
    phase?: boolean
    status?: boolean
    isInUse?: boolean
    installationDate?: boolean
    lastMaintenanceDate?: boolean
    decommissionDate?: boolean
    locationId?: boolean
    dtrId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bills?: boolean | meters$billsArgs<ExtArgs>
    current_transformers?: boolean | meters$current_transformersArgs<ExtArgs>
    meter_configurations?: boolean | meters$meter_configurationsArgs<ExtArgs>
    meter_readings?: boolean | meters$meter_readingsArgs<ExtArgs>
    dtrs?: boolean | meters$dtrsArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    potential_transformers?: boolean | meters$potential_transformersArgs<ExtArgs>
    tamper_events?: boolean | meters$tamper_eventsArgs<ExtArgs>
    _count?: boolean | MetersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meters"]>

  export type metersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterNumber?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    type?: boolean
    phase?: boolean
    status?: boolean
    isInUse?: boolean
    installationDate?: boolean
    lastMaintenanceDate?: boolean
    decommissionDate?: boolean
    locationId?: boolean
    dtrId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dtrs?: boolean | meters$dtrsArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meters"]>

  export type metersSelectScalar = {
    id?: boolean
    meterNumber?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    type?: boolean
    phase?: boolean
    status?: boolean
    isInUse?: boolean
    installationDate?: boolean
    lastMaintenanceDate?: boolean
    decommissionDate?: boolean
    locationId?: boolean
    dtrId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type metersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | meters$billsArgs<ExtArgs>
    current_transformers?: boolean | meters$current_transformersArgs<ExtArgs>
    meter_configurations?: boolean | meters$meter_configurationsArgs<ExtArgs>
    meter_readings?: boolean | meters$meter_readingsArgs<ExtArgs>
    dtrs?: boolean | meters$dtrsArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
    potential_transformers?: boolean | meters$potential_transformersArgs<ExtArgs>
    tamper_events?: boolean | meters$tamper_eventsArgs<ExtArgs>
    _count?: boolean | MetersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type metersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dtrs?: boolean | meters$dtrsArgs<ExtArgs>
    locations?: boolean | locationsDefaultArgs<ExtArgs>
  }

  export type $metersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meters"
    objects: {
      bills: Prisma.$billsPayload<ExtArgs>[]
      current_transformers: Prisma.$current_transformersPayload<ExtArgs>[]
      meter_configurations: Prisma.$meter_configurationsPayload<ExtArgs> | null
      meter_readings: Prisma.$meter_readingsPayload<ExtArgs>[]
      dtrs: Prisma.$dtrsPayload<ExtArgs> | null
      locations: Prisma.$locationsPayload<ExtArgs>
      potential_transformers: Prisma.$potential_transformersPayload<ExtArgs>[]
      tamper_events: Prisma.$tamper_eventsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      meterNumber: string
      serialNumber: string
      manufacturer: string
      model: string
      type: $Enums.MeterType
      phase: number
      status: $Enums.MeterStatus
      isInUse: boolean
      installationDate: Date
      lastMaintenanceDate: Date | null
      decommissionDate: Date | null
      locationId: number
      dtrId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meters"]>
    composites: {}
  }

  type metersGetPayload<S extends boolean | null | undefined | metersDefaultArgs> = $Result.GetResult<Prisma.$metersPayload, S>

  type metersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<metersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MetersCountAggregateInputType | true
    }

  export interface metersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meters'], meta: { name: 'meters' } }
    /**
     * Find zero or one Meters that matches the filter.
     * @param {metersFindUniqueArgs} args - Arguments to find a Meters
     * @example
     * // Get one Meters
     * const meters = await prisma.meters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends metersFindUniqueArgs>(args: SelectSubset<T, metersFindUniqueArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Meters that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {metersFindUniqueOrThrowArgs} args - Arguments to find a Meters
     * @example
     * // Get one Meters
     * const meters = await prisma.meters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends metersFindUniqueOrThrowArgs>(args: SelectSubset<T, metersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Meters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersFindFirstArgs} args - Arguments to find a Meters
     * @example
     * // Get one Meters
     * const meters = await prisma.meters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends metersFindFirstArgs>(args?: SelectSubset<T, metersFindFirstArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Meters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersFindFirstOrThrowArgs} args - Arguments to find a Meters
     * @example
     * // Get one Meters
     * const meters = await prisma.meters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends metersFindFirstOrThrowArgs>(args?: SelectSubset<T, metersFindFirstOrThrowArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Meters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meters
     * const meters = await prisma.meters.findMany()
     * 
     * // Get first 10 Meters
     * const meters = await prisma.meters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metersWithIdOnly = await prisma.meters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends metersFindManyArgs>(args?: SelectSubset<T, metersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Meters.
     * @param {metersCreateArgs} args - Arguments to create a Meters.
     * @example
     * // Create one Meters
     * const Meters = await prisma.meters.create({
     *   data: {
     *     // ... data to create a Meters
     *   }
     * })
     * 
     */
    create<T extends metersCreateArgs>(args: SelectSubset<T, metersCreateArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Meters.
     * @param {metersCreateManyArgs} args - Arguments to create many Meters.
     * @example
     * // Create many Meters
     * const meters = await prisma.meters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends metersCreateManyArgs>(args?: SelectSubset<T, metersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meters and returns the data saved in the database.
     * @param {metersCreateManyAndReturnArgs} args - Arguments to create many Meters.
     * @example
     * // Create many Meters
     * const meters = await prisma.meters.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meters and only return the `id`
     * const metersWithIdOnly = await prisma.meters.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends metersCreateManyAndReturnArgs>(args?: SelectSubset<T, metersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Meters.
     * @param {metersDeleteArgs} args - Arguments to delete one Meters.
     * @example
     * // Delete one Meters
     * const Meters = await prisma.meters.delete({
     *   where: {
     *     // ... filter to delete one Meters
     *   }
     * })
     * 
     */
    delete<T extends metersDeleteArgs>(args: SelectSubset<T, metersDeleteArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Meters.
     * @param {metersUpdateArgs} args - Arguments to update one Meters.
     * @example
     * // Update one Meters
     * const meters = await prisma.meters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends metersUpdateArgs>(args: SelectSubset<T, metersUpdateArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Meters.
     * @param {metersDeleteManyArgs} args - Arguments to filter Meters to delete.
     * @example
     * // Delete a few Meters
     * const { count } = await prisma.meters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends metersDeleteManyArgs>(args?: SelectSubset<T, metersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meters
     * const meters = await prisma.meters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends metersUpdateManyArgs>(args: SelectSubset<T, metersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meters.
     * @param {metersUpsertArgs} args - Arguments to update or create a Meters.
     * @example
     * // Update or create a Meters
     * const meters = await prisma.meters.upsert({
     *   create: {
     *     // ... data to create a Meters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meters we want to update
     *   }
     * })
     */
    upsert<T extends metersUpsertArgs>(args: SelectSubset<T, metersUpsertArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Meters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersCountArgs} args - Arguments to filter Meters to count.
     * @example
     * // Count the number of Meters
     * const count = await prisma.meters.count({
     *   where: {
     *     // ... the filter for the Meters we want to count
     *   }
     * })
    **/
    count<T extends metersCountArgs>(
      args?: Subset<T, metersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetersAggregateArgs>(args: Subset<T, MetersAggregateArgs>): Prisma.PrismaPromise<GetMetersAggregateType<T>>

    /**
     * Group by Meters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends metersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: metersGroupByArgs['orderBy'] }
        : { orderBy?: metersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, metersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meters model
   */
  readonly fields: metersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__metersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bills<T extends meters$billsArgs<ExtArgs> = {}>(args?: Subset<T, meters$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "findMany"> | Null>
    current_transformers<T extends meters$current_transformersArgs<ExtArgs> = {}>(args?: Subset<T, meters$current_transformersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$current_transformersPayload<ExtArgs>, T, "findMany"> | Null>
    meter_configurations<T extends meters$meter_configurationsArgs<ExtArgs> = {}>(args?: Subset<T, meters$meter_configurationsArgs<ExtArgs>>): Prisma__meter_configurationsClient<$Result.GetResult<Prisma.$meter_configurationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    meter_readings<T extends meters$meter_readingsArgs<ExtArgs> = {}>(args?: Subset<T, meters$meter_readingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "findMany"> | Null>
    dtrs<T extends meters$dtrsArgs<ExtArgs> = {}>(args?: Subset<T, meters$dtrsArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    locations<T extends locationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, locationsDefaultArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    potential_transformers<T extends meters$potential_transformersArgs<ExtArgs> = {}>(args?: Subset<T, meters$potential_transformersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$potential_transformersPayload<ExtArgs>, T, "findMany"> | Null>
    tamper_events<T extends meters$tamper_eventsArgs<ExtArgs> = {}>(args?: Subset<T, meters$tamper_eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tamper_eventsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meters model
   */ 
  interface metersFieldRefs {
    readonly id: FieldRef<"meters", 'Int'>
    readonly meterNumber: FieldRef<"meters", 'String'>
    readonly serialNumber: FieldRef<"meters", 'String'>
    readonly manufacturer: FieldRef<"meters", 'String'>
    readonly model: FieldRef<"meters", 'String'>
    readonly type: FieldRef<"meters", 'MeterType'>
    readonly phase: FieldRef<"meters", 'Int'>
    readonly status: FieldRef<"meters", 'MeterStatus'>
    readonly isInUse: FieldRef<"meters", 'Boolean'>
    readonly installationDate: FieldRef<"meters", 'DateTime'>
    readonly lastMaintenanceDate: FieldRef<"meters", 'DateTime'>
    readonly decommissionDate: FieldRef<"meters", 'DateTime'>
    readonly locationId: FieldRef<"meters", 'Int'>
    readonly dtrId: FieldRef<"meters", 'Int'>
    readonly createdAt: FieldRef<"meters", 'DateTime'>
    readonly updatedAt: FieldRef<"meters", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * meters findUnique
   */
  export type metersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter, which meters to fetch.
     */
    where: metersWhereUniqueInput
  }

  /**
   * meters findUniqueOrThrow
   */
  export type metersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter, which meters to fetch.
     */
    where: metersWhereUniqueInput
  }

  /**
   * meters findFirst
   */
  export type metersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter, which meters to fetch.
     */
    where?: metersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meters to fetch.
     */
    orderBy?: metersOrderByWithRelationInput | metersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meters.
     */
    cursor?: metersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meters.
     */
    distinct?: MetersScalarFieldEnum | MetersScalarFieldEnum[]
  }

  /**
   * meters findFirstOrThrow
   */
  export type metersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter, which meters to fetch.
     */
    where?: metersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meters to fetch.
     */
    orderBy?: metersOrderByWithRelationInput | metersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meters.
     */
    cursor?: metersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meters.
     */
    distinct?: MetersScalarFieldEnum | MetersScalarFieldEnum[]
  }

  /**
   * meters findMany
   */
  export type metersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter, which meters to fetch.
     */
    where?: metersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meters to fetch.
     */
    orderBy?: metersOrderByWithRelationInput | metersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meters.
     */
    cursor?: metersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meters.
     */
    skip?: number
    distinct?: MetersScalarFieldEnum | MetersScalarFieldEnum[]
  }

  /**
   * meters create
   */
  export type metersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * The data needed to create a meters.
     */
    data: XOR<metersCreateInput, metersUncheckedCreateInput>
  }

  /**
   * meters createMany
   */
  export type metersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meters.
     */
    data: metersCreateManyInput | metersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meters createManyAndReturn
   */
  export type metersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many meters.
     */
    data: metersCreateManyInput | metersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * meters update
   */
  export type metersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * The data needed to update a meters.
     */
    data: XOR<metersUpdateInput, metersUncheckedUpdateInput>
    /**
     * Choose, which meters to update.
     */
    where: metersWhereUniqueInput
  }

  /**
   * meters updateMany
   */
  export type metersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meters.
     */
    data: XOR<metersUpdateManyMutationInput, metersUncheckedUpdateManyInput>
    /**
     * Filter which meters to update
     */
    where?: metersWhereInput
  }

  /**
   * meters upsert
   */
  export type metersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * The filter to search for the meters to update in case it exists.
     */
    where: metersWhereUniqueInput
    /**
     * In case the meters found by the `where` argument doesn't exist, create a new meters with this data.
     */
    create: XOR<metersCreateInput, metersUncheckedCreateInput>
    /**
     * In case the meters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<metersUpdateInput, metersUncheckedUpdateInput>
  }

  /**
   * meters delete
   */
  export type metersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
    /**
     * Filter which meters to delete.
     */
    where: metersWhereUniqueInput
  }

  /**
   * meters deleteMany
   */
  export type metersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meters to delete
     */
    where?: metersWhereInput
  }

  /**
   * meters.bills
   */
  export type meters$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills
     */
    select?: billsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billsInclude<ExtArgs> | null
    where?: billsWhereInput
    orderBy?: billsOrderByWithRelationInput | billsOrderByWithRelationInput[]
    cursor?: billsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * meters.current_transformers
   */
  export type meters$current_transformersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the current_transformers
     */
    select?: current_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: current_transformersInclude<ExtArgs> | null
    where?: current_transformersWhereInput
    orderBy?: current_transformersOrderByWithRelationInput | current_transformersOrderByWithRelationInput[]
    cursor?: current_transformersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Current_transformersScalarFieldEnum | Current_transformersScalarFieldEnum[]
  }

  /**
   * meters.meter_configurations
   */
  export type meters$meter_configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_configurations
     */
    select?: meter_configurationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_configurationsInclude<ExtArgs> | null
    where?: meter_configurationsWhereInput
  }

  /**
   * meters.meter_readings
   */
  export type meters$meter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    where?: meter_readingsWhereInput
    orderBy?: meter_readingsOrderByWithRelationInput | meter_readingsOrderByWithRelationInput[]
    cursor?: meter_readingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Meter_readingsScalarFieldEnum | Meter_readingsScalarFieldEnum[]
  }

  /**
   * meters.dtrs
   */
  export type meters$dtrsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    where?: dtrsWhereInput
  }

  /**
   * meters.potential_transformers
   */
  export type meters$potential_transformersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersInclude<ExtArgs> | null
    where?: potential_transformersWhereInput
    orderBy?: potential_transformersOrderByWithRelationInput | potential_transformersOrderByWithRelationInput[]
    cursor?: potential_transformersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Potential_transformersScalarFieldEnum | Potential_transformersScalarFieldEnum[]
  }

  /**
   * meters.tamper_events
   */
  export type meters$tamper_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsInclude<ExtArgs> | null
    where?: tamper_eventsWhereInput
    orderBy?: tamper_eventsOrderByWithRelationInput | tamper_eventsOrderByWithRelationInput[]
    cursor?: tamper_eventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tamper_eventsScalarFieldEnum | Tamper_eventsScalarFieldEnum[]
  }

  /**
   * meters without action
   */
  export type metersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meters
     */
    select?: metersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metersInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    consumerId: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: number | null
    consumerId: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: number | null
    consumerId: number | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    priority: $Enums.NotificationPriority | null
    status: $Enums.NotificationStatus | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: number | null
    consumerId: number | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    priority: $Enums.NotificationPriority | null
    status: $Enums.NotificationStatus | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    consumerId: number
    type: number
    title: number
    message: number
    priority: number
    channels: number
    status: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    consumerId?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    consumerId?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    consumerId?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    status?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    consumerId?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    status?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    consumerId?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    channels?: true
    status?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: number
    consumerId: number
    type: $Enums.NotificationType
    title: string
    message: string
    priority: $Enums.NotificationPriority
    channels: $Enums.NotificationChannel[]
    status: $Enums.NotificationStatus
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consumerId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    priority?: boolean
    channels?: boolean
    status?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consumerId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    priority?: boolean
    channels?: boolean
    status?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    consumerId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    priority?: boolean
    channels?: boolean
    status?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      consumers: Prisma.$consumersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      consumerId: number
      type: $Enums.NotificationType
      title: string
      message: string
      priority: $Enums.NotificationPriority
      channels: $Enums.NotificationChannel[]
      status: $Enums.NotificationStatus
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consumers<T extends consumersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, consumersDefaultArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */ 
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'Int'>
    readonly consumerId: FieldRef<"notifications", 'Int'>
    readonly type: FieldRef<"notifications", 'NotificationType'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly message: FieldRef<"notifications", 'String'>
    readonly priority: FieldRef<"notifications", 'NotificationPriority'>
    readonly channels: FieldRef<"notifications", 'NotificationChannel[]'>
    readonly status: FieldRef<"notifications", 'NotificationStatus'>
    readonly readAt: FieldRef<"notifications", 'DateTime'>
    readonly createdAt: FieldRef<"notifications", 'DateTime'>
    readonly updatedAt: FieldRef<"notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    billId: number | null
    amount: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: number | null
    billId: number | null
    amount: number | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: number | null
    transactionId: string | null
    billId: number | null
    amount: number | null
    paymentMode: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    receiptNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: number | null
    transactionId: string | null
    billId: number | null
    amount: number | null
    paymentMode: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    receiptNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    transactionId: number
    billId: number
    amount: number
    paymentMode: number
    paymentStatus: number
    gatewayResponse: number
    receiptNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    billId?: true
    amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    billId?: true
    amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    transactionId?: true
    billId?: true
    amount?: true
    paymentMode?: true
    paymentStatus?: true
    receiptNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    transactionId?: true
    billId?: true
    amount?: true
    paymentMode?: true
    paymentStatus?: true
    receiptNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    transactionId?: true
    billId?: true
    amount?: true
    paymentMode?: true
    paymentStatus?: true
    gatewayResponse?: true
    receiptNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: number
    transactionId: string
    billId: number
    amount: number
    paymentMode: $Enums.PaymentMethod
    paymentStatus: $Enums.PaymentStatus
    gatewayResponse: JsonValue | null
    receiptNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    billId?: boolean
    amount?: boolean
    paymentMode?: boolean
    paymentStatus?: boolean
    gatewayResponse?: boolean
    receiptNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bills?: boolean | billsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    billId?: boolean
    amount?: boolean
    paymentMode?: boolean
    paymentStatus?: boolean
    gatewayResponse?: boolean
    receiptNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bills?: boolean | billsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    transactionId?: boolean
    billId?: boolean
    amount?: boolean
    paymentMode?: boolean
    paymentStatus?: boolean
    gatewayResponse?: boolean
    receiptNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | billsDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | billsDefaultArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      bills: Prisma.$billsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: string
      billId: number
      amount: number
      paymentMode: $Enums.PaymentMethod
      paymentStatus: $Enums.PaymentStatus
      gatewayResponse: Prisma.JsonValue | null
      receiptNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bills<T extends billsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, billsDefaultArgs<ExtArgs>>): Prisma__billsClient<$Result.GetResult<Prisma.$billsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */ 
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'Int'>
    readonly transactionId: FieldRef<"payments", 'String'>
    readonly billId: FieldRef<"payments", 'Int'>
    readonly amount: FieldRef<"payments", 'Float'>
    readonly paymentMode: FieldRef<"payments", 'PaymentMethod'>
    readonly paymentStatus: FieldRef<"payments", 'PaymentStatus'>
    readonly gatewayResponse: FieldRef<"payments", 'Json'>
    readonly receiptNumber: FieldRef<"payments", 'String'>
    readonly createdAt: FieldRef<"payments", 'DateTime'>
    readonly updatedAt: FieldRef<"payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionsSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionsAvgAggregateInputType = {
    id?: true
  }

  export type PermissionsSumAggregateInputType = {
    id?: true
  }

  export type PermissionsMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to aggregate.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionsWhereInput
    orderBy?: permissionsOrderByWithAggregationInput | permissionsOrderByWithAggregationInput[]
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum
    having?: permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _avg?: PermissionsAvgAggregateInputType
    _sum?: PermissionsSumAggregateInputType
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }

  export type PermissionsGroupByOutputType = {
    id: number
    code: string
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user_permissions?: boolean | permissions$user_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type permissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permissions"]>

  export type permissionsSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_permissions?: boolean | permissions$user_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type permissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permissions"
    objects: {
      user_permissions: Prisma.$user_permissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permissions"]>
    composites: {}
  }

  type permissionsGetPayload<S extends boolean | null | undefined | permissionsDefaultArgs> = $Result.GetResult<Prisma.$permissionsPayload, S>

  type permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<permissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionsCountAggregateInputType | true
    }

  export interface permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permissions'], meta: { name: 'permissions' } }
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {permissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionsFindUniqueArgs>(args: SelectSubset<T, permissionsFindUniqueArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {permissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionsFindFirstArgs>(args?: SelectSubset<T, permissionsFindFirstArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends permissionsFindManyArgs>(args?: SelectSubset<T, permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permissions.
     * @param {permissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
     */
    create<T extends permissionsCreateArgs>(args: SelectSubset<T, permissionsCreateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {permissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissionsCreateManyArgs>(args?: SelectSubset<T, permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {permissionsCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionsWithIdOnly = await prisma.permissions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends permissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, permissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permissions.
     * @param {permissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
     */
    delete<T extends permissionsDeleteArgs>(args: SelectSubset<T, permissionsDeleteArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permissions.
     * @param {permissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissionsUpdateArgs>(args: SelectSubset<T, permissionsUpdateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {permissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissionsDeleteManyArgs>(args?: SelectSubset<T, permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissionsUpdateManyArgs>(args: SelectSubset<T, permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissions.
     * @param {permissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends permissionsUpsertArgs>(args: SelectSubset<T, permissionsUpsertArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionsCountArgs>(
      args?: Subset<T, permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionsGroupByArgs['orderBy'] }
        : { orderBy?: permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permissions model
   */
  readonly fields: permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_permissions<T extends permissions$user_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, permissions$user_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permissions model
   */ 
  interface permissionsFieldRefs {
    readonly id: FieldRef<"permissions", 'Int'>
    readonly code: FieldRef<"permissions", 'String'>
    readonly name: FieldRef<"permissions", 'String'>
    readonly description: FieldRef<"permissions", 'String'>
    readonly isActive: FieldRef<"permissions", 'Boolean'>
    readonly createdAt: FieldRef<"permissions", 'DateTime'>
    readonly updatedAt: FieldRef<"permissions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * permissions findUnique
   */
  export type permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findUniqueOrThrow
   */
  export type permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findFirst
   */
  export type permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findFirstOrThrow
   */
  export type permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findMany
   */
  export type permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions create
   */
  export type permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a permissions.
     */
    data: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
  }

  /**
   * permissions createMany
   */
  export type permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionsCreateManyInput | permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permissions createManyAndReturn
   */
  export type permissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many permissions.
     */
    data: permissionsCreateManyInput | permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permissions update
   */
  export type permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a permissions.
     */
    data: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
    /**
     * Choose, which permissions to update.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions updateMany
   */
  export type permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionsUpdateManyMutationInput, permissionsUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionsWhereInput
  }

  /**
   * permissions upsert
   */
  export type permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the permissions to update in case it exists.
     */
    where: permissionsWhereUniqueInput
    /**
     * In case the permissions found by the `where` argument doesn't exist, create a new permissions with this data.
     */
    create: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
    /**
     * In case the permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
  }

  /**
   * permissions delete
   */
  export type permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter which permissions to delete.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions deleteMany
   */
  export type permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionsWhereInput
  }

  /**
   * permissions.user_permissions
   */
  export type permissions$user_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    where?: user_permissionsWhereInput
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    cursor?: user_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_permissionsScalarFieldEnum | User_permissionsScalarFieldEnum[]
  }

  /**
   * permissions without action
   */
  export type permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
  }


  /**
   * Model potential_transformers
   */

  export type AggregatePotential_transformers = {
    _count: Potential_transformersCountAggregateOutputType | null
    _avg: Potential_transformersAvgAggregateOutputType | null
    _sum: Potential_transformersSumAggregateOutputType | null
    _min: Potential_transformersMinAggregateOutputType | null
    _max: Potential_transformersMaxAggregateOutputType | null
  }

  export type Potential_transformersAvgAggregateOutputType = {
    id: number | null
    meterId: number | null
    ratedPrimary: number | null
    ratedSecondary: number | null
    burden: number | null
  }

  export type Potential_transformersSumAggregateOutputType = {
    id: number | null
    meterId: number | null
    ratedPrimary: number | null
    ratedSecondary: number | null
    burden: number | null
  }

  export type Potential_transformersMinAggregateOutputType = {
    id: number | null
    meterId: number | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    ratedPrimary: number | null
    ratedSecondary: number | null
    accuracyClass: string | null
    burden: number | null
    installationDate: Date | null
    lastTestedDate: Date | null
    nextTestDue: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Potential_transformersMaxAggregateOutputType = {
    id: number | null
    meterId: number | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    ratedPrimary: number | null
    ratedSecondary: number | null
    accuracyClass: string | null
    burden: number | null
    installationDate: Date | null
    lastTestedDate: Date | null
    nextTestDue: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Potential_transformersCountAggregateOutputType = {
    id: number
    meterId: number
    serialNumber: number
    manufacturer: number
    model: number
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: number
    burden: number
    installationDate: number
    lastTestedDate: number
    nextTestDue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Potential_transformersAvgAggregateInputType = {
    id?: true
    meterId?: true
    ratedPrimary?: true
    ratedSecondary?: true
    burden?: true
  }

  export type Potential_transformersSumAggregateInputType = {
    id?: true
    meterId?: true
    ratedPrimary?: true
    ratedSecondary?: true
    burden?: true
  }

  export type Potential_transformersMinAggregateInputType = {
    id?: true
    meterId?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    ratedPrimary?: true
    ratedSecondary?: true
    accuracyClass?: true
    burden?: true
    installationDate?: true
    lastTestedDate?: true
    nextTestDue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Potential_transformersMaxAggregateInputType = {
    id?: true
    meterId?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    ratedPrimary?: true
    ratedSecondary?: true
    accuracyClass?: true
    burden?: true
    installationDate?: true
    lastTestedDate?: true
    nextTestDue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Potential_transformersCountAggregateInputType = {
    id?: true
    meterId?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    ratedPrimary?: true
    ratedSecondary?: true
    accuracyClass?: true
    burden?: true
    installationDate?: true
    lastTestedDate?: true
    nextTestDue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Potential_transformersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which potential_transformers to aggregate.
     */
    where?: potential_transformersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of potential_transformers to fetch.
     */
    orderBy?: potential_transformersOrderByWithRelationInput | potential_transformersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: potential_transformersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` potential_transformers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` potential_transformers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned potential_transformers
    **/
    _count?: true | Potential_transformersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Potential_transformersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Potential_transformersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Potential_transformersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Potential_transformersMaxAggregateInputType
  }

  export type GetPotential_transformersAggregateType<T extends Potential_transformersAggregateArgs> = {
        [P in keyof T & keyof AggregatePotential_transformers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePotential_transformers[P]>
      : GetScalarType<T[P], AggregatePotential_transformers[P]>
  }




  export type potential_transformersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: potential_transformersWhereInput
    orderBy?: potential_transformersOrderByWithAggregationInput | potential_transformersOrderByWithAggregationInput[]
    by: Potential_transformersScalarFieldEnum[] | Potential_transformersScalarFieldEnum
    having?: potential_transformersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Potential_transformersCountAggregateInputType | true
    _avg?: Potential_transformersAvgAggregateInputType
    _sum?: Potential_transformersSumAggregateInputType
    _min?: Potential_transformersMinAggregateInputType
    _max?: Potential_transformersMaxAggregateInputType
  }

  export type Potential_transformersGroupByOutputType = {
    id: number
    meterId: number
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date
    lastTestedDate: Date | null
    nextTestDue: Date | null
    createdAt: Date
    updatedAt: Date
    _count: Potential_transformersCountAggregateOutputType | null
    _avg: Potential_transformersAvgAggregateOutputType | null
    _sum: Potential_transformersSumAggregateOutputType | null
    _min: Potential_transformersMinAggregateOutputType | null
    _max: Potential_transformersMaxAggregateOutputType | null
  }

  type GetPotential_transformersGroupByPayload<T extends potential_transformersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Potential_transformersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Potential_transformersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Potential_transformersGroupByOutputType[P]>
            : GetScalarType<T[P], Potential_transformersGroupByOutputType[P]>
        }
      >
    >


  export type potential_transformersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterId?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    ratedPrimary?: boolean
    ratedSecondary?: boolean
    accuracyClass?: boolean
    burden?: boolean
    installationDate?: boolean
    lastTestedDate?: boolean
    nextTestDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["potential_transformers"]>

  export type potential_transformersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterId?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    ratedPrimary?: boolean
    ratedSecondary?: boolean
    accuracyClass?: boolean
    burden?: boolean
    installationDate?: boolean
    lastTestedDate?: boolean
    nextTestDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["potential_transformers"]>

  export type potential_transformersSelectScalar = {
    id?: boolean
    meterId?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    ratedPrimary?: boolean
    ratedSecondary?: boolean
    accuracyClass?: boolean
    burden?: boolean
    installationDate?: boolean
    lastTestedDate?: boolean
    nextTestDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type potential_transformersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }
  export type potential_transformersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }

  export type $potential_transformersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "potential_transformers"
    objects: {
      meters: Prisma.$metersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      meterId: number
      serialNumber: string
      manufacturer: string
      model: string
      ratedPrimary: number
      ratedSecondary: number
      accuracyClass: string
      burden: number
      installationDate: Date
      lastTestedDate: Date | null
      nextTestDue: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["potential_transformers"]>
    composites: {}
  }

  type potential_transformersGetPayload<S extends boolean | null | undefined | potential_transformersDefaultArgs> = $Result.GetResult<Prisma.$potential_transformersPayload, S>

  type potential_transformersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<potential_transformersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Potential_transformersCountAggregateInputType | true
    }

  export interface potential_transformersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['potential_transformers'], meta: { name: 'potential_transformers' } }
    /**
     * Find zero or one Potential_transformers that matches the filter.
     * @param {potential_transformersFindUniqueArgs} args - Arguments to find a Potential_transformers
     * @example
     * // Get one Potential_transformers
     * const potential_transformers = await prisma.potential_transformers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends potential_transformersFindUniqueArgs>(args: SelectSubset<T, potential_transformersFindUniqueArgs<ExtArgs>>): Prisma__potential_transformersClient<$Result.GetResult<Prisma.$potential_transformersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Potential_transformers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {potential_transformersFindUniqueOrThrowArgs} args - Arguments to find a Potential_transformers
     * @example
     * // Get one Potential_transformers
     * const potential_transformers = await prisma.potential_transformers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends potential_transformersFindUniqueOrThrowArgs>(args: SelectSubset<T, potential_transformersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__potential_transformersClient<$Result.GetResult<Prisma.$potential_transformersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Potential_transformers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {potential_transformersFindFirstArgs} args - Arguments to find a Potential_transformers
     * @example
     * // Get one Potential_transformers
     * const potential_transformers = await prisma.potential_transformers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends potential_transformersFindFirstArgs>(args?: SelectSubset<T, potential_transformersFindFirstArgs<ExtArgs>>): Prisma__potential_transformersClient<$Result.GetResult<Prisma.$potential_transformersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Potential_transformers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {potential_transformersFindFirstOrThrowArgs} args - Arguments to find a Potential_transformers
     * @example
     * // Get one Potential_transformers
     * const potential_transformers = await prisma.potential_transformers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends potential_transformersFindFirstOrThrowArgs>(args?: SelectSubset<T, potential_transformersFindFirstOrThrowArgs<ExtArgs>>): Prisma__potential_transformersClient<$Result.GetResult<Prisma.$potential_transformersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Potential_transformers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {potential_transformersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Potential_transformers
     * const potential_transformers = await prisma.potential_transformers.findMany()
     * 
     * // Get first 10 Potential_transformers
     * const potential_transformers = await prisma.potential_transformers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const potential_transformersWithIdOnly = await prisma.potential_transformers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends potential_transformersFindManyArgs>(args?: SelectSubset<T, potential_transformersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$potential_transformersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Potential_transformers.
     * @param {potential_transformersCreateArgs} args - Arguments to create a Potential_transformers.
     * @example
     * // Create one Potential_transformers
     * const Potential_transformers = await prisma.potential_transformers.create({
     *   data: {
     *     // ... data to create a Potential_transformers
     *   }
     * })
     * 
     */
    create<T extends potential_transformersCreateArgs>(args: SelectSubset<T, potential_transformersCreateArgs<ExtArgs>>): Prisma__potential_transformersClient<$Result.GetResult<Prisma.$potential_transformersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Potential_transformers.
     * @param {potential_transformersCreateManyArgs} args - Arguments to create many Potential_transformers.
     * @example
     * // Create many Potential_transformers
     * const potential_transformers = await prisma.potential_transformers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends potential_transformersCreateManyArgs>(args?: SelectSubset<T, potential_transformersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Potential_transformers and returns the data saved in the database.
     * @param {potential_transformersCreateManyAndReturnArgs} args - Arguments to create many Potential_transformers.
     * @example
     * // Create many Potential_transformers
     * const potential_transformers = await prisma.potential_transformers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Potential_transformers and only return the `id`
     * const potential_transformersWithIdOnly = await prisma.potential_transformers.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends potential_transformersCreateManyAndReturnArgs>(args?: SelectSubset<T, potential_transformersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$potential_transformersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Potential_transformers.
     * @param {potential_transformersDeleteArgs} args - Arguments to delete one Potential_transformers.
     * @example
     * // Delete one Potential_transformers
     * const Potential_transformers = await prisma.potential_transformers.delete({
     *   where: {
     *     // ... filter to delete one Potential_transformers
     *   }
     * })
     * 
     */
    delete<T extends potential_transformersDeleteArgs>(args: SelectSubset<T, potential_transformersDeleteArgs<ExtArgs>>): Prisma__potential_transformersClient<$Result.GetResult<Prisma.$potential_transformersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Potential_transformers.
     * @param {potential_transformersUpdateArgs} args - Arguments to update one Potential_transformers.
     * @example
     * // Update one Potential_transformers
     * const potential_transformers = await prisma.potential_transformers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends potential_transformersUpdateArgs>(args: SelectSubset<T, potential_transformersUpdateArgs<ExtArgs>>): Prisma__potential_transformersClient<$Result.GetResult<Prisma.$potential_transformersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Potential_transformers.
     * @param {potential_transformersDeleteManyArgs} args - Arguments to filter Potential_transformers to delete.
     * @example
     * // Delete a few Potential_transformers
     * const { count } = await prisma.potential_transformers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends potential_transformersDeleteManyArgs>(args?: SelectSubset<T, potential_transformersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Potential_transformers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {potential_transformersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Potential_transformers
     * const potential_transformers = await prisma.potential_transformers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends potential_transformersUpdateManyArgs>(args: SelectSubset<T, potential_transformersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Potential_transformers.
     * @param {potential_transformersUpsertArgs} args - Arguments to update or create a Potential_transformers.
     * @example
     * // Update or create a Potential_transformers
     * const potential_transformers = await prisma.potential_transformers.upsert({
     *   create: {
     *     // ... data to create a Potential_transformers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Potential_transformers we want to update
     *   }
     * })
     */
    upsert<T extends potential_transformersUpsertArgs>(args: SelectSubset<T, potential_transformersUpsertArgs<ExtArgs>>): Prisma__potential_transformersClient<$Result.GetResult<Prisma.$potential_transformersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Potential_transformers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {potential_transformersCountArgs} args - Arguments to filter Potential_transformers to count.
     * @example
     * // Count the number of Potential_transformers
     * const count = await prisma.potential_transformers.count({
     *   where: {
     *     // ... the filter for the Potential_transformers we want to count
     *   }
     * })
    **/
    count<T extends potential_transformersCountArgs>(
      args?: Subset<T, potential_transformersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Potential_transformersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Potential_transformers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Potential_transformersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Potential_transformersAggregateArgs>(args: Subset<T, Potential_transformersAggregateArgs>): Prisma.PrismaPromise<GetPotential_transformersAggregateType<T>>

    /**
     * Group by Potential_transformers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {potential_transformersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends potential_transformersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: potential_transformersGroupByArgs['orderBy'] }
        : { orderBy?: potential_transformersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, potential_transformersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPotential_transformersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the potential_transformers model
   */
  readonly fields: potential_transformersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for potential_transformers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__potential_transformersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meters<T extends metersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, metersDefaultArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the potential_transformers model
   */ 
  interface potential_transformersFieldRefs {
    readonly id: FieldRef<"potential_transformers", 'Int'>
    readonly meterId: FieldRef<"potential_transformers", 'Int'>
    readonly serialNumber: FieldRef<"potential_transformers", 'String'>
    readonly manufacturer: FieldRef<"potential_transformers", 'String'>
    readonly model: FieldRef<"potential_transformers", 'String'>
    readonly ratedPrimary: FieldRef<"potential_transformers", 'Float'>
    readonly ratedSecondary: FieldRef<"potential_transformers", 'Float'>
    readonly accuracyClass: FieldRef<"potential_transformers", 'String'>
    readonly burden: FieldRef<"potential_transformers", 'Float'>
    readonly installationDate: FieldRef<"potential_transformers", 'DateTime'>
    readonly lastTestedDate: FieldRef<"potential_transformers", 'DateTime'>
    readonly nextTestDue: FieldRef<"potential_transformers", 'DateTime'>
    readonly createdAt: FieldRef<"potential_transformers", 'DateTime'>
    readonly updatedAt: FieldRef<"potential_transformers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * potential_transformers findUnique
   */
  export type potential_transformersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersInclude<ExtArgs> | null
    /**
     * Filter, which potential_transformers to fetch.
     */
    where: potential_transformersWhereUniqueInput
  }

  /**
   * potential_transformers findUniqueOrThrow
   */
  export type potential_transformersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersInclude<ExtArgs> | null
    /**
     * Filter, which potential_transformers to fetch.
     */
    where: potential_transformersWhereUniqueInput
  }

  /**
   * potential_transformers findFirst
   */
  export type potential_transformersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersInclude<ExtArgs> | null
    /**
     * Filter, which potential_transformers to fetch.
     */
    where?: potential_transformersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of potential_transformers to fetch.
     */
    orderBy?: potential_transformersOrderByWithRelationInput | potential_transformersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for potential_transformers.
     */
    cursor?: potential_transformersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` potential_transformers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` potential_transformers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of potential_transformers.
     */
    distinct?: Potential_transformersScalarFieldEnum | Potential_transformersScalarFieldEnum[]
  }

  /**
   * potential_transformers findFirstOrThrow
   */
  export type potential_transformersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersInclude<ExtArgs> | null
    /**
     * Filter, which potential_transformers to fetch.
     */
    where?: potential_transformersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of potential_transformers to fetch.
     */
    orderBy?: potential_transformersOrderByWithRelationInput | potential_transformersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for potential_transformers.
     */
    cursor?: potential_transformersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` potential_transformers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` potential_transformers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of potential_transformers.
     */
    distinct?: Potential_transformersScalarFieldEnum | Potential_transformersScalarFieldEnum[]
  }

  /**
   * potential_transformers findMany
   */
  export type potential_transformersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersInclude<ExtArgs> | null
    /**
     * Filter, which potential_transformers to fetch.
     */
    where?: potential_transformersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of potential_transformers to fetch.
     */
    orderBy?: potential_transformersOrderByWithRelationInput | potential_transformersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing potential_transformers.
     */
    cursor?: potential_transformersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` potential_transformers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` potential_transformers.
     */
    skip?: number
    distinct?: Potential_transformersScalarFieldEnum | Potential_transformersScalarFieldEnum[]
  }

  /**
   * potential_transformers create
   */
  export type potential_transformersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersInclude<ExtArgs> | null
    /**
     * The data needed to create a potential_transformers.
     */
    data: XOR<potential_transformersCreateInput, potential_transformersUncheckedCreateInput>
  }

  /**
   * potential_transformers createMany
   */
  export type potential_transformersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many potential_transformers.
     */
    data: potential_transformersCreateManyInput | potential_transformersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * potential_transformers createManyAndReturn
   */
  export type potential_transformersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many potential_transformers.
     */
    data: potential_transformersCreateManyInput | potential_transformersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * potential_transformers update
   */
  export type potential_transformersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersInclude<ExtArgs> | null
    /**
     * The data needed to update a potential_transformers.
     */
    data: XOR<potential_transformersUpdateInput, potential_transformersUncheckedUpdateInput>
    /**
     * Choose, which potential_transformers to update.
     */
    where: potential_transformersWhereUniqueInput
  }

  /**
   * potential_transformers updateMany
   */
  export type potential_transformersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update potential_transformers.
     */
    data: XOR<potential_transformersUpdateManyMutationInput, potential_transformersUncheckedUpdateManyInput>
    /**
     * Filter which potential_transformers to update
     */
    where?: potential_transformersWhereInput
  }

  /**
   * potential_transformers upsert
   */
  export type potential_transformersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersInclude<ExtArgs> | null
    /**
     * The filter to search for the potential_transformers to update in case it exists.
     */
    where: potential_transformersWhereUniqueInput
    /**
     * In case the potential_transformers found by the `where` argument doesn't exist, create a new potential_transformers with this data.
     */
    create: XOR<potential_transformersCreateInput, potential_transformersUncheckedCreateInput>
    /**
     * In case the potential_transformers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<potential_transformersUpdateInput, potential_transformersUncheckedUpdateInput>
  }

  /**
   * potential_transformers delete
   */
  export type potential_transformersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersInclude<ExtArgs> | null
    /**
     * Filter which potential_transformers to delete.
     */
    where: potential_transformersWhereUniqueInput
  }

  /**
   * potential_transformers deleteMany
   */
  export type potential_transformersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which potential_transformers to delete
     */
    where?: potential_transformersWhereInput
  }

  /**
   * potential_transformers without action
   */
  export type potential_transformersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the potential_transformers
     */
    select?: potential_transformersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: potential_transformersInclude<ExtArgs> | null
  }


  /**
   * Model role_permissions
   */

  export type AggregateRole_permissions = {
    _count: Role_permissionsCountAggregateOutputType | null
    _avg: Role_permissionsAvgAggregateOutputType | null
    _sum: Role_permissionsSumAggregateOutputType | null
    _min: Role_permissionsMinAggregateOutputType | null
    _max: Role_permissionsMaxAggregateOutputType | null
  }

  export type Role_permissionsAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type Role_permissionsSumAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type Role_permissionsMinAggregateOutputType = {
    id: number | null
    roleId: number | null
    isGranted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Role_permissionsMaxAggregateOutputType = {
    id: number | null
    roleId: number | null
    isGranted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Role_permissionsCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    isGranted: number
    restrictions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Role_permissionsAvgAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type Role_permissionsSumAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type Role_permissionsMinAggregateInputType = {
    id?: true
    roleId?: true
    isGranted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Role_permissionsMaxAggregateInputType = {
    id?: true
    roleId?: true
    isGranted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Role_permissionsCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    isGranted?: true
    restrictions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Role_permissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_permissions to aggregate.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned role_permissions
    **/
    _count?: true | Role_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Role_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Role_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Role_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Role_permissionsMaxAggregateInputType
  }

  export type GetRole_permissionsAggregateType<T extends Role_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRole_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole_permissions[P]>
      : GetScalarType<T[P], AggregateRole_permissions[P]>
  }




  export type role_permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_permissionsWhereInput
    orderBy?: role_permissionsOrderByWithAggregationInput | role_permissionsOrderByWithAggregationInput[]
    by: Role_permissionsScalarFieldEnum[] | Role_permissionsScalarFieldEnum
    having?: role_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Role_permissionsCountAggregateInputType | true
    _avg?: Role_permissionsAvgAggregateInputType
    _sum?: Role_permissionsSumAggregateInputType
    _min?: Role_permissionsMinAggregateInputType
    _max?: Role_permissionsMaxAggregateInputType
  }

  export type Role_permissionsGroupByOutputType = {
    id: number
    roleId: number
    permissionId: JsonValue
    isGranted: boolean
    restrictions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: Role_permissionsCountAggregateOutputType | null
    _avg: Role_permissionsAvgAggregateOutputType | null
    _sum: Role_permissionsSumAggregateOutputType | null
    _min: Role_permissionsMinAggregateOutputType | null
    _max: Role_permissionsMaxAggregateOutputType | null
  }

  type GetRole_permissionsGroupByPayload<T extends role_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Role_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Role_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Role_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Role_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type role_permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    isGranted?: boolean
    restrictions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role_permissions"]>

  export type role_permissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    isGranted?: boolean
    restrictions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role_permissions"]>

  export type role_permissionsSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    isGranted?: boolean
    restrictions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type role_permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }
  export type role_permissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $role_permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role_permissions"
    objects: {
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleId: number
      permissionId: Prisma.JsonValue
      isGranted: boolean
      restrictions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role_permissions"]>
    composites: {}
  }

  type role_permissionsGetPayload<S extends boolean | null | undefined | role_permissionsDefaultArgs> = $Result.GetResult<Prisma.$role_permissionsPayload, S>

  type role_permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<role_permissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Role_permissionsCountAggregateInputType | true
    }

  export interface role_permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role_permissions'], meta: { name: 'role_permissions' } }
    /**
     * Find zero or one Role_permissions that matches the filter.
     * @param {role_permissionsFindUniqueArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends role_permissionsFindUniqueArgs>(args: SelectSubset<T, role_permissionsFindUniqueArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role_permissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {role_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends role_permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, role_permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsFindFirstArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends role_permissionsFindFirstArgs>(args?: SelectSubset<T, role_permissionsFindFirstArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsFindFirstOrThrowArgs} args - Arguments to find a Role_permissions
     * @example
     * // Get one Role_permissions
     * const role_permissions = await prisma.role_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends role_permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, role_permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Role_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Role_permissions
     * const role_permissions = await prisma.role_permissions.findMany()
     * 
     * // Get first 10 Role_permissions
     * const role_permissions = await prisma.role_permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const role_permissionsWithIdOnly = await prisma.role_permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends role_permissionsFindManyArgs>(args?: SelectSubset<T, role_permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role_permissions.
     * @param {role_permissionsCreateArgs} args - Arguments to create a Role_permissions.
     * @example
     * // Create one Role_permissions
     * const Role_permissions = await prisma.role_permissions.create({
     *   data: {
     *     // ... data to create a Role_permissions
     *   }
     * })
     * 
     */
    create<T extends role_permissionsCreateArgs>(args: SelectSubset<T, role_permissionsCreateArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Role_permissions.
     * @param {role_permissionsCreateManyArgs} args - Arguments to create many Role_permissions.
     * @example
     * // Create many Role_permissions
     * const role_permissions = await prisma.role_permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends role_permissionsCreateManyArgs>(args?: SelectSubset<T, role_permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Role_permissions and returns the data saved in the database.
     * @param {role_permissionsCreateManyAndReturnArgs} args - Arguments to create many Role_permissions.
     * @example
     * // Create many Role_permissions
     * const role_permissions = await prisma.role_permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Role_permissions and only return the `id`
     * const role_permissionsWithIdOnly = await prisma.role_permissions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends role_permissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, role_permissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role_permissions.
     * @param {role_permissionsDeleteArgs} args - Arguments to delete one Role_permissions.
     * @example
     * // Delete one Role_permissions
     * const Role_permissions = await prisma.role_permissions.delete({
     *   where: {
     *     // ... filter to delete one Role_permissions
     *   }
     * })
     * 
     */
    delete<T extends role_permissionsDeleteArgs>(args: SelectSubset<T, role_permissionsDeleteArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role_permissions.
     * @param {role_permissionsUpdateArgs} args - Arguments to update one Role_permissions.
     * @example
     * // Update one Role_permissions
     * const role_permissions = await prisma.role_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends role_permissionsUpdateArgs>(args: SelectSubset<T, role_permissionsUpdateArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Role_permissions.
     * @param {role_permissionsDeleteManyArgs} args - Arguments to filter Role_permissions to delete.
     * @example
     * // Delete a few Role_permissions
     * const { count } = await prisma.role_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends role_permissionsDeleteManyArgs>(args?: SelectSubset<T, role_permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Role_permissions
     * const role_permissions = await prisma.role_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends role_permissionsUpdateManyArgs>(args: SelectSubset<T, role_permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role_permissions.
     * @param {role_permissionsUpsertArgs} args - Arguments to update or create a Role_permissions.
     * @example
     * // Update or create a Role_permissions
     * const role_permissions = await prisma.role_permissions.upsert({
     *   create: {
     *     // ... data to create a Role_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role_permissions we want to update
     *   }
     * })
     */
    upsert<T extends role_permissionsUpsertArgs>(args: SelectSubset<T, role_permissionsUpsertArgs<ExtArgs>>): Prisma__role_permissionsClient<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsCountArgs} args - Arguments to filter Role_permissions to count.
     * @example
     * // Count the number of Role_permissions
     * const count = await prisma.role_permissions.count({
     *   where: {
     *     // ... the filter for the Role_permissions we want to count
     *   }
     * })
    **/
    count<T extends role_permissionsCountArgs>(
      args?: Subset<T, role_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Role_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Role_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Role_permissionsAggregateArgs>(args: Subset<T, Role_permissionsAggregateArgs>): Prisma.PrismaPromise<GetRole_permissionsAggregateType<T>>

    /**
     * Group by Role_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends role_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: role_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: role_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, role_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRole_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role_permissions model
   */
  readonly fields: role_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__role_permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role_permissions model
   */ 
  interface role_permissionsFieldRefs {
    readonly id: FieldRef<"role_permissions", 'Int'>
    readonly roleId: FieldRef<"role_permissions", 'Int'>
    readonly permissionId: FieldRef<"role_permissions", 'Json'>
    readonly isGranted: FieldRef<"role_permissions", 'Boolean'>
    readonly restrictions: FieldRef<"role_permissions", 'Json'>
    readonly createdAt: FieldRef<"role_permissions", 'DateTime'>
    readonly updatedAt: FieldRef<"role_permissions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * role_permissions findUnique
   */
  export type role_permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions findUniqueOrThrow
   */
  export type role_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions findFirst
   */
  export type role_permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_permissions.
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_permissions.
     */
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * role_permissions findFirstOrThrow
   */
  export type role_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_permissions.
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_permissions.
     */
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * role_permissions findMany
   */
  export type role_permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_permissions to fetch.
     */
    where?: role_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_permissions to fetch.
     */
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing role_permissions.
     */
    cursor?: role_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_permissions.
     */
    skip?: number
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * role_permissions create
   */
  export type role_permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a role_permissions.
     */
    data: XOR<role_permissionsCreateInput, role_permissionsUncheckedCreateInput>
  }

  /**
   * role_permissions createMany
   */
  export type role_permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many role_permissions.
     */
    data: role_permissionsCreateManyInput | role_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role_permissions createManyAndReturn
   */
  export type role_permissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many role_permissions.
     */
    data: role_permissionsCreateManyInput | role_permissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * role_permissions update
   */
  export type role_permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a role_permissions.
     */
    data: XOR<role_permissionsUpdateInput, role_permissionsUncheckedUpdateInput>
    /**
     * Choose, which role_permissions to update.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions updateMany
   */
  export type role_permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update role_permissions.
     */
    data: XOR<role_permissionsUpdateManyMutationInput, role_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which role_permissions to update
     */
    where?: role_permissionsWhereInput
  }

  /**
   * role_permissions upsert
   */
  export type role_permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the role_permissions to update in case it exists.
     */
    where: role_permissionsWhereUniqueInput
    /**
     * In case the role_permissions found by the `where` argument doesn't exist, create a new role_permissions with this data.
     */
    create: XOR<role_permissionsCreateInput, role_permissionsUncheckedCreateInput>
    /**
     * In case the role_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<role_permissionsUpdateInput, role_permissionsUncheckedUpdateInput>
  }

  /**
   * role_permissions delete
   */
  export type role_permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    /**
     * Filter which role_permissions to delete.
     */
    where: role_permissionsWhereUniqueInput
  }

  /**
   * role_permissions deleteMany
   */
  export type role_permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_permissions to delete
     */
    where?: role_permissionsWhereInput
  }

  /**
   * role_permissions without action
   */
  export type role_permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
    level: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
    level: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    level: number | null
    isSystem: boolean | null
    isActive: boolean | null
    accessLevel: $Enums.AccessLevel | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    level: number | null
    isSystem: boolean | null
    isActive: boolean | null
    accessLevel: $Enums.AccessLevel | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    level: number
    isSystem: number
    isActive: number
    accessLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
    level?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
    level?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    level?: true
    isSystem?: true
    isActive?: true
    accessLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    level?: true
    isSystem?: true
    isActive?: true
    accessLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    level?: true
    isSystem?: true
    isActive?: true
    accessLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    level: number
    isSystem: boolean
    isActive: boolean
    accessLevel: $Enums.AccessLevel
    createdAt: Date
    updatedAt: Date
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    isSystem?: boolean
    isActive?: boolean
    accessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role_permissions?: boolean | roles$role_permissionsArgs<ExtArgs>
    users?: boolean | roles$usersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    isSystem?: boolean
    isActive?: boolean
    accessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    level?: boolean
    isSystem?: boolean
    isActive?: boolean
    accessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role_permissions?: boolean | roles$role_permissionsArgs<ExtArgs>
    users?: boolean | roles$usersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      role_permissions: Prisma.$role_permissionsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      level: number
      isSystem: boolean
      isActive: boolean
      accessLevel: $Enums.AccessLevel
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {rolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role_permissions<T extends roles$role_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, roles$role_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_permissionsPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends roles$usersArgs<ExtArgs> = {}>(args?: Subset<T, roles$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */ 
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'Int'>
    readonly name: FieldRef<"roles", 'String'>
    readonly description: FieldRef<"roles", 'String'>
    readonly level: FieldRef<"roles", 'Int'>
    readonly isSystem: FieldRef<"roles", 'Boolean'>
    readonly isActive: FieldRef<"roles", 'Boolean'>
    readonly accessLevel: FieldRef<"roles", 'AccessLevel'>
    readonly createdAt: FieldRef<"roles", 'DateTime'>
    readonly updatedAt: FieldRef<"roles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles createManyAndReturn
   */
  export type rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }

  /**
   * roles.role_permissions
   */
  export type roles$role_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_permissions
     */
    select?: role_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_permissionsInclude<ExtArgs> | null
    where?: role_permissionsWhereInput
    orderBy?: role_permissionsOrderByWithRelationInput | role_permissionsOrderByWithRelationInput[]
    cursor?: role_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Role_permissionsScalarFieldEnum | Role_permissionsScalarFieldEnum[]
  }

  /**
   * roles.users
   */
  export type roles$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model tickets
   */

  export type AggregateTickets = {
    _count: TicketsCountAggregateOutputType | null
    _avg: TicketsAvgAggregateOutputType | null
    _sum: TicketsSumAggregateOutputType | null
    _min: TicketsMinAggregateOutputType | null
    _max: TicketsMaxAggregateOutputType | null
  }

  export type TicketsAvgAggregateOutputType = {
    id: number | null
    dtrId: number | null
    raisedById: number | null
    assignedToId: number | null
  }

  export type TicketsSumAggregateOutputType = {
    id: number | null
    dtrId: number | null
    raisedById: number | null
    assignedToId: number | null
  }

  export type TicketsMinAggregateOutputType = {
    id: number | null
    ticketNumber: string | null
    dtrId: number | null
    raisedById: number | null
    assignedToId: number | null
    type: $Enums.TicketType | null
    category: $Enums.TicketCategory | null
    priority: $Enums.TicketPriority | null
    status: $Enums.TicketStatus | null
    subject: string | null
    description: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketsMaxAggregateOutputType = {
    id: number | null
    ticketNumber: string | null
    dtrId: number | null
    raisedById: number | null
    assignedToId: number | null
    type: $Enums.TicketType | null
    category: $Enums.TicketCategory | null
    priority: $Enums.TicketPriority | null
    status: $Enums.TicketStatus | null
    subject: string | null
    description: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketsCountAggregateOutputType = {
    id: number
    ticketNumber: number
    dtrId: number
    raisedById: number
    assignedToId: number
    type: number
    category: number
    priority: number
    status: number
    subject: number
    description: number
    resolution: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketsAvgAggregateInputType = {
    id?: true
    dtrId?: true
    raisedById?: true
    assignedToId?: true
  }

  export type TicketsSumAggregateInputType = {
    id?: true
    dtrId?: true
    raisedById?: true
    assignedToId?: true
  }

  export type TicketsMinAggregateInputType = {
    id?: true
    ticketNumber?: true
    dtrId?: true
    raisedById?: true
    assignedToId?: true
    type?: true
    category?: true
    priority?: true
    status?: true
    subject?: true
    description?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketsMaxAggregateInputType = {
    id?: true
    ticketNumber?: true
    dtrId?: true
    raisedById?: true
    assignedToId?: true
    type?: true
    category?: true
    priority?: true
    status?: true
    subject?: true
    description?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketsCountAggregateInputType = {
    id?: true
    ticketNumber?: true
    dtrId?: true
    raisedById?: true
    assignedToId?: true
    type?: true
    category?: true
    priority?: true
    status?: true
    subject?: true
    description?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tickets to aggregate.
     */
    where?: ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tickets
    **/
    _count?: true | TicketsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketsMaxAggregateInputType
  }

  export type GetTicketsAggregateType<T extends TicketsAggregateArgs> = {
        [P in keyof T & keyof AggregateTickets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTickets[P]>
      : GetScalarType<T[P], AggregateTickets[P]>
  }




  export type ticketsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ticketsWhereInput
    orderBy?: ticketsOrderByWithAggregationInput | ticketsOrderByWithAggregationInput[]
    by: TicketsScalarFieldEnum[] | TicketsScalarFieldEnum
    having?: ticketsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketsCountAggregateInputType | true
    _avg?: TicketsAvgAggregateInputType
    _sum?: TicketsSumAggregateInputType
    _min?: TicketsMinAggregateInputType
    _max?: TicketsMaxAggregateInputType
  }

  export type TicketsGroupByOutputType = {
    id: number
    ticketNumber: string
    dtrId: number | null
    raisedById: number
    assignedToId: number | null
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    subject: string
    description: string
    resolution: string | null
    createdAt: Date
    updatedAt: Date
    _count: TicketsCountAggregateOutputType | null
    _avg: TicketsAvgAggregateOutputType | null
    _sum: TicketsSumAggregateOutputType | null
    _min: TicketsMinAggregateOutputType | null
    _max: TicketsMaxAggregateOutputType | null
  }

  type GetTicketsGroupByPayload<T extends ticketsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketsGroupByOutputType[P]>
            : GetScalarType<T[P], TicketsGroupByOutputType[P]>
        }
      >
    >


  export type ticketsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    dtrId?: boolean
    raisedById?: boolean
    assignedToId?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    subject?: boolean
    description?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_tickets_assignedToIdTousers?: boolean | tickets$users_tickets_assignedToIdTousersArgs<ExtArgs>
    dtrs?: boolean | tickets$dtrsArgs<ExtArgs>
    users_tickets_raisedByIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tickets"]>

  export type ticketsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    dtrId?: boolean
    raisedById?: boolean
    assignedToId?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    subject?: boolean
    description?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_tickets_assignedToIdTousers?: boolean | tickets$users_tickets_assignedToIdTousersArgs<ExtArgs>
    dtrs?: boolean | tickets$dtrsArgs<ExtArgs>
    users_tickets_raisedByIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tickets"]>

  export type ticketsSelectScalar = {
    id?: boolean
    ticketNumber?: boolean
    dtrId?: boolean
    raisedById?: boolean
    assignedToId?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    subject?: boolean
    description?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ticketsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_tickets_assignedToIdTousers?: boolean | tickets$users_tickets_assignedToIdTousersArgs<ExtArgs>
    dtrs?: boolean | tickets$dtrsArgs<ExtArgs>
    users_tickets_raisedByIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type ticketsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_tickets_assignedToIdTousers?: boolean | tickets$users_tickets_assignedToIdTousersArgs<ExtArgs>
    dtrs?: boolean | tickets$dtrsArgs<ExtArgs>
    users_tickets_raisedByIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $ticketsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tickets"
    objects: {
      users_tickets_assignedToIdTousers: Prisma.$usersPayload<ExtArgs> | null
      dtrs: Prisma.$dtrsPayload<ExtArgs> | null
      users_tickets_raisedByIdTousers: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketNumber: string
      dtrId: number | null
      raisedById: number
      assignedToId: number | null
      type: $Enums.TicketType
      category: $Enums.TicketCategory
      priority: $Enums.TicketPriority
      status: $Enums.TicketStatus
      subject: string
      description: string
      resolution: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tickets"]>
    composites: {}
  }

  type ticketsGetPayload<S extends boolean | null | undefined | ticketsDefaultArgs> = $Result.GetResult<Prisma.$ticketsPayload, S>

  type ticketsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ticketsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketsCountAggregateInputType | true
    }

  export interface ticketsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tickets'], meta: { name: 'tickets' } }
    /**
     * Find zero or one Tickets that matches the filter.
     * @param {ticketsFindUniqueArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ticketsFindUniqueArgs>(args: SelectSubset<T, ticketsFindUniqueArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tickets that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ticketsFindUniqueOrThrowArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ticketsFindUniqueOrThrowArgs>(args: SelectSubset<T, ticketsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsFindFirstArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ticketsFindFirstArgs>(args?: SelectSubset<T, ticketsFindFirstArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tickets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsFindFirstOrThrowArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ticketsFindFirstOrThrowArgs>(args?: SelectSubset<T, ticketsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.tickets.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.tickets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketsWithIdOnly = await prisma.tickets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ticketsFindManyArgs>(args?: SelectSubset<T, ticketsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tickets.
     * @param {ticketsCreateArgs} args - Arguments to create a Tickets.
     * @example
     * // Create one Tickets
     * const Tickets = await prisma.tickets.create({
     *   data: {
     *     // ... data to create a Tickets
     *   }
     * })
     * 
     */
    create<T extends ticketsCreateArgs>(args: SelectSubset<T, ticketsCreateArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tickets.
     * @param {ticketsCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const tickets = await prisma.tickets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ticketsCreateManyArgs>(args?: SelectSubset<T, ticketsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {ticketsCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const tickets = await prisma.tickets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketsWithIdOnly = await prisma.tickets.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ticketsCreateManyAndReturnArgs>(args?: SelectSubset<T, ticketsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tickets.
     * @param {ticketsDeleteArgs} args - Arguments to delete one Tickets.
     * @example
     * // Delete one Tickets
     * const Tickets = await prisma.tickets.delete({
     *   where: {
     *     // ... filter to delete one Tickets
     *   }
     * })
     * 
     */
    delete<T extends ticketsDeleteArgs>(args: SelectSubset<T, ticketsDeleteArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tickets.
     * @param {ticketsUpdateArgs} args - Arguments to update one Tickets.
     * @example
     * // Update one Tickets
     * const tickets = await prisma.tickets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ticketsUpdateArgs>(args: SelectSubset<T, ticketsUpdateArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tickets.
     * @param {ticketsDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.tickets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ticketsDeleteManyArgs>(args?: SelectSubset<T, ticketsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const tickets = await prisma.tickets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ticketsUpdateManyArgs>(args: SelectSubset<T, ticketsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tickets.
     * @param {ticketsUpsertArgs} args - Arguments to update or create a Tickets.
     * @example
     * // Update or create a Tickets
     * const tickets = await prisma.tickets.upsert({
     *   create: {
     *     // ... data to create a Tickets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tickets we want to update
     *   }
     * })
     */
    upsert<T extends ticketsUpsertArgs>(args: SelectSubset<T, ticketsUpsertArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.tickets.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends ticketsCountArgs>(
      args?: Subset<T, ticketsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketsAggregateArgs>(args: Subset<T, TicketsAggregateArgs>): Prisma.PrismaPromise<GetTicketsAggregateType<T>>

    /**
     * Group by Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ticketsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ticketsGroupByArgs['orderBy'] }
        : { orderBy?: ticketsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ticketsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tickets model
   */
  readonly fields: ticketsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tickets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ticketsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_tickets_assignedToIdTousers<T extends tickets$users_tickets_assignedToIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, tickets$users_tickets_assignedToIdTousersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    dtrs<T extends tickets$dtrsArgs<ExtArgs> = {}>(args?: Subset<T, tickets$dtrsArgs<ExtArgs>>): Prisma__dtrsClient<$Result.GetResult<Prisma.$dtrsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    users_tickets_raisedByIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tickets model
   */ 
  interface ticketsFieldRefs {
    readonly id: FieldRef<"tickets", 'Int'>
    readonly ticketNumber: FieldRef<"tickets", 'String'>
    readonly dtrId: FieldRef<"tickets", 'Int'>
    readonly raisedById: FieldRef<"tickets", 'Int'>
    readonly assignedToId: FieldRef<"tickets", 'Int'>
    readonly type: FieldRef<"tickets", 'TicketType'>
    readonly category: FieldRef<"tickets", 'TicketCategory'>
    readonly priority: FieldRef<"tickets", 'TicketPriority'>
    readonly status: FieldRef<"tickets", 'TicketStatus'>
    readonly subject: FieldRef<"tickets", 'String'>
    readonly description: FieldRef<"tickets", 'String'>
    readonly resolution: FieldRef<"tickets", 'String'>
    readonly createdAt: FieldRef<"tickets", 'DateTime'>
    readonly updatedAt: FieldRef<"tickets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tickets findUnique
   */
  export type ticketsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter, which tickets to fetch.
     */
    where: ticketsWhereUniqueInput
  }

  /**
   * tickets findUniqueOrThrow
   */
  export type ticketsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter, which tickets to fetch.
     */
    where: ticketsWhereUniqueInput
  }

  /**
   * tickets findFirst
   */
  export type ticketsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter, which tickets to fetch.
     */
    where?: ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tickets.
     */
    cursor?: ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tickets.
     */
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * tickets findFirstOrThrow
   */
  export type ticketsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter, which tickets to fetch.
     */
    where?: ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tickets.
     */
    cursor?: ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tickets.
     */
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * tickets findMany
   */
  export type ticketsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter, which tickets to fetch.
     */
    where?: ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tickets.
     */
    cursor?: ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * tickets create
   */
  export type ticketsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * The data needed to create a tickets.
     */
    data: XOR<ticketsCreateInput, ticketsUncheckedCreateInput>
  }

  /**
   * tickets createMany
   */
  export type ticketsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tickets.
     */
    data: ticketsCreateManyInput | ticketsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tickets createManyAndReturn
   */
  export type ticketsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tickets.
     */
    data: ticketsCreateManyInput | ticketsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tickets update
   */
  export type ticketsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * The data needed to update a tickets.
     */
    data: XOR<ticketsUpdateInput, ticketsUncheckedUpdateInput>
    /**
     * Choose, which tickets to update.
     */
    where: ticketsWhereUniqueInput
  }

  /**
   * tickets updateMany
   */
  export type ticketsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tickets.
     */
    data: XOR<ticketsUpdateManyMutationInput, ticketsUncheckedUpdateManyInput>
    /**
     * Filter which tickets to update
     */
    where?: ticketsWhereInput
  }

  /**
   * tickets upsert
   */
  export type ticketsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * The filter to search for the tickets to update in case it exists.
     */
    where: ticketsWhereUniqueInput
    /**
     * In case the tickets found by the `where` argument doesn't exist, create a new tickets with this data.
     */
    create: XOR<ticketsCreateInput, ticketsUncheckedCreateInput>
    /**
     * In case the tickets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ticketsUpdateInput, ticketsUncheckedUpdateInput>
  }

  /**
   * tickets delete
   */
  export type ticketsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter which tickets to delete.
     */
    where: ticketsWhereUniqueInput
  }

  /**
   * tickets deleteMany
   */
  export type ticketsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tickets to delete
     */
    where?: ticketsWhereInput
  }

  /**
   * tickets.users_tickets_assignedToIdTousers
   */
  export type tickets$users_tickets_assignedToIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * tickets.dtrs
   */
  export type tickets$dtrsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dtrs
     */
    select?: dtrsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dtrsInclude<ExtArgs> | null
    where?: dtrsWhereInput
  }

  /**
   * tickets without action
   */
  export type ticketsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
  }


  /**
   * Model user_activity_logs
   */

  export type AggregateUser_activity_logs = {
    _count: User_activity_logsCountAggregateOutputType | null
    _avg: User_activity_logsAvgAggregateOutputType | null
    _sum: User_activity_logsSumAggregateOutputType | null
    _min: User_activity_logsMinAggregateOutputType | null
    _max: User_activity_logsMaxAggregateOutputType | null
  }

  export type User_activity_logsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type User_activity_logsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type User_activity_logsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type User_activity_logsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type User_activity_logsCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    details: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type User_activity_logsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type User_activity_logsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type User_activity_logsMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    createdAt?: true
  }

  export type User_activity_logsMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    createdAt?: true
  }

  export type User_activity_logsCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type User_activity_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_activity_logs to aggregate.
     */
    where?: user_activity_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_activity_logs to fetch.
     */
    orderBy?: user_activity_logsOrderByWithRelationInput | user_activity_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_activity_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_activity_logs
    **/
    _count?: true | User_activity_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_activity_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_activity_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_activity_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_activity_logsMaxAggregateInputType
  }

  export type GetUser_activity_logsAggregateType<T extends User_activity_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_activity_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_activity_logs[P]>
      : GetScalarType<T[P], AggregateUser_activity_logs[P]>
  }




  export type user_activity_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_activity_logsWhereInput
    orderBy?: user_activity_logsOrderByWithAggregationInput | user_activity_logsOrderByWithAggregationInput[]
    by: User_activity_logsScalarFieldEnum[] | User_activity_logsScalarFieldEnum
    having?: user_activity_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_activity_logsCountAggregateInputType | true
    _avg?: User_activity_logsAvgAggregateInputType
    _sum?: User_activity_logsSumAggregateInputType
    _min?: User_activity_logsMinAggregateInputType
    _max?: User_activity_logsMaxAggregateInputType
  }

  export type User_activity_logsGroupByOutputType = {
    id: number
    userId: number
    action: string
    details: JsonValue | null
    ipAddress: string | null
    createdAt: Date
    _count: User_activity_logsCountAggregateOutputType | null
    _avg: User_activity_logsAvgAggregateOutputType | null
    _sum: User_activity_logsSumAggregateOutputType | null
    _min: User_activity_logsMinAggregateOutputType | null
    _max: User_activity_logsMaxAggregateOutputType | null
  }

  type GetUser_activity_logsGroupByPayload<T extends user_activity_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_activity_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_activity_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_activity_logsGroupByOutputType[P]>
            : GetScalarType<T[P], User_activity_logsGroupByOutputType[P]>
        }
      >
    >


  export type user_activity_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_activity_logs"]>

  export type user_activity_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_activity_logs"]>

  export type user_activity_logsSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type user_activity_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_activity_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_activity_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_activity_logs"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      action: string
      details: Prisma.JsonValue | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["user_activity_logs"]>
    composites: {}
  }

  type user_activity_logsGetPayload<S extends boolean | null | undefined | user_activity_logsDefaultArgs> = $Result.GetResult<Prisma.$user_activity_logsPayload, S>

  type user_activity_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_activity_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_activity_logsCountAggregateInputType | true
    }

  export interface user_activity_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_activity_logs'], meta: { name: 'user_activity_logs' } }
    /**
     * Find zero or one User_activity_logs that matches the filter.
     * @param {user_activity_logsFindUniqueArgs} args - Arguments to find a User_activity_logs
     * @example
     * // Get one User_activity_logs
     * const user_activity_logs = await prisma.user_activity_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_activity_logsFindUniqueArgs>(args: SelectSubset<T, user_activity_logsFindUniqueArgs<ExtArgs>>): Prisma__user_activity_logsClient<$Result.GetResult<Prisma.$user_activity_logsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_activity_logs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_activity_logsFindUniqueOrThrowArgs} args - Arguments to find a User_activity_logs
     * @example
     * // Get one User_activity_logs
     * const user_activity_logs = await prisma.user_activity_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_activity_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_activity_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_activity_logsClient<$Result.GetResult<Prisma.$user_activity_logsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_activity_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activity_logsFindFirstArgs} args - Arguments to find a User_activity_logs
     * @example
     * // Get one User_activity_logs
     * const user_activity_logs = await prisma.user_activity_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_activity_logsFindFirstArgs>(args?: SelectSubset<T, user_activity_logsFindFirstArgs<ExtArgs>>): Prisma__user_activity_logsClient<$Result.GetResult<Prisma.$user_activity_logsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_activity_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activity_logsFindFirstOrThrowArgs} args - Arguments to find a User_activity_logs
     * @example
     * // Get one User_activity_logs
     * const user_activity_logs = await prisma.user_activity_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_activity_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_activity_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_activity_logsClient<$Result.GetResult<Prisma.$user_activity_logsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_activity_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activity_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_activity_logs
     * const user_activity_logs = await prisma.user_activity_logs.findMany()
     * 
     * // Get first 10 User_activity_logs
     * const user_activity_logs = await prisma.user_activity_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_activity_logsWithIdOnly = await prisma.user_activity_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_activity_logsFindManyArgs>(args?: SelectSubset<T, user_activity_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_activity_logsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_activity_logs.
     * @param {user_activity_logsCreateArgs} args - Arguments to create a User_activity_logs.
     * @example
     * // Create one User_activity_logs
     * const User_activity_logs = await prisma.user_activity_logs.create({
     *   data: {
     *     // ... data to create a User_activity_logs
     *   }
     * })
     * 
     */
    create<T extends user_activity_logsCreateArgs>(args: SelectSubset<T, user_activity_logsCreateArgs<ExtArgs>>): Prisma__user_activity_logsClient<$Result.GetResult<Prisma.$user_activity_logsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_activity_logs.
     * @param {user_activity_logsCreateManyArgs} args - Arguments to create many User_activity_logs.
     * @example
     * // Create many User_activity_logs
     * const user_activity_logs = await prisma.user_activity_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_activity_logsCreateManyArgs>(args?: SelectSubset<T, user_activity_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_activity_logs and returns the data saved in the database.
     * @param {user_activity_logsCreateManyAndReturnArgs} args - Arguments to create many User_activity_logs.
     * @example
     * // Create many User_activity_logs
     * const user_activity_logs = await prisma.user_activity_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_activity_logs and only return the `id`
     * const user_activity_logsWithIdOnly = await prisma.user_activity_logs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_activity_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_activity_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_activity_logsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_activity_logs.
     * @param {user_activity_logsDeleteArgs} args - Arguments to delete one User_activity_logs.
     * @example
     * // Delete one User_activity_logs
     * const User_activity_logs = await prisma.user_activity_logs.delete({
     *   where: {
     *     // ... filter to delete one User_activity_logs
     *   }
     * })
     * 
     */
    delete<T extends user_activity_logsDeleteArgs>(args: SelectSubset<T, user_activity_logsDeleteArgs<ExtArgs>>): Prisma__user_activity_logsClient<$Result.GetResult<Prisma.$user_activity_logsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_activity_logs.
     * @param {user_activity_logsUpdateArgs} args - Arguments to update one User_activity_logs.
     * @example
     * // Update one User_activity_logs
     * const user_activity_logs = await prisma.user_activity_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_activity_logsUpdateArgs>(args: SelectSubset<T, user_activity_logsUpdateArgs<ExtArgs>>): Prisma__user_activity_logsClient<$Result.GetResult<Prisma.$user_activity_logsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_activity_logs.
     * @param {user_activity_logsDeleteManyArgs} args - Arguments to filter User_activity_logs to delete.
     * @example
     * // Delete a few User_activity_logs
     * const { count } = await prisma.user_activity_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_activity_logsDeleteManyArgs>(args?: SelectSubset<T, user_activity_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activity_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_activity_logs
     * const user_activity_logs = await prisma.user_activity_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_activity_logsUpdateManyArgs>(args: SelectSubset<T, user_activity_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_activity_logs.
     * @param {user_activity_logsUpsertArgs} args - Arguments to update or create a User_activity_logs.
     * @example
     * // Update or create a User_activity_logs
     * const user_activity_logs = await prisma.user_activity_logs.upsert({
     *   create: {
     *     // ... data to create a User_activity_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_activity_logs we want to update
     *   }
     * })
     */
    upsert<T extends user_activity_logsUpsertArgs>(args: SelectSubset<T, user_activity_logsUpsertArgs<ExtArgs>>): Prisma__user_activity_logsClient<$Result.GetResult<Prisma.$user_activity_logsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activity_logsCountArgs} args - Arguments to filter User_activity_logs to count.
     * @example
     * // Count the number of User_activity_logs
     * const count = await prisma.user_activity_logs.count({
     *   where: {
     *     // ... the filter for the User_activity_logs we want to count
     *   }
     * })
    **/
    count<T extends user_activity_logsCountArgs>(
      args?: Subset<T, user_activity_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_activity_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_activity_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_activity_logsAggregateArgs>(args: Subset<T, User_activity_logsAggregateArgs>): Prisma.PrismaPromise<GetUser_activity_logsAggregateType<T>>

    /**
     * Group by User_activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activity_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_activity_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_activity_logsGroupByArgs['orderBy'] }
        : { orderBy?: user_activity_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_activity_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_activity_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_activity_logs model
   */
  readonly fields: user_activity_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_activity_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_activity_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_activity_logs model
   */ 
  interface user_activity_logsFieldRefs {
    readonly id: FieldRef<"user_activity_logs", 'Int'>
    readonly userId: FieldRef<"user_activity_logs", 'Int'>
    readonly action: FieldRef<"user_activity_logs", 'String'>
    readonly details: FieldRef<"user_activity_logs", 'Json'>
    readonly ipAddress: FieldRef<"user_activity_logs", 'String'>
    readonly createdAt: FieldRef<"user_activity_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_activity_logs findUnique
   */
  export type user_activity_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsInclude<ExtArgs> | null
    /**
     * Filter, which user_activity_logs to fetch.
     */
    where: user_activity_logsWhereUniqueInput
  }

  /**
   * user_activity_logs findUniqueOrThrow
   */
  export type user_activity_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsInclude<ExtArgs> | null
    /**
     * Filter, which user_activity_logs to fetch.
     */
    where: user_activity_logsWhereUniqueInput
  }

  /**
   * user_activity_logs findFirst
   */
  export type user_activity_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsInclude<ExtArgs> | null
    /**
     * Filter, which user_activity_logs to fetch.
     */
    where?: user_activity_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_activity_logs to fetch.
     */
    orderBy?: user_activity_logsOrderByWithRelationInput | user_activity_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_activity_logs.
     */
    cursor?: user_activity_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_activity_logs.
     */
    distinct?: User_activity_logsScalarFieldEnum | User_activity_logsScalarFieldEnum[]
  }

  /**
   * user_activity_logs findFirstOrThrow
   */
  export type user_activity_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsInclude<ExtArgs> | null
    /**
     * Filter, which user_activity_logs to fetch.
     */
    where?: user_activity_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_activity_logs to fetch.
     */
    orderBy?: user_activity_logsOrderByWithRelationInput | user_activity_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_activity_logs.
     */
    cursor?: user_activity_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_activity_logs.
     */
    distinct?: User_activity_logsScalarFieldEnum | User_activity_logsScalarFieldEnum[]
  }

  /**
   * user_activity_logs findMany
   */
  export type user_activity_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsInclude<ExtArgs> | null
    /**
     * Filter, which user_activity_logs to fetch.
     */
    where?: user_activity_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_activity_logs to fetch.
     */
    orderBy?: user_activity_logsOrderByWithRelationInput | user_activity_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_activity_logs.
     */
    cursor?: user_activity_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_activity_logs.
     */
    skip?: number
    distinct?: User_activity_logsScalarFieldEnum | User_activity_logsScalarFieldEnum[]
  }

  /**
   * user_activity_logs create
   */
  export type user_activity_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_activity_logs.
     */
    data: XOR<user_activity_logsCreateInput, user_activity_logsUncheckedCreateInput>
  }

  /**
   * user_activity_logs createMany
   */
  export type user_activity_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_activity_logs.
     */
    data: user_activity_logsCreateManyInput | user_activity_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_activity_logs createManyAndReturn
   */
  export type user_activity_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_activity_logs.
     */
    data: user_activity_logsCreateManyInput | user_activity_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_activity_logs update
   */
  export type user_activity_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_activity_logs.
     */
    data: XOR<user_activity_logsUpdateInput, user_activity_logsUncheckedUpdateInput>
    /**
     * Choose, which user_activity_logs to update.
     */
    where: user_activity_logsWhereUniqueInput
  }

  /**
   * user_activity_logs updateMany
   */
  export type user_activity_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_activity_logs.
     */
    data: XOR<user_activity_logsUpdateManyMutationInput, user_activity_logsUncheckedUpdateManyInput>
    /**
     * Filter which user_activity_logs to update
     */
    where?: user_activity_logsWhereInput
  }

  /**
   * user_activity_logs upsert
   */
  export type user_activity_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_activity_logs to update in case it exists.
     */
    where: user_activity_logsWhereUniqueInput
    /**
     * In case the user_activity_logs found by the `where` argument doesn't exist, create a new user_activity_logs with this data.
     */
    create: XOR<user_activity_logsCreateInput, user_activity_logsUncheckedCreateInput>
    /**
     * In case the user_activity_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_activity_logsUpdateInput, user_activity_logsUncheckedUpdateInput>
  }

  /**
   * user_activity_logs delete
   */
  export type user_activity_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsInclude<ExtArgs> | null
    /**
     * Filter which user_activity_logs to delete.
     */
    where: user_activity_logsWhereUniqueInput
  }

  /**
   * user_activity_logs deleteMany
   */
  export type user_activity_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_activity_logs to delete
     */
    where?: user_activity_logsWhereInput
  }

  /**
   * user_activity_logs without action
   */
  export type user_activity_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsInclude<ExtArgs> | null
  }


  /**
   * Model user_permissions
   */

  export type AggregateUser_permissions = {
    _count: User_permissionsCountAggregateOutputType | null
    _avg: User_permissionsAvgAggregateOutputType | null
    _sum: User_permissionsSumAggregateOutputType | null
    _min: User_permissionsMinAggregateOutputType | null
    _max: User_permissionsMaxAggregateOutputType | null
  }

  export type User_permissionsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    permissionId: number | null
  }

  export type User_permissionsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    permissionId: number | null
  }

  export type User_permissionsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    permissionId: number | null
    isGranted: boolean | null
    reason: string | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_permissionsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    permissionId: number | null
    isGranted: boolean | null
    reason: string | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_permissionsCountAggregateOutputType = {
    id: number
    userId: number
    permissionId: number
    isGranted: number
    reason: number
    validFrom: number
    validUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type User_permissionsAvgAggregateInputType = {
    id?: true
    userId?: true
    permissionId?: true
  }

  export type User_permissionsSumAggregateInputType = {
    id?: true
    userId?: true
    permissionId?: true
  }

  export type User_permissionsMinAggregateInputType = {
    id?: true
    userId?: true
    permissionId?: true
    isGranted?: true
    reason?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_permissionsMaxAggregateInputType = {
    id?: true
    userId?: true
    permissionId?: true
    isGranted?: true
    reason?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_permissionsCountAggregateInputType = {
    id?: true
    userId?: true
    permissionId?: true
    isGranted?: true
    reason?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type User_permissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_permissions to aggregate.
     */
    where?: user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_permissions to fetch.
     */
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_permissions
    **/
    _count?: true | User_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_permissionsMaxAggregateInputType
  }

  export type GetUser_permissionsAggregateType<T extends User_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_permissions[P]>
      : GetScalarType<T[P], AggregateUser_permissions[P]>
  }




  export type user_permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_permissionsWhereInput
    orderBy?: user_permissionsOrderByWithAggregationInput | user_permissionsOrderByWithAggregationInput[]
    by: User_permissionsScalarFieldEnum[] | User_permissionsScalarFieldEnum
    having?: user_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_permissionsCountAggregateInputType | true
    _avg?: User_permissionsAvgAggregateInputType
    _sum?: User_permissionsSumAggregateInputType
    _min?: User_permissionsMinAggregateInputType
    _max?: User_permissionsMaxAggregateInputType
  }

  export type User_permissionsGroupByOutputType = {
    id: number
    userId: number
    permissionId: number
    isGranted: boolean
    reason: string | null
    validFrom: Date
    validUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: User_permissionsCountAggregateOutputType | null
    _avg: User_permissionsAvgAggregateOutputType | null
    _sum: User_permissionsSumAggregateOutputType | null
    _min: User_permissionsMinAggregateOutputType | null
    _max: User_permissionsMaxAggregateOutputType | null
  }

  type GetUser_permissionsGroupByPayload<T extends user_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], User_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type user_permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissionId?: boolean
    isGranted?: boolean
    reason?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_permissions"]>

  export type user_permissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissionId?: boolean
    isGranted?: boolean
    reason?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_permissions"]>

  export type user_permissionsSelectScalar = {
    id?: boolean
    userId?: boolean
    permissionId?: boolean
    isGranted?: boolean
    reason?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type user_permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_permissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_permissions"
    objects: {
      permissions: Prisma.$permissionsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      permissionId: number
      isGranted: boolean
      reason: string | null
      validFrom: Date
      validUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user_permissions"]>
    composites: {}
  }

  type user_permissionsGetPayload<S extends boolean | null | undefined | user_permissionsDefaultArgs> = $Result.GetResult<Prisma.$user_permissionsPayload, S>

  type user_permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_permissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_permissionsCountAggregateInputType | true
    }

  export interface user_permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_permissions'], meta: { name: 'user_permissions' } }
    /**
     * Find zero or one User_permissions that matches the filter.
     * @param {user_permissionsFindUniqueArgs} args - Arguments to find a User_permissions
     * @example
     * // Get one User_permissions
     * const user_permissions = await prisma.user_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_permissionsFindUniqueArgs>(args: SelectSubset<T, user_permissionsFindUniqueArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_permissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_permissionsFindUniqueOrThrowArgs} args - Arguments to find a User_permissions
     * @example
     * // Get one User_permissions
     * const user_permissions = await prisma.user_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsFindFirstArgs} args - Arguments to find a User_permissions
     * @example
     * // Get one User_permissions
     * const user_permissions = await prisma.user_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_permissionsFindFirstArgs>(args?: SelectSubset<T, user_permissionsFindFirstArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsFindFirstOrThrowArgs} args - Arguments to find a User_permissions
     * @example
     * // Get one User_permissions
     * const user_permissions = await prisma.user_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_permissions
     * const user_permissions = await prisma.user_permissions.findMany()
     * 
     * // Get first 10 User_permissions
     * const user_permissions = await prisma.user_permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_permissionsWithIdOnly = await prisma.user_permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_permissionsFindManyArgs>(args?: SelectSubset<T, user_permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_permissions.
     * @param {user_permissionsCreateArgs} args - Arguments to create a User_permissions.
     * @example
     * // Create one User_permissions
     * const User_permissions = await prisma.user_permissions.create({
     *   data: {
     *     // ... data to create a User_permissions
     *   }
     * })
     * 
     */
    create<T extends user_permissionsCreateArgs>(args: SelectSubset<T, user_permissionsCreateArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_permissions.
     * @param {user_permissionsCreateManyArgs} args - Arguments to create many User_permissions.
     * @example
     * // Create many User_permissions
     * const user_permissions = await prisma.user_permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_permissionsCreateManyArgs>(args?: SelectSubset<T, user_permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_permissions and returns the data saved in the database.
     * @param {user_permissionsCreateManyAndReturnArgs} args - Arguments to create many User_permissions.
     * @example
     * // Create many User_permissions
     * const user_permissions = await prisma.user_permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_permissions and only return the `id`
     * const user_permissionsWithIdOnly = await prisma.user_permissions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_permissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_permissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_permissions.
     * @param {user_permissionsDeleteArgs} args - Arguments to delete one User_permissions.
     * @example
     * // Delete one User_permissions
     * const User_permissions = await prisma.user_permissions.delete({
     *   where: {
     *     // ... filter to delete one User_permissions
     *   }
     * })
     * 
     */
    delete<T extends user_permissionsDeleteArgs>(args: SelectSubset<T, user_permissionsDeleteArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_permissions.
     * @param {user_permissionsUpdateArgs} args - Arguments to update one User_permissions.
     * @example
     * // Update one User_permissions
     * const user_permissions = await prisma.user_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_permissionsUpdateArgs>(args: SelectSubset<T, user_permissionsUpdateArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_permissions.
     * @param {user_permissionsDeleteManyArgs} args - Arguments to filter User_permissions to delete.
     * @example
     * // Delete a few User_permissions
     * const { count } = await prisma.user_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_permissionsDeleteManyArgs>(args?: SelectSubset<T, user_permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_permissions
     * const user_permissions = await prisma.user_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_permissionsUpdateManyArgs>(args: SelectSubset<T, user_permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_permissions.
     * @param {user_permissionsUpsertArgs} args - Arguments to update or create a User_permissions.
     * @example
     * // Update or create a User_permissions
     * const user_permissions = await prisma.user_permissions.upsert({
     *   create: {
     *     // ... data to create a User_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_permissions we want to update
     *   }
     * })
     */
    upsert<T extends user_permissionsUpsertArgs>(args: SelectSubset<T, user_permissionsUpsertArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsCountArgs} args - Arguments to filter User_permissions to count.
     * @example
     * // Count the number of User_permissions
     * const count = await prisma.user_permissions.count({
     *   where: {
     *     // ... the filter for the User_permissions we want to count
     *   }
     * })
    **/
    count<T extends user_permissionsCountArgs>(
      args?: Subset<T, user_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_permissionsAggregateArgs>(args: Subset<T, User_permissionsAggregateArgs>): Prisma.PrismaPromise<GetUser_permissionsAggregateType<T>>

    /**
     * Group by User_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: user_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_permissions model
   */
  readonly fields: user_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends permissionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permissionsDefaultArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_permissions model
   */ 
  interface user_permissionsFieldRefs {
    readonly id: FieldRef<"user_permissions", 'Int'>
    readonly userId: FieldRef<"user_permissions", 'Int'>
    readonly permissionId: FieldRef<"user_permissions", 'Int'>
    readonly isGranted: FieldRef<"user_permissions", 'Boolean'>
    readonly reason: FieldRef<"user_permissions", 'String'>
    readonly validFrom: FieldRef<"user_permissions", 'DateTime'>
    readonly validUntil: FieldRef<"user_permissions", 'DateTime'>
    readonly createdAt: FieldRef<"user_permissions", 'DateTime'>
    readonly updatedAt: FieldRef<"user_permissions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_permissions findUnique
   */
  export type user_permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which user_permissions to fetch.
     */
    where: user_permissionsWhereUniqueInput
  }

  /**
   * user_permissions findUniqueOrThrow
   */
  export type user_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which user_permissions to fetch.
     */
    where: user_permissionsWhereUniqueInput
  }

  /**
   * user_permissions findFirst
   */
  export type user_permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which user_permissions to fetch.
     */
    where?: user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_permissions to fetch.
     */
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_permissions.
     */
    cursor?: user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_permissions.
     */
    distinct?: User_permissionsScalarFieldEnum | User_permissionsScalarFieldEnum[]
  }

  /**
   * user_permissions findFirstOrThrow
   */
  export type user_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which user_permissions to fetch.
     */
    where?: user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_permissions to fetch.
     */
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_permissions.
     */
    cursor?: user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_permissions.
     */
    distinct?: User_permissionsScalarFieldEnum | User_permissionsScalarFieldEnum[]
  }

  /**
   * user_permissions findMany
   */
  export type user_permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which user_permissions to fetch.
     */
    where?: user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_permissions to fetch.
     */
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_permissions.
     */
    cursor?: user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_permissions.
     */
    skip?: number
    distinct?: User_permissionsScalarFieldEnum | User_permissionsScalarFieldEnum[]
  }

  /**
   * user_permissions create
   */
  export type user_permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_permissions.
     */
    data: XOR<user_permissionsCreateInput, user_permissionsUncheckedCreateInput>
  }

  /**
   * user_permissions createMany
   */
  export type user_permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_permissions.
     */
    data: user_permissionsCreateManyInput | user_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_permissions createManyAndReturn
   */
  export type user_permissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_permissions.
     */
    data: user_permissionsCreateManyInput | user_permissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_permissions update
   */
  export type user_permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_permissions.
     */
    data: XOR<user_permissionsUpdateInput, user_permissionsUncheckedUpdateInput>
    /**
     * Choose, which user_permissions to update.
     */
    where: user_permissionsWhereUniqueInput
  }

  /**
   * user_permissions updateMany
   */
  export type user_permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_permissions.
     */
    data: XOR<user_permissionsUpdateManyMutationInput, user_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which user_permissions to update
     */
    where?: user_permissionsWhereInput
  }

  /**
   * user_permissions upsert
   */
  export type user_permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_permissions to update in case it exists.
     */
    where: user_permissionsWhereUniqueInput
    /**
     * In case the user_permissions found by the `where` argument doesn't exist, create a new user_permissions with this data.
     */
    create: XOR<user_permissionsCreateInput, user_permissionsUncheckedCreateInput>
    /**
     * In case the user_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_permissionsUpdateInput, user_permissionsUncheckedUpdateInput>
  }

  /**
   * user_permissions delete
   */
  export type user_permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter which user_permissions to delete.
     */
    where: user_permissionsWhereUniqueInput
  }

  /**
   * user_permissions deleteMany
   */
  export type user_permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_permissions to delete
     */
    where?: user_permissionsWhereInput
  }

  /**
   * user_permissions without action
   */
  export type user_permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
  }


  /**
   * Model user_sessions
   */

  export type AggregateUser_sessions = {
    _count: User_sessionsCountAggregateOutputType | null
    _avg: User_sessionsAvgAggregateOutputType | null
    _sum: User_sessionsSumAggregateOutputType | null
    _min: User_sessionsMinAggregateOutputType | null
    _max: User_sessionsMaxAggregateOutputType | null
  }

  export type User_sessionsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type User_sessionsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type User_sessionsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    sessionToken: string | null
    ipAddress: string | null
    location: string | null
    isActive: boolean | null
    lastActivityAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_sessionsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    sessionToken: string | null
    ipAddress: string | null
    location: string | null
    isActive: boolean | null
    lastActivityAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_sessionsCountAggregateOutputType = {
    id: number
    userId: number
    sessionToken: number
    deviceInfo: number
    ipAddress: number
    location: number
    isActive: number
    lastActivityAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type User_sessionsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type User_sessionsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type User_sessionsMinAggregateInputType = {
    id?: true
    userId?: true
    sessionToken?: true
    ipAddress?: true
    location?: true
    isActive?: true
    lastActivityAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_sessionsMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionToken?: true
    ipAddress?: true
    location?: true
    isActive?: true
    lastActivityAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_sessionsCountAggregateInputType = {
    id?: true
    userId?: true
    sessionToken?: true
    deviceInfo?: true
    ipAddress?: true
    location?: true
    isActive?: true
    lastActivityAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type User_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_sessions to aggregate.
     */
    where?: user_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_sessions to fetch.
     */
    orderBy?: user_sessionsOrderByWithRelationInput | user_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_sessions
    **/
    _count?: true | User_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_sessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_sessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_sessionsMaxAggregateInputType
  }

  export type GetUser_sessionsAggregateType<T extends User_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_sessions[P]>
      : GetScalarType<T[P], AggregateUser_sessions[P]>
  }




  export type user_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_sessionsWhereInput
    orderBy?: user_sessionsOrderByWithAggregationInput | user_sessionsOrderByWithAggregationInput[]
    by: User_sessionsScalarFieldEnum[] | User_sessionsScalarFieldEnum
    having?: user_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_sessionsCountAggregateInputType | true
    _avg?: User_sessionsAvgAggregateInputType
    _sum?: User_sessionsSumAggregateInputType
    _min?: User_sessionsMinAggregateInputType
    _max?: User_sessionsMaxAggregateInputType
  }

  export type User_sessionsGroupByOutputType = {
    id: number
    userId: number
    sessionToken: string
    deviceInfo: JsonValue | null
    ipAddress: string | null
    location: string | null
    isActive: boolean
    lastActivityAt: Date
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: User_sessionsCountAggregateOutputType | null
    _avg: User_sessionsAvgAggregateOutputType | null
    _sum: User_sessionsSumAggregateOutputType | null
    _min: User_sessionsMinAggregateOutputType | null
    _max: User_sessionsMaxAggregateOutputType | null
  }

  type GetUser_sessionsGroupByPayload<T extends user_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], User_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type user_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionToken?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    location?: boolean
    isActive?: boolean
    lastActivityAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_sessions"]>

  export type user_sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionToken?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    location?: boolean
    isActive?: boolean
    lastActivityAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_sessions"]>

  export type user_sessionsSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionToken?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    location?: boolean
    isActive?: boolean
    lastActivityAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type user_sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_sessions"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      sessionToken: string
      deviceInfo: Prisma.JsonValue | null
      ipAddress: string | null
      location: string | null
      isActive: boolean
      lastActivityAt: Date
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user_sessions"]>
    composites: {}
  }

  type user_sessionsGetPayload<S extends boolean | null | undefined | user_sessionsDefaultArgs> = $Result.GetResult<Prisma.$user_sessionsPayload, S>

  type user_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_sessionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_sessionsCountAggregateInputType | true
    }

  export interface user_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_sessions'], meta: { name: 'user_sessions' } }
    /**
     * Find zero or one User_sessions that matches the filter.
     * @param {user_sessionsFindUniqueArgs} args - Arguments to find a User_sessions
     * @example
     * // Get one User_sessions
     * const user_sessions = await prisma.user_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_sessionsFindUniqueArgs>(args: SelectSubset<T, user_sessionsFindUniqueArgs<ExtArgs>>): Prisma__user_sessionsClient<$Result.GetResult<Prisma.$user_sessionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_sessions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_sessionsFindUniqueOrThrowArgs} args - Arguments to find a User_sessions
     * @example
     * // Get one User_sessions
     * const user_sessions = await prisma.user_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_sessionsClient<$Result.GetResult<Prisma.$user_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionsFindFirstArgs} args - Arguments to find a User_sessions
     * @example
     * // Get one User_sessions
     * const user_sessions = await prisma.user_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_sessionsFindFirstArgs>(args?: SelectSubset<T, user_sessionsFindFirstArgs<ExtArgs>>): Prisma__user_sessionsClient<$Result.GetResult<Prisma.$user_sessionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionsFindFirstOrThrowArgs} args - Arguments to find a User_sessions
     * @example
     * // Get one User_sessions
     * const user_sessions = await prisma.user_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_sessionsClient<$Result.GetResult<Prisma.$user_sessionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_sessions
     * const user_sessions = await prisma.user_sessions.findMany()
     * 
     * // Get first 10 User_sessions
     * const user_sessions = await prisma.user_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_sessionsWithIdOnly = await prisma.user_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_sessionsFindManyArgs>(args?: SelectSubset<T, user_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_sessionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_sessions.
     * @param {user_sessionsCreateArgs} args - Arguments to create a User_sessions.
     * @example
     * // Create one User_sessions
     * const User_sessions = await prisma.user_sessions.create({
     *   data: {
     *     // ... data to create a User_sessions
     *   }
     * })
     * 
     */
    create<T extends user_sessionsCreateArgs>(args: SelectSubset<T, user_sessionsCreateArgs<ExtArgs>>): Prisma__user_sessionsClient<$Result.GetResult<Prisma.$user_sessionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_sessions.
     * @param {user_sessionsCreateManyArgs} args - Arguments to create many User_sessions.
     * @example
     * // Create many User_sessions
     * const user_sessions = await prisma.user_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_sessionsCreateManyArgs>(args?: SelectSubset<T, user_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_sessions and returns the data saved in the database.
     * @param {user_sessionsCreateManyAndReturnArgs} args - Arguments to create many User_sessions.
     * @example
     * // Create many User_sessions
     * const user_sessions = await prisma.user_sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_sessions and only return the `id`
     * const user_sessionsWithIdOnly = await prisma.user_sessions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_sessionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_sessions.
     * @param {user_sessionsDeleteArgs} args - Arguments to delete one User_sessions.
     * @example
     * // Delete one User_sessions
     * const User_sessions = await prisma.user_sessions.delete({
     *   where: {
     *     // ... filter to delete one User_sessions
     *   }
     * })
     * 
     */
    delete<T extends user_sessionsDeleteArgs>(args: SelectSubset<T, user_sessionsDeleteArgs<ExtArgs>>): Prisma__user_sessionsClient<$Result.GetResult<Prisma.$user_sessionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_sessions.
     * @param {user_sessionsUpdateArgs} args - Arguments to update one User_sessions.
     * @example
     * // Update one User_sessions
     * const user_sessions = await prisma.user_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_sessionsUpdateArgs>(args: SelectSubset<T, user_sessionsUpdateArgs<ExtArgs>>): Prisma__user_sessionsClient<$Result.GetResult<Prisma.$user_sessionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_sessions.
     * @param {user_sessionsDeleteManyArgs} args - Arguments to filter User_sessions to delete.
     * @example
     * // Delete a few User_sessions
     * const { count } = await prisma.user_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_sessionsDeleteManyArgs>(args?: SelectSubset<T, user_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_sessions
     * const user_sessions = await prisma.user_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_sessionsUpdateManyArgs>(args: SelectSubset<T, user_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_sessions.
     * @param {user_sessionsUpsertArgs} args - Arguments to update or create a User_sessions.
     * @example
     * // Update or create a User_sessions
     * const user_sessions = await prisma.user_sessions.upsert({
     *   create: {
     *     // ... data to create a User_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_sessions we want to update
     *   }
     * })
     */
    upsert<T extends user_sessionsUpsertArgs>(args: SelectSubset<T, user_sessionsUpsertArgs<ExtArgs>>): Prisma__user_sessionsClient<$Result.GetResult<Prisma.$user_sessionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionsCountArgs} args - Arguments to filter User_sessions to count.
     * @example
     * // Count the number of User_sessions
     * const count = await prisma.user_sessions.count({
     *   where: {
     *     // ... the filter for the User_sessions we want to count
     *   }
     * })
    **/
    count<T extends user_sessionsCountArgs>(
      args?: Subset<T, user_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_sessionsAggregateArgs>(args: Subset<T, User_sessionsAggregateArgs>): Prisma.PrismaPromise<GetUser_sessionsAggregateType<T>>

    /**
     * Group by User_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: user_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_sessions model
   */
  readonly fields: user_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_sessions model
   */ 
  interface user_sessionsFieldRefs {
    readonly id: FieldRef<"user_sessions", 'Int'>
    readonly userId: FieldRef<"user_sessions", 'Int'>
    readonly sessionToken: FieldRef<"user_sessions", 'String'>
    readonly deviceInfo: FieldRef<"user_sessions", 'Json'>
    readonly ipAddress: FieldRef<"user_sessions", 'String'>
    readonly location: FieldRef<"user_sessions", 'String'>
    readonly isActive: FieldRef<"user_sessions", 'Boolean'>
    readonly lastActivityAt: FieldRef<"user_sessions", 'DateTime'>
    readonly expiresAt: FieldRef<"user_sessions", 'DateTime'>
    readonly createdAt: FieldRef<"user_sessions", 'DateTime'>
    readonly updatedAt: FieldRef<"user_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_sessions findUnique
   */
  export type user_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which user_sessions to fetch.
     */
    where: user_sessionsWhereUniqueInput
  }

  /**
   * user_sessions findUniqueOrThrow
   */
  export type user_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which user_sessions to fetch.
     */
    where: user_sessionsWhereUniqueInput
  }

  /**
   * user_sessions findFirst
   */
  export type user_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which user_sessions to fetch.
     */
    where?: user_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_sessions to fetch.
     */
    orderBy?: user_sessionsOrderByWithRelationInput | user_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_sessions.
     */
    cursor?: user_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_sessions.
     */
    distinct?: User_sessionsScalarFieldEnum | User_sessionsScalarFieldEnum[]
  }

  /**
   * user_sessions findFirstOrThrow
   */
  export type user_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which user_sessions to fetch.
     */
    where?: user_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_sessions to fetch.
     */
    orderBy?: user_sessionsOrderByWithRelationInput | user_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_sessions.
     */
    cursor?: user_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_sessions.
     */
    distinct?: User_sessionsScalarFieldEnum | User_sessionsScalarFieldEnum[]
  }

  /**
   * user_sessions findMany
   */
  export type user_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which user_sessions to fetch.
     */
    where?: user_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_sessions to fetch.
     */
    orderBy?: user_sessionsOrderByWithRelationInput | user_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_sessions.
     */
    cursor?: user_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_sessions.
     */
    skip?: number
    distinct?: User_sessionsScalarFieldEnum | User_sessionsScalarFieldEnum[]
  }

  /**
   * user_sessions create
   */
  export type user_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_sessions.
     */
    data: XOR<user_sessionsCreateInput, user_sessionsUncheckedCreateInput>
  }

  /**
   * user_sessions createMany
   */
  export type user_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_sessions.
     */
    data: user_sessionsCreateManyInput | user_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_sessions createManyAndReturn
   */
  export type user_sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_sessions.
     */
    data: user_sessionsCreateManyInput | user_sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_sessions update
   */
  export type user_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_sessions.
     */
    data: XOR<user_sessionsUpdateInput, user_sessionsUncheckedUpdateInput>
    /**
     * Choose, which user_sessions to update.
     */
    where: user_sessionsWhereUniqueInput
  }

  /**
   * user_sessions updateMany
   */
  export type user_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_sessions.
     */
    data: XOR<user_sessionsUpdateManyMutationInput, user_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which user_sessions to update
     */
    where?: user_sessionsWhereInput
  }

  /**
   * user_sessions upsert
   */
  export type user_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_sessions to update in case it exists.
     */
    where: user_sessionsWhereUniqueInput
    /**
     * In case the user_sessions found by the `where` argument doesn't exist, create a new user_sessions with this data.
     */
    create: XOR<user_sessionsCreateInput, user_sessionsUncheckedCreateInput>
    /**
     * In case the user_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_sessionsUpdateInput, user_sessionsUncheckedUpdateInput>
  }

  /**
   * user_sessions delete
   */
  export type user_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsInclude<ExtArgs> | null
    /**
     * Filter which user_sessions to delete.
     */
    where: user_sessionsWhereUniqueInput
  }

  /**
   * user_sessions deleteMany
   */
  export type user_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_sessions to delete
     */
    where?: user_sessionsWhereInput
  }

  /**
   * user_sessions without action
   */
  export type user_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsInclude<ExtArgs> | null
  }


  /**
   * Model refresh_tokens
   */

  export type AggregateRefresh_tokens = {
    _count: Refresh_tokensCountAggregateOutputType | null
    _avg: Refresh_tokensAvgAggregateOutputType | null
    _sum: Refresh_tokensSumAggregateOutputType | null
    _min: Refresh_tokensMinAggregateOutputType | null
    _max: Refresh_tokensMaxAggregateOutputType | null
  }

  export type Refresh_tokensAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Refresh_tokensSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Refresh_tokensMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Refresh_tokensMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Refresh_tokensCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Refresh_tokensAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Refresh_tokensSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Refresh_tokensMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Refresh_tokensMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Refresh_tokensCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Refresh_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refresh_tokens to aggregate.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned refresh_tokens
    **/
    _count?: true | Refresh_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Refresh_tokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Refresh_tokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Refresh_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Refresh_tokensMaxAggregateInputType
  }

  export type GetRefresh_tokensAggregateType<T extends Refresh_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregateRefresh_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefresh_tokens[P]>
      : GetScalarType<T[P], AggregateRefresh_tokens[P]>
  }




  export type refresh_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refresh_tokensWhereInput
    orderBy?: refresh_tokensOrderByWithAggregationInput | refresh_tokensOrderByWithAggregationInput[]
    by: Refresh_tokensScalarFieldEnum[] | Refresh_tokensScalarFieldEnum
    having?: refresh_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Refresh_tokensCountAggregateInputType | true
    _avg?: Refresh_tokensAvgAggregateInputType
    _sum?: Refresh_tokensSumAggregateInputType
    _min?: Refresh_tokensMinAggregateInputType
    _max?: Refresh_tokensMaxAggregateInputType
  }

  export type Refresh_tokensGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: Refresh_tokensCountAggregateOutputType | null
    _avg: Refresh_tokensAvgAggregateOutputType | null
    _sum: Refresh_tokensSumAggregateOutputType | null
    _min: Refresh_tokensMinAggregateOutputType | null
    _max: Refresh_tokensMaxAggregateOutputType | null
  }

  type GetRefresh_tokensGroupByPayload<T extends refresh_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Refresh_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Refresh_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Refresh_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Refresh_tokensGroupByOutputType[P]>
        }
      >
    >


  export type refresh_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refresh_tokens"]>

  export type refresh_tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refresh_tokens"]>

  export type refresh_tokensSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type refresh_tokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type refresh_tokensIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $refresh_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "refresh_tokens"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refresh_tokens"]>
    composites: {}
  }

  type refresh_tokensGetPayload<S extends boolean | null | undefined | refresh_tokensDefaultArgs> = $Result.GetResult<Prisma.$refresh_tokensPayload, S>

  type refresh_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<refresh_tokensFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Refresh_tokensCountAggregateInputType | true
    }

  export interface refresh_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['refresh_tokens'], meta: { name: 'refresh_tokens' } }
    /**
     * Find zero or one Refresh_tokens that matches the filter.
     * @param {refresh_tokensFindUniqueArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends refresh_tokensFindUniqueArgs>(args: SelectSubset<T, refresh_tokensFindUniqueArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Refresh_tokens that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {refresh_tokensFindUniqueOrThrowArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends refresh_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, refresh_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Refresh_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensFindFirstArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends refresh_tokensFindFirstArgs>(args?: SelectSubset<T, refresh_tokensFindFirstArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Refresh_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensFindFirstOrThrowArgs} args - Arguments to find a Refresh_tokens
     * @example
     * // Get one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends refresh_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, refresh_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Refresh_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findMany()
     * 
     * // Get first 10 Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refresh_tokensWithIdOnly = await prisma.refresh_tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends refresh_tokensFindManyArgs>(args?: SelectSubset<T, refresh_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Refresh_tokens.
     * @param {refresh_tokensCreateArgs} args - Arguments to create a Refresh_tokens.
     * @example
     * // Create one Refresh_tokens
     * const Refresh_tokens = await prisma.refresh_tokens.create({
     *   data: {
     *     // ... data to create a Refresh_tokens
     *   }
     * })
     * 
     */
    create<T extends refresh_tokensCreateArgs>(args: SelectSubset<T, refresh_tokensCreateArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Refresh_tokens.
     * @param {refresh_tokensCreateManyArgs} args - Arguments to create many Refresh_tokens.
     * @example
     * // Create many Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends refresh_tokensCreateManyArgs>(args?: SelectSubset<T, refresh_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Refresh_tokens and returns the data saved in the database.
     * @param {refresh_tokensCreateManyAndReturnArgs} args - Arguments to create many Refresh_tokens.
     * @example
     * // Create many Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Refresh_tokens and only return the `id`
     * const refresh_tokensWithIdOnly = await prisma.refresh_tokens.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends refresh_tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, refresh_tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Refresh_tokens.
     * @param {refresh_tokensDeleteArgs} args - Arguments to delete one Refresh_tokens.
     * @example
     * // Delete one Refresh_tokens
     * const Refresh_tokens = await prisma.refresh_tokens.delete({
     *   where: {
     *     // ... filter to delete one Refresh_tokens
     *   }
     * })
     * 
     */
    delete<T extends refresh_tokensDeleteArgs>(args: SelectSubset<T, refresh_tokensDeleteArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Refresh_tokens.
     * @param {refresh_tokensUpdateArgs} args - Arguments to update one Refresh_tokens.
     * @example
     * // Update one Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends refresh_tokensUpdateArgs>(args: SelectSubset<T, refresh_tokensUpdateArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Refresh_tokens.
     * @param {refresh_tokensDeleteManyArgs} args - Arguments to filter Refresh_tokens to delete.
     * @example
     * // Delete a few Refresh_tokens
     * const { count } = await prisma.refresh_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends refresh_tokensDeleteManyArgs>(args?: SelectSubset<T, refresh_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends refresh_tokensUpdateManyArgs>(args: SelectSubset<T, refresh_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Refresh_tokens.
     * @param {refresh_tokensUpsertArgs} args - Arguments to update or create a Refresh_tokens.
     * @example
     * // Update or create a Refresh_tokens
     * const refresh_tokens = await prisma.refresh_tokens.upsert({
     *   create: {
     *     // ... data to create a Refresh_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refresh_tokens we want to update
     *   }
     * })
     */
    upsert<T extends refresh_tokensUpsertArgs>(args: SelectSubset<T, refresh_tokensUpsertArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensCountArgs} args - Arguments to filter Refresh_tokens to count.
     * @example
     * // Count the number of Refresh_tokens
     * const count = await prisma.refresh_tokens.count({
     *   where: {
     *     // ... the filter for the Refresh_tokens we want to count
     *   }
     * })
    **/
    count<T extends refresh_tokensCountArgs>(
      args?: Subset<T, refresh_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Refresh_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Refresh_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Refresh_tokensAggregateArgs>(args: Subset<T, Refresh_tokensAggregateArgs>): Prisma.PrismaPromise<GetRefresh_tokensAggregateType<T>>

    /**
     * Group by Refresh_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refresh_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends refresh_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: refresh_tokensGroupByArgs['orderBy'] }
        : { orderBy?: refresh_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, refresh_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefresh_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the refresh_tokens model
   */
  readonly fields: refresh_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for refresh_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__refresh_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the refresh_tokens model
   */ 
  interface refresh_tokensFieldRefs {
    readonly id: FieldRef<"refresh_tokens", 'Int'>
    readonly userId: FieldRef<"refresh_tokens", 'Int'>
    readonly token: FieldRef<"refresh_tokens", 'String'>
    readonly expiresAt: FieldRef<"refresh_tokens", 'DateTime'>
    readonly createdAt: FieldRef<"refresh_tokens", 'DateTime'>
    readonly updatedAt: FieldRef<"refresh_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * refresh_tokens findUnique
   */
  export type refresh_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens findUniqueOrThrow
   */
  export type refresh_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens findFirst
   */
  export type refresh_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refresh_tokens.
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refresh_tokens.
     */
    distinct?: Refresh_tokensScalarFieldEnum | Refresh_tokensScalarFieldEnum[]
  }

  /**
   * refresh_tokens findFirstOrThrow
   */
  export type refresh_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refresh_tokens.
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refresh_tokens.
     */
    distinct?: Refresh_tokensScalarFieldEnum | Refresh_tokensScalarFieldEnum[]
  }

  /**
   * refresh_tokens findMany
   */
  export type refresh_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter, which refresh_tokens to fetch.
     */
    where?: refresh_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refresh_tokens to fetch.
     */
    orderBy?: refresh_tokensOrderByWithRelationInput | refresh_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing refresh_tokens.
     */
    cursor?: refresh_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refresh_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refresh_tokens.
     */
    skip?: number
    distinct?: Refresh_tokensScalarFieldEnum | Refresh_tokensScalarFieldEnum[]
  }

  /**
   * refresh_tokens create
   */
  export type refresh_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * The data needed to create a refresh_tokens.
     */
    data: XOR<refresh_tokensCreateInput, refresh_tokensUncheckedCreateInput>
  }

  /**
   * refresh_tokens createMany
   */
  export type refresh_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many refresh_tokens.
     */
    data: refresh_tokensCreateManyInput | refresh_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * refresh_tokens createManyAndReturn
   */
  export type refresh_tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many refresh_tokens.
     */
    data: refresh_tokensCreateManyInput | refresh_tokensCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * refresh_tokens update
   */
  export type refresh_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * The data needed to update a refresh_tokens.
     */
    data: XOR<refresh_tokensUpdateInput, refresh_tokensUncheckedUpdateInput>
    /**
     * Choose, which refresh_tokens to update.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens updateMany
   */
  export type refresh_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update refresh_tokens.
     */
    data: XOR<refresh_tokensUpdateManyMutationInput, refresh_tokensUncheckedUpdateManyInput>
    /**
     * Filter which refresh_tokens to update
     */
    where?: refresh_tokensWhereInput
  }

  /**
   * refresh_tokens upsert
   */
  export type refresh_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * The filter to search for the refresh_tokens to update in case it exists.
     */
    where: refresh_tokensWhereUniqueInput
    /**
     * In case the refresh_tokens found by the `where` argument doesn't exist, create a new refresh_tokens with this data.
     */
    create: XOR<refresh_tokensCreateInput, refresh_tokensUncheckedCreateInput>
    /**
     * In case the refresh_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<refresh_tokensUpdateInput, refresh_tokensUncheckedUpdateInput>
  }

  /**
   * refresh_tokens delete
   */
  export type refresh_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    /**
     * Filter which refresh_tokens to delete.
     */
    where: refresh_tokensWhereUniqueInput
  }

  /**
   * refresh_tokens deleteMany
   */
  export type refresh_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refresh_tokens to delete
     */
    where?: refresh_tokensWhereInput
  }

  /**
   * refresh_tokens without action
   */
  export type refresh_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    failedLoginAttempts: number | null
    departmentId: number | null
    roleId: number | null
    locationId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    failedLoginAttempts: number | null
    departmentId: number | null
    roleId: number | null
    locationId: number | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    profileImage: string | null
    isActive: boolean | null
    isLocked: boolean | null
    lastLoginAt: Date | null
    passwordChangedAt: Date | null
    failedLoginAttempts: number | null
    lockoutUntil: Date | null
    departmentId: number | null
    roleId: number | null
    locationId: number | null
    accessLevel: $Enums.AccessLevel | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    profileImage: string | null
    isActive: boolean | null
    isLocked: boolean | null
    lastLoginAt: Date | null
    passwordChangedAt: Date | null
    failedLoginAttempts: number | null
    lockoutUntil: Date | null
    departmentId: number | null
    roleId: number | null
    locationId: number | null
    accessLevel: $Enums.AccessLevel | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    firstName: number
    lastName: number
    phone: number
    profileImage: number
    isActive: number
    isLocked: number
    lastLoginAt: number
    passwordChangedAt: number
    failedLoginAttempts: number
    lockoutUntil: number
    departmentId: number
    roleId: number
    locationId: number
    accessLevel: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    failedLoginAttempts?: true
    departmentId?: true
    roleId?: true
    locationId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    failedLoginAttempts?: true
    departmentId?: true
    roleId?: true
    locationId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    profileImage?: true
    isActive?: true
    isLocked?: true
    lastLoginAt?: true
    passwordChangedAt?: true
    failedLoginAttempts?: true
    lockoutUntil?: true
    departmentId?: true
    roleId?: true
    locationId?: true
    accessLevel?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    profileImage?: true
    isActive?: true
    isLocked?: true
    lastLoginAt?: true
    passwordChangedAt?: true
    failedLoginAttempts?: true
    lockoutUntil?: true
    departmentId?: true
    roleId?: true
    locationId?: true
    accessLevel?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    profileImage?: true
    isActive?: true
    isLocked?: true
    lastLoginAt?: true
    passwordChangedAt?: true
    failedLoginAttempts?: true
    lockoutUntil?: true
    departmentId?: true
    roleId?: true
    locationId?: true
    accessLevel?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone: string | null
    profileImage: string | null
    isActive: boolean
    isLocked: boolean
    lastLoginAt: Date | null
    passwordChangedAt: Date | null
    failedLoginAttempts: number
    lockoutUntil: Date | null
    departmentId: number | null
    roleId: number | null
    locationId: number | null
    accessLevel: $Enums.AccessLevel
    createdAt: Date
    updatedAt: Date
    createdBy: number | null
    updatedBy: number | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    profileImage?: boolean
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: boolean
    passwordChangedAt?: boolean
    failedLoginAttempts?: boolean
    lockoutUntil?: boolean
    departmentId?: boolean
    roleId?: boolean
    locationId?: boolean
    accessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    login_history?: boolean | users$login_historyArgs<ExtArgs>
    tickets_tickets_assignedToIdTousers?: boolean | users$tickets_tickets_assignedToIdTousersArgs<ExtArgs>
    tickets_tickets_raisedByIdTousers?: boolean | users$tickets_tickets_raisedByIdTousersArgs<ExtArgs>
    user_activity_logs?: boolean | users$user_activity_logsArgs<ExtArgs>
    user_permissions?: boolean | users$user_permissionsArgs<ExtArgs>
    user_sessions?: boolean | users$user_sessionsArgs<ExtArgs>
    refresh_tokens?: boolean | users$refresh_tokensArgs<ExtArgs>
    departments?: boolean | users$departmentsArgs<ExtArgs>
    roles?: boolean | users$rolesArgs<ExtArgs>
    locations?: boolean | users$locationsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    profileImage?: boolean
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: boolean
    passwordChangedAt?: boolean
    failedLoginAttempts?: boolean
    lockoutUntil?: boolean
    departmentId?: boolean
    roleId?: boolean
    locationId?: boolean
    accessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    departments?: boolean | users$departmentsArgs<ExtArgs>
    roles?: boolean | users$rolesArgs<ExtArgs>
    locations?: boolean | users$locationsArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    profileImage?: boolean
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: boolean
    passwordChangedAt?: boolean
    failedLoginAttempts?: boolean
    lockoutUntil?: boolean
    departmentId?: boolean
    roleId?: boolean
    locationId?: boolean
    accessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    login_history?: boolean | users$login_historyArgs<ExtArgs>
    tickets_tickets_assignedToIdTousers?: boolean | users$tickets_tickets_assignedToIdTousersArgs<ExtArgs>
    tickets_tickets_raisedByIdTousers?: boolean | users$tickets_tickets_raisedByIdTousersArgs<ExtArgs>
    user_activity_logs?: boolean | users$user_activity_logsArgs<ExtArgs>
    user_permissions?: boolean | users$user_permissionsArgs<ExtArgs>
    user_sessions?: boolean | users$user_sessionsArgs<ExtArgs>
    refresh_tokens?: boolean | users$refresh_tokensArgs<ExtArgs>
    departments?: boolean | users$departmentsArgs<ExtArgs>
    roles?: boolean | users$rolesArgs<ExtArgs>
    locations?: boolean | users$locationsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | users$departmentsArgs<ExtArgs>
    roles?: boolean | users$rolesArgs<ExtArgs>
    locations?: boolean | users$locationsArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      login_history: Prisma.$login_historyPayload<ExtArgs>[]
      tickets_tickets_assignedToIdTousers: Prisma.$ticketsPayload<ExtArgs>[]
      tickets_tickets_raisedByIdTousers: Prisma.$ticketsPayload<ExtArgs>[]
      user_activity_logs: Prisma.$user_activity_logsPayload<ExtArgs>[]
      user_permissions: Prisma.$user_permissionsPayload<ExtArgs>[]
      user_sessions: Prisma.$user_sessionsPayload<ExtArgs>[]
      refresh_tokens: Prisma.$refresh_tokensPayload<ExtArgs> | null
      departments: Prisma.$departmentsPayload<ExtArgs> | null
      roles: Prisma.$rolesPayload<ExtArgs> | null
      locations: Prisma.$locationsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      password: string
      firstName: string
      lastName: string
      phone: string | null
      profileImage: string | null
      isActive: boolean
      isLocked: boolean
      lastLoginAt: Date | null
      passwordChangedAt: Date | null
      failedLoginAttempts: number
      lockoutUntil: Date | null
      departmentId: number | null
      roleId: number | null
      locationId: number | null
      accessLevel: $Enums.AccessLevel
      createdAt: Date
      updatedAt: Date
      createdBy: number | null
      updatedBy: number | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    login_history<T extends users$login_historyArgs<ExtArgs> = {}>(args?: Subset<T, users$login_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "findMany"> | Null>
    tickets_tickets_assignedToIdTousers<T extends users$tickets_tickets_assignedToIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$tickets_tickets_assignedToIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findMany"> | Null>
    tickets_tickets_raisedByIdTousers<T extends users$tickets_tickets_raisedByIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$tickets_tickets_raisedByIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findMany"> | Null>
    user_activity_logs<T extends users$user_activity_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_activity_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_activity_logsPayload<ExtArgs>, T, "findMany"> | Null>
    user_permissions<T extends users$user_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findMany"> | Null>
    user_sessions<T extends users$user_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_sessionsPayload<ExtArgs>, T, "findMany"> | Null>
    refresh_tokens<T extends users$refresh_tokensArgs<ExtArgs> = {}>(args?: Subset<T, users$refresh_tokensArgs<ExtArgs>>): Prisma__refresh_tokensClient<$Result.GetResult<Prisma.$refresh_tokensPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    departments<T extends users$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, users$departmentsArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    roles<T extends users$rolesArgs<ExtArgs> = {}>(args?: Subset<T, users$rolesArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    locations<T extends users$locationsArgs<ExtArgs> = {}>(args?: Subset<T, users$locationsArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly username: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly firstName: FieldRef<"users", 'String'>
    readonly lastName: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly profileImage: FieldRef<"users", 'String'>
    readonly isActive: FieldRef<"users", 'Boolean'>
    readonly isLocked: FieldRef<"users", 'Boolean'>
    readonly lastLoginAt: FieldRef<"users", 'DateTime'>
    readonly passwordChangedAt: FieldRef<"users", 'DateTime'>
    readonly failedLoginAttempts: FieldRef<"users", 'Int'>
    readonly lockoutUntil: FieldRef<"users", 'DateTime'>
    readonly departmentId: FieldRef<"users", 'Int'>
    readonly roleId: FieldRef<"users", 'Int'>
    readonly locationId: FieldRef<"users", 'Int'>
    readonly accessLevel: FieldRef<"users", 'AccessLevel'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
    readonly createdBy: FieldRef<"users", 'Int'>
    readonly updatedBy: FieldRef<"users", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.login_history
   */
  export type users$login_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: login_historyInclude<ExtArgs> | null
    where?: login_historyWhereInput
    orderBy?: login_historyOrderByWithRelationInput | login_historyOrderByWithRelationInput[]
    cursor?: login_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Login_historyScalarFieldEnum | Login_historyScalarFieldEnum[]
  }

  /**
   * users.tickets_tickets_assignedToIdTousers
   */
  export type users$tickets_tickets_assignedToIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    where?: ticketsWhereInput
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    cursor?: ticketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * users.tickets_tickets_raisedByIdTousers
   */
  export type users$tickets_tickets_raisedByIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    where?: ticketsWhereInput
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    cursor?: ticketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * users.user_activity_logs
   */
  export type users$user_activity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity_logs
     */
    select?: user_activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activity_logsInclude<ExtArgs> | null
    where?: user_activity_logsWhereInput
    orderBy?: user_activity_logsOrderByWithRelationInput | user_activity_logsOrderByWithRelationInput[]
    cursor?: user_activity_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_activity_logsScalarFieldEnum | User_activity_logsScalarFieldEnum[]
  }

  /**
   * users.user_permissions
   */
  export type users$user_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    where?: user_permissionsWhereInput
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    cursor?: user_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_permissionsScalarFieldEnum | User_permissionsScalarFieldEnum[]
  }

  /**
   * users.user_sessions
   */
  export type users$user_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_sessions
     */
    select?: user_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_sessionsInclude<ExtArgs> | null
    where?: user_sessionsWhereInput
    orderBy?: user_sessionsOrderByWithRelationInput | user_sessionsOrderByWithRelationInput[]
    cursor?: user_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_sessionsScalarFieldEnum | User_sessionsScalarFieldEnum[]
  }

  /**
   * users.refresh_tokens
   */
  export type users$refresh_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refresh_tokens
     */
    select?: refresh_tokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refresh_tokensInclude<ExtArgs> | null
    where?: refresh_tokensWhereInput
  }

  /**
   * users.departments
   */
  export type users$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentsInclude<ExtArgs> | null
    where?: departmentsWhereInput
  }

  /**
   * users.roles
   */
  export type users$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    where?: rolesWhereInput
  }

  /**
   * users.locations
   */
  export type users$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationsInclude<ExtArgs> | null
    where?: locationsWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model raw_xml_import
   */

  export type AggregateRaw_xml_import = {
    _count: Raw_xml_importCountAggregateOutputType | null
    _avg: Raw_xml_importAvgAggregateOutputType | null
    _sum: Raw_xml_importSumAggregateOutputType | null
    _min: Raw_xml_importMinAggregateOutputType | null
    _max: Raw_xml_importMaxAggregateOutputType | null
  }

  export type Raw_xml_importAvgAggregateOutputType = {
    id: number | null
  }

  export type Raw_xml_importSumAggregateOutputType = {
    id: number | null
  }

  export type Raw_xml_importMinAggregateOutputType = {
    id: number | null
    doc: string | null
    imported_at: Date | null
  }

  export type Raw_xml_importMaxAggregateOutputType = {
    id: number | null
    doc: string | null
    imported_at: Date | null
  }

  export type Raw_xml_importCountAggregateOutputType = {
    id: number
    doc: number
    imported_at: number
    _all: number
  }


  export type Raw_xml_importAvgAggregateInputType = {
    id?: true
  }

  export type Raw_xml_importSumAggregateInputType = {
    id?: true
  }

  export type Raw_xml_importMinAggregateInputType = {
    id?: true
    doc?: true
    imported_at?: true
  }

  export type Raw_xml_importMaxAggregateInputType = {
    id?: true
    doc?: true
    imported_at?: true
  }

  export type Raw_xml_importCountAggregateInputType = {
    id?: true
    doc?: true
    imported_at?: true
    _all?: true
  }

  export type Raw_xml_importAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which raw_xml_import to aggregate.
     */
    where?: raw_xml_importWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raw_xml_imports to fetch.
     */
    orderBy?: raw_xml_importOrderByWithRelationInput | raw_xml_importOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: raw_xml_importWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raw_xml_imports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raw_xml_imports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned raw_xml_imports
    **/
    _count?: true | Raw_xml_importCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Raw_xml_importAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Raw_xml_importSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Raw_xml_importMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Raw_xml_importMaxAggregateInputType
  }

  export type GetRaw_xml_importAggregateType<T extends Raw_xml_importAggregateArgs> = {
        [P in keyof T & keyof AggregateRaw_xml_import]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaw_xml_import[P]>
      : GetScalarType<T[P], AggregateRaw_xml_import[P]>
  }




  export type raw_xml_importGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: raw_xml_importWhereInput
    orderBy?: raw_xml_importOrderByWithAggregationInput | raw_xml_importOrderByWithAggregationInput[]
    by: Raw_xml_importScalarFieldEnum[] | Raw_xml_importScalarFieldEnum
    having?: raw_xml_importScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Raw_xml_importCountAggregateInputType | true
    _avg?: Raw_xml_importAvgAggregateInputType
    _sum?: Raw_xml_importSumAggregateInputType
    _min?: Raw_xml_importMinAggregateInputType
    _max?: Raw_xml_importMaxAggregateInputType
  }

  export type Raw_xml_importGroupByOutputType = {
    id: number
    doc: string
    imported_at: Date | null
    _count: Raw_xml_importCountAggregateOutputType | null
    _avg: Raw_xml_importAvgAggregateOutputType | null
    _sum: Raw_xml_importSumAggregateOutputType | null
    _min: Raw_xml_importMinAggregateOutputType | null
    _max: Raw_xml_importMaxAggregateOutputType | null
  }

  type GetRaw_xml_importGroupByPayload<T extends raw_xml_importGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Raw_xml_importGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Raw_xml_importGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Raw_xml_importGroupByOutputType[P]>
            : GetScalarType<T[P], Raw_xml_importGroupByOutputType[P]>
        }
      >
    >


  export type raw_xml_importSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doc?: boolean
    imported_at?: boolean
  }, ExtArgs["result"]["raw_xml_import"]>

  export type raw_xml_importSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doc?: boolean
    imported_at?: boolean
  }, ExtArgs["result"]["raw_xml_import"]>

  export type raw_xml_importSelectScalar = {
    id?: boolean
    doc?: boolean
    imported_at?: boolean
  }


  export type $raw_xml_importPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "raw_xml_import"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doc: string
      imported_at: Date | null
    }, ExtArgs["result"]["raw_xml_import"]>
    composites: {}
  }

  type raw_xml_importGetPayload<S extends boolean | null | undefined | raw_xml_importDefaultArgs> = $Result.GetResult<Prisma.$raw_xml_importPayload, S>

  type raw_xml_importCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<raw_xml_importFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Raw_xml_importCountAggregateInputType | true
    }

  export interface raw_xml_importDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['raw_xml_import'], meta: { name: 'raw_xml_import' } }
    /**
     * Find zero or one Raw_xml_import that matches the filter.
     * @param {raw_xml_importFindUniqueArgs} args - Arguments to find a Raw_xml_import
     * @example
     * // Get one Raw_xml_import
     * const raw_xml_import = await prisma.raw_xml_import.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends raw_xml_importFindUniqueArgs>(args: SelectSubset<T, raw_xml_importFindUniqueArgs<ExtArgs>>): Prisma__raw_xml_importClient<$Result.GetResult<Prisma.$raw_xml_importPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Raw_xml_import that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {raw_xml_importFindUniqueOrThrowArgs} args - Arguments to find a Raw_xml_import
     * @example
     * // Get one Raw_xml_import
     * const raw_xml_import = await prisma.raw_xml_import.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends raw_xml_importFindUniqueOrThrowArgs>(args: SelectSubset<T, raw_xml_importFindUniqueOrThrowArgs<ExtArgs>>): Prisma__raw_xml_importClient<$Result.GetResult<Prisma.$raw_xml_importPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Raw_xml_import that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_xml_importFindFirstArgs} args - Arguments to find a Raw_xml_import
     * @example
     * // Get one Raw_xml_import
     * const raw_xml_import = await prisma.raw_xml_import.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends raw_xml_importFindFirstArgs>(args?: SelectSubset<T, raw_xml_importFindFirstArgs<ExtArgs>>): Prisma__raw_xml_importClient<$Result.GetResult<Prisma.$raw_xml_importPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Raw_xml_import that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_xml_importFindFirstOrThrowArgs} args - Arguments to find a Raw_xml_import
     * @example
     * // Get one Raw_xml_import
     * const raw_xml_import = await prisma.raw_xml_import.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends raw_xml_importFindFirstOrThrowArgs>(args?: SelectSubset<T, raw_xml_importFindFirstOrThrowArgs<ExtArgs>>): Prisma__raw_xml_importClient<$Result.GetResult<Prisma.$raw_xml_importPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Raw_xml_imports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_xml_importFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Raw_xml_imports
     * const raw_xml_imports = await prisma.raw_xml_import.findMany()
     * 
     * // Get first 10 Raw_xml_imports
     * const raw_xml_imports = await prisma.raw_xml_import.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raw_xml_importWithIdOnly = await prisma.raw_xml_import.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends raw_xml_importFindManyArgs>(args?: SelectSubset<T, raw_xml_importFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$raw_xml_importPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Raw_xml_import.
     * @param {raw_xml_importCreateArgs} args - Arguments to create a Raw_xml_import.
     * @example
     * // Create one Raw_xml_import
     * const Raw_xml_import = await prisma.raw_xml_import.create({
     *   data: {
     *     // ... data to create a Raw_xml_import
     *   }
     * })
     * 
     */
    create<T extends raw_xml_importCreateArgs>(args: SelectSubset<T, raw_xml_importCreateArgs<ExtArgs>>): Prisma__raw_xml_importClient<$Result.GetResult<Prisma.$raw_xml_importPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Raw_xml_imports.
     * @param {raw_xml_importCreateManyArgs} args - Arguments to create many Raw_xml_imports.
     * @example
     * // Create many Raw_xml_imports
     * const raw_xml_import = await prisma.raw_xml_import.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends raw_xml_importCreateManyArgs>(args?: SelectSubset<T, raw_xml_importCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Raw_xml_imports and returns the data saved in the database.
     * @param {raw_xml_importCreateManyAndReturnArgs} args - Arguments to create many Raw_xml_imports.
     * @example
     * // Create many Raw_xml_imports
     * const raw_xml_import = await prisma.raw_xml_import.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Raw_xml_imports and only return the `id`
     * const raw_xml_importWithIdOnly = await prisma.raw_xml_import.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends raw_xml_importCreateManyAndReturnArgs>(args?: SelectSubset<T, raw_xml_importCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$raw_xml_importPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Raw_xml_import.
     * @param {raw_xml_importDeleteArgs} args - Arguments to delete one Raw_xml_import.
     * @example
     * // Delete one Raw_xml_import
     * const Raw_xml_import = await prisma.raw_xml_import.delete({
     *   where: {
     *     // ... filter to delete one Raw_xml_import
     *   }
     * })
     * 
     */
    delete<T extends raw_xml_importDeleteArgs>(args: SelectSubset<T, raw_xml_importDeleteArgs<ExtArgs>>): Prisma__raw_xml_importClient<$Result.GetResult<Prisma.$raw_xml_importPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Raw_xml_import.
     * @param {raw_xml_importUpdateArgs} args - Arguments to update one Raw_xml_import.
     * @example
     * // Update one Raw_xml_import
     * const raw_xml_import = await prisma.raw_xml_import.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends raw_xml_importUpdateArgs>(args: SelectSubset<T, raw_xml_importUpdateArgs<ExtArgs>>): Prisma__raw_xml_importClient<$Result.GetResult<Prisma.$raw_xml_importPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Raw_xml_imports.
     * @param {raw_xml_importDeleteManyArgs} args - Arguments to filter Raw_xml_imports to delete.
     * @example
     * // Delete a few Raw_xml_imports
     * const { count } = await prisma.raw_xml_import.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends raw_xml_importDeleteManyArgs>(args?: SelectSubset<T, raw_xml_importDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Raw_xml_imports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_xml_importUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Raw_xml_imports
     * const raw_xml_import = await prisma.raw_xml_import.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends raw_xml_importUpdateManyArgs>(args: SelectSubset<T, raw_xml_importUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Raw_xml_import.
     * @param {raw_xml_importUpsertArgs} args - Arguments to update or create a Raw_xml_import.
     * @example
     * // Update or create a Raw_xml_import
     * const raw_xml_import = await prisma.raw_xml_import.upsert({
     *   create: {
     *     // ... data to create a Raw_xml_import
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Raw_xml_import we want to update
     *   }
     * })
     */
    upsert<T extends raw_xml_importUpsertArgs>(args: SelectSubset<T, raw_xml_importUpsertArgs<ExtArgs>>): Prisma__raw_xml_importClient<$Result.GetResult<Prisma.$raw_xml_importPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Raw_xml_imports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_xml_importCountArgs} args - Arguments to filter Raw_xml_imports to count.
     * @example
     * // Count the number of Raw_xml_imports
     * const count = await prisma.raw_xml_import.count({
     *   where: {
     *     // ... the filter for the Raw_xml_imports we want to count
     *   }
     * })
    **/
    count<T extends raw_xml_importCountArgs>(
      args?: Subset<T, raw_xml_importCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Raw_xml_importCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Raw_xml_import.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Raw_xml_importAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Raw_xml_importAggregateArgs>(args: Subset<T, Raw_xml_importAggregateArgs>): Prisma.PrismaPromise<GetRaw_xml_importAggregateType<T>>

    /**
     * Group by Raw_xml_import.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raw_xml_importGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends raw_xml_importGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: raw_xml_importGroupByArgs['orderBy'] }
        : { orderBy?: raw_xml_importGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, raw_xml_importGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaw_xml_importGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the raw_xml_import model
   */
  readonly fields: raw_xml_importFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for raw_xml_import.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__raw_xml_importClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the raw_xml_import model
   */ 
  interface raw_xml_importFieldRefs {
    readonly id: FieldRef<"raw_xml_import", 'Int'>
    readonly doc: FieldRef<"raw_xml_import", 'String'>
    readonly imported_at: FieldRef<"raw_xml_import", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * raw_xml_import findUnique
   */
  export type raw_xml_importFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_xml_import
     */
    select?: raw_xml_importSelect<ExtArgs> | null
    /**
     * Filter, which raw_xml_import to fetch.
     */
    where: raw_xml_importWhereUniqueInput
  }

  /**
   * raw_xml_import findUniqueOrThrow
   */
  export type raw_xml_importFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_xml_import
     */
    select?: raw_xml_importSelect<ExtArgs> | null
    /**
     * Filter, which raw_xml_import to fetch.
     */
    where: raw_xml_importWhereUniqueInput
  }

  /**
   * raw_xml_import findFirst
   */
  export type raw_xml_importFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_xml_import
     */
    select?: raw_xml_importSelect<ExtArgs> | null
    /**
     * Filter, which raw_xml_import to fetch.
     */
    where?: raw_xml_importWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raw_xml_imports to fetch.
     */
    orderBy?: raw_xml_importOrderByWithRelationInput | raw_xml_importOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for raw_xml_imports.
     */
    cursor?: raw_xml_importWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raw_xml_imports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raw_xml_imports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of raw_xml_imports.
     */
    distinct?: Raw_xml_importScalarFieldEnum | Raw_xml_importScalarFieldEnum[]
  }

  /**
   * raw_xml_import findFirstOrThrow
   */
  export type raw_xml_importFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_xml_import
     */
    select?: raw_xml_importSelect<ExtArgs> | null
    /**
     * Filter, which raw_xml_import to fetch.
     */
    where?: raw_xml_importWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raw_xml_imports to fetch.
     */
    orderBy?: raw_xml_importOrderByWithRelationInput | raw_xml_importOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for raw_xml_imports.
     */
    cursor?: raw_xml_importWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raw_xml_imports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raw_xml_imports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of raw_xml_imports.
     */
    distinct?: Raw_xml_importScalarFieldEnum | Raw_xml_importScalarFieldEnum[]
  }

  /**
   * raw_xml_import findMany
   */
  export type raw_xml_importFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_xml_import
     */
    select?: raw_xml_importSelect<ExtArgs> | null
    /**
     * Filter, which raw_xml_imports to fetch.
     */
    where?: raw_xml_importWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raw_xml_imports to fetch.
     */
    orderBy?: raw_xml_importOrderByWithRelationInput | raw_xml_importOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing raw_xml_imports.
     */
    cursor?: raw_xml_importWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raw_xml_imports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raw_xml_imports.
     */
    skip?: number
    distinct?: Raw_xml_importScalarFieldEnum | Raw_xml_importScalarFieldEnum[]
  }

  /**
   * raw_xml_import create
   */
  export type raw_xml_importCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_xml_import
     */
    select?: raw_xml_importSelect<ExtArgs> | null
    /**
     * The data needed to create a raw_xml_import.
     */
    data: XOR<raw_xml_importCreateInput, raw_xml_importUncheckedCreateInput>
  }

  /**
   * raw_xml_import createMany
   */
  export type raw_xml_importCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many raw_xml_imports.
     */
    data: raw_xml_importCreateManyInput | raw_xml_importCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * raw_xml_import createManyAndReturn
   */
  export type raw_xml_importCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_xml_import
     */
    select?: raw_xml_importSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many raw_xml_imports.
     */
    data: raw_xml_importCreateManyInput | raw_xml_importCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * raw_xml_import update
   */
  export type raw_xml_importUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_xml_import
     */
    select?: raw_xml_importSelect<ExtArgs> | null
    /**
     * The data needed to update a raw_xml_import.
     */
    data: XOR<raw_xml_importUpdateInput, raw_xml_importUncheckedUpdateInput>
    /**
     * Choose, which raw_xml_import to update.
     */
    where: raw_xml_importWhereUniqueInput
  }

  /**
   * raw_xml_import updateMany
   */
  export type raw_xml_importUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update raw_xml_imports.
     */
    data: XOR<raw_xml_importUpdateManyMutationInput, raw_xml_importUncheckedUpdateManyInput>
    /**
     * Filter which raw_xml_imports to update
     */
    where?: raw_xml_importWhereInput
  }

  /**
   * raw_xml_import upsert
   */
  export type raw_xml_importUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_xml_import
     */
    select?: raw_xml_importSelect<ExtArgs> | null
    /**
     * The filter to search for the raw_xml_import to update in case it exists.
     */
    where: raw_xml_importWhereUniqueInput
    /**
     * In case the raw_xml_import found by the `where` argument doesn't exist, create a new raw_xml_import with this data.
     */
    create: XOR<raw_xml_importCreateInput, raw_xml_importUncheckedCreateInput>
    /**
     * In case the raw_xml_import was found with the provided `where` argument, update it with this data.
     */
    update: XOR<raw_xml_importUpdateInput, raw_xml_importUncheckedUpdateInput>
  }

  /**
   * raw_xml_import delete
   */
  export type raw_xml_importDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_xml_import
     */
    select?: raw_xml_importSelect<ExtArgs> | null
    /**
     * Filter which raw_xml_import to delete.
     */
    where: raw_xml_importWhereUniqueInput
  }

  /**
   * raw_xml_import deleteMany
   */
  export type raw_xml_importDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which raw_xml_imports to delete
     */
    where?: raw_xml_importWhereInput
  }

  /**
   * raw_xml_import without action
   */
  export type raw_xml_importDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raw_xml_import
     */
    select?: raw_xml_importSelect<ExtArgs> | null
  }


  /**
   * Model prepaid_accounts
   */

  export type AggregatePrepaid_accounts = {
    _count: Prepaid_accountsCountAggregateOutputType | null
    _avg: Prepaid_accountsAvgAggregateOutputType | null
    _sum: Prepaid_accountsSumAggregateOutputType | null
    _min: Prepaid_accountsMinAggregateOutputType | null
    _max: Prepaid_accountsMaxAggregateOutputType | null
  }

  export type Prepaid_accountsAvgAggregateOutputType = {
    id: number | null
    consumerId: number | null
    currentBalance: number | null
    totalRecharged: number | null
    totalConsumed: number | null
    blockedBy: number | null
    lowBalanceThreshold: number | null
    emergencyThreshold: number | null
    autoRechargeAmount: number | null
    autoRechargeThreshold: number | null
  }

  export type Prepaid_accountsSumAggregateOutputType = {
    id: number | null
    consumerId: number | null
    currentBalance: number | null
    totalRecharged: number | null
    totalConsumed: number | null
    blockedBy: number | null
    lowBalanceThreshold: number | null
    emergencyThreshold: number | null
    autoRechargeAmount: number | null
    autoRechargeThreshold: number | null
  }

  export type Prepaid_accountsMinAggregateOutputType = {
    id: number | null
    consumerId: number | null
    accountNumber: string | null
    currentBalance: number | null
    totalRecharged: number | null
    totalConsumed: number | null
    isActive: boolean | null
    isBlocked: boolean | null
    blockReason: string | null
    blockedAt: Date | null
    blockedBy: number | null
    lowBalanceThreshold: number | null
    emergencyThreshold: number | null
    autoRechargeEnabled: boolean | null
    autoRechargeAmount: number | null
    autoRechargeThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Prepaid_accountsMaxAggregateOutputType = {
    id: number | null
    consumerId: number | null
    accountNumber: string | null
    currentBalance: number | null
    totalRecharged: number | null
    totalConsumed: number | null
    isActive: boolean | null
    isBlocked: boolean | null
    blockReason: string | null
    blockedAt: Date | null
    blockedBy: number | null
    lowBalanceThreshold: number | null
    emergencyThreshold: number | null
    autoRechargeEnabled: boolean | null
    autoRechargeAmount: number | null
    autoRechargeThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Prepaid_accountsCountAggregateOutputType = {
    id: number
    consumerId: number
    accountNumber: number
    currentBalance: number
    totalRecharged: number
    totalConsumed: number
    isActive: number
    isBlocked: number
    blockReason: number
    blockedAt: number
    blockedBy: number
    lowBalanceThreshold: number
    emergencyThreshold: number
    autoRechargeEnabled: number
    autoRechargeAmount: number
    autoRechargeThreshold: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Prepaid_accountsAvgAggregateInputType = {
    id?: true
    consumerId?: true
    currentBalance?: true
    totalRecharged?: true
    totalConsumed?: true
    blockedBy?: true
    lowBalanceThreshold?: true
    emergencyThreshold?: true
    autoRechargeAmount?: true
    autoRechargeThreshold?: true
  }

  export type Prepaid_accountsSumAggregateInputType = {
    id?: true
    consumerId?: true
    currentBalance?: true
    totalRecharged?: true
    totalConsumed?: true
    blockedBy?: true
    lowBalanceThreshold?: true
    emergencyThreshold?: true
    autoRechargeAmount?: true
    autoRechargeThreshold?: true
  }

  export type Prepaid_accountsMinAggregateInputType = {
    id?: true
    consumerId?: true
    accountNumber?: true
    currentBalance?: true
    totalRecharged?: true
    totalConsumed?: true
    isActive?: true
    isBlocked?: true
    blockReason?: true
    blockedAt?: true
    blockedBy?: true
    lowBalanceThreshold?: true
    emergencyThreshold?: true
    autoRechargeEnabled?: true
    autoRechargeAmount?: true
    autoRechargeThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Prepaid_accountsMaxAggregateInputType = {
    id?: true
    consumerId?: true
    accountNumber?: true
    currentBalance?: true
    totalRecharged?: true
    totalConsumed?: true
    isActive?: true
    isBlocked?: true
    blockReason?: true
    blockedAt?: true
    blockedBy?: true
    lowBalanceThreshold?: true
    emergencyThreshold?: true
    autoRechargeEnabled?: true
    autoRechargeAmount?: true
    autoRechargeThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Prepaid_accountsCountAggregateInputType = {
    id?: true
    consumerId?: true
    accountNumber?: true
    currentBalance?: true
    totalRecharged?: true
    totalConsumed?: true
    isActive?: true
    isBlocked?: true
    blockReason?: true
    blockedAt?: true
    blockedBy?: true
    lowBalanceThreshold?: true
    emergencyThreshold?: true
    autoRechargeEnabled?: true
    autoRechargeAmount?: true
    autoRechargeThreshold?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Prepaid_accountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prepaid_accounts to aggregate.
     */
    where?: prepaid_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_accounts to fetch.
     */
    orderBy?: prepaid_accountsOrderByWithRelationInput | prepaid_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prepaid_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prepaid_accounts
    **/
    _count?: true | Prepaid_accountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prepaid_accountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prepaid_accountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prepaid_accountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prepaid_accountsMaxAggregateInputType
  }

  export type GetPrepaid_accountsAggregateType<T extends Prepaid_accountsAggregateArgs> = {
        [P in keyof T & keyof AggregatePrepaid_accounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrepaid_accounts[P]>
      : GetScalarType<T[P], AggregatePrepaid_accounts[P]>
  }




  export type prepaid_accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prepaid_accountsWhereInput
    orderBy?: prepaid_accountsOrderByWithAggregationInput | prepaid_accountsOrderByWithAggregationInput[]
    by: Prepaid_accountsScalarFieldEnum[] | Prepaid_accountsScalarFieldEnum
    having?: prepaid_accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prepaid_accountsCountAggregateInputType | true
    _avg?: Prepaid_accountsAvgAggregateInputType
    _sum?: Prepaid_accountsSumAggregateInputType
    _min?: Prepaid_accountsMinAggregateInputType
    _max?: Prepaid_accountsMaxAggregateInputType
  }

  export type Prepaid_accountsGroupByOutputType = {
    id: number
    consumerId: number
    accountNumber: string
    currentBalance: number
    totalRecharged: number
    totalConsumed: number
    isActive: boolean
    isBlocked: boolean
    blockReason: string | null
    blockedAt: Date | null
    blockedBy: number | null
    lowBalanceThreshold: number
    emergencyThreshold: number
    autoRechargeEnabled: boolean
    autoRechargeAmount: number | null
    autoRechargeThreshold: number | null
    createdAt: Date
    updatedAt: Date
    _count: Prepaid_accountsCountAggregateOutputType | null
    _avg: Prepaid_accountsAvgAggregateOutputType | null
    _sum: Prepaid_accountsSumAggregateOutputType | null
    _min: Prepaid_accountsMinAggregateOutputType | null
    _max: Prepaid_accountsMaxAggregateOutputType | null
  }

  type GetPrepaid_accountsGroupByPayload<T extends prepaid_accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Prepaid_accountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prepaid_accountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prepaid_accountsGroupByOutputType[P]>
            : GetScalarType<T[P], Prepaid_accountsGroupByOutputType[P]>
        }
      >
    >


  export type prepaid_accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consumerId?: boolean
    accountNumber?: boolean
    currentBalance?: boolean
    totalRecharged?: boolean
    totalConsumed?: boolean
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: boolean
    blockedAt?: boolean
    blockedBy?: boolean
    lowBalanceThreshold?: boolean
    emergencyThreshold?: boolean
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: boolean
    autoRechargeThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
    prepaid_alerts?: boolean | prepaid_accounts$prepaid_alertsArgs<ExtArgs>
    prepaid_recharges?: boolean | prepaid_accounts$prepaid_rechargesArgs<ExtArgs>
    prepaid_transactions?: boolean | prepaid_accounts$prepaid_transactionsArgs<ExtArgs>
    _count?: boolean | Prepaid_accountsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prepaid_accounts"]>

  export type prepaid_accountsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consumerId?: boolean
    accountNumber?: boolean
    currentBalance?: boolean
    totalRecharged?: boolean
    totalConsumed?: boolean
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: boolean
    blockedAt?: boolean
    blockedBy?: boolean
    lowBalanceThreshold?: boolean
    emergencyThreshold?: boolean
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: boolean
    autoRechargeThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prepaid_accounts"]>

  export type prepaid_accountsSelectScalar = {
    id?: boolean
    consumerId?: boolean
    accountNumber?: boolean
    currentBalance?: boolean
    totalRecharged?: boolean
    totalConsumed?: boolean
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: boolean
    blockedAt?: boolean
    blockedBy?: boolean
    lowBalanceThreshold?: boolean
    emergencyThreshold?: boolean
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: boolean
    autoRechargeThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type prepaid_accountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
    prepaid_alerts?: boolean | prepaid_accounts$prepaid_alertsArgs<ExtArgs>
    prepaid_recharges?: boolean | prepaid_accounts$prepaid_rechargesArgs<ExtArgs>
    prepaid_transactions?: boolean | prepaid_accounts$prepaid_transactionsArgs<ExtArgs>
    _count?: boolean | Prepaid_accountsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type prepaid_accountsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consumers?: boolean | consumersDefaultArgs<ExtArgs>
  }

  export type $prepaid_accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prepaid_accounts"
    objects: {
      consumers: Prisma.$consumersPayload<ExtArgs>
      prepaid_alerts: Prisma.$prepaid_alertsPayload<ExtArgs>[]
      prepaid_recharges: Prisma.$prepaid_rechargesPayload<ExtArgs>[]
      prepaid_transactions: Prisma.$prepaid_transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      consumerId: number
      accountNumber: string
      currentBalance: number
      totalRecharged: number
      totalConsumed: number
      isActive: boolean
      isBlocked: boolean
      blockReason: string | null
      blockedAt: Date | null
      blockedBy: number | null
      lowBalanceThreshold: number
      emergencyThreshold: number
      autoRechargeEnabled: boolean
      autoRechargeAmount: number | null
      autoRechargeThreshold: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prepaid_accounts"]>
    composites: {}
  }

  type prepaid_accountsGetPayload<S extends boolean | null | undefined | prepaid_accountsDefaultArgs> = $Result.GetResult<Prisma.$prepaid_accountsPayload, S>

  type prepaid_accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<prepaid_accountsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Prepaid_accountsCountAggregateInputType | true
    }

  export interface prepaid_accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prepaid_accounts'], meta: { name: 'prepaid_accounts' } }
    /**
     * Find zero or one Prepaid_accounts that matches the filter.
     * @param {prepaid_accountsFindUniqueArgs} args - Arguments to find a Prepaid_accounts
     * @example
     * // Get one Prepaid_accounts
     * const prepaid_accounts = await prisma.prepaid_accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prepaid_accountsFindUniqueArgs>(args: SelectSubset<T, prepaid_accountsFindUniqueArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prepaid_accounts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {prepaid_accountsFindUniqueOrThrowArgs} args - Arguments to find a Prepaid_accounts
     * @example
     * // Get one Prepaid_accounts
     * const prepaid_accounts = await prisma.prepaid_accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prepaid_accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, prepaid_accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prepaid_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_accountsFindFirstArgs} args - Arguments to find a Prepaid_accounts
     * @example
     * // Get one Prepaid_accounts
     * const prepaid_accounts = await prisma.prepaid_accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prepaid_accountsFindFirstArgs>(args?: SelectSubset<T, prepaid_accountsFindFirstArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prepaid_accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_accountsFindFirstOrThrowArgs} args - Arguments to find a Prepaid_accounts
     * @example
     * // Get one Prepaid_accounts
     * const prepaid_accounts = await prisma.prepaid_accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prepaid_accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, prepaid_accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prepaid_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prepaid_accounts
     * const prepaid_accounts = await prisma.prepaid_accounts.findMany()
     * 
     * // Get first 10 Prepaid_accounts
     * const prepaid_accounts = await prisma.prepaid_accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prepaid_accountsWithIdOnly = await prisma.prepaid_accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends prepaid_accountsFindManyArgs>(args?: SelectSubset<T, prepaid_accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prepaid_accounts.
     * @param {prepaid_accountsCreateArgs} args - Arguments to create a Prepaid_accounts.
     * @example
     * // Create one Prepaid_accounts
     * const Prepaid_accounts = await prisma.prepaid_accounts.create({
     *   data: {
     *     // ... data to create a Prepaid_accounts
     *   }
     * })
     * 
     */
    create<T extends prepaid_accountsCreateArgs>(args: SelectSubset<T, prepaid_accountsCreateArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prepaid_accounts.
     * @param {prepaid_accountsCreateManyArgs} args - Arguments to create many Prepaid_accounts.
     * @example
     * // Create many Prepaid_accounts
     * const prepaid_accounts = await prisma.prepaid_accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prepaid_accountsCreateManyArgs>(args?: SelectSubset<T, prepaid_accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prepaid_accounts and returns the data saved in the database.
     * @param {prepaid_accountsCreateManyAndReturnArgs} args - Arguments to create many Prepaid_accounts.
     * @example
     * // Create many Prepaid_accounts
     * const prepaid_accounts = await prisma.prepaid_accounts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prepaid_accounts and only return the `id`
     * const prepaid_accountsWithIdOnly = await prisma.prepaid_accounts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends prepaid_accountsCreateManyAndReturnArgs>(args?: SelectSubset<T, prepaid_accountsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prepaid_accounts.
     * @param {prepaid_accountsDeleteArgs} args - Arguments to delete one Prepaid_accounts.
     * @example
     * // Delete one Prepaid_accounts
     * const Prepaid_accounts = await prisma.prepaid_accounts.delete({
     *   where: {
     *     // ... filter to delete one Prepaid_accounts
     *   }
     * })
     * 
     */
    delete<T extends prepaid_accountsDeleteArgs>(args: SelectSubset<T, prepaid_accountsDeleteArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prepaid_accounts.
     * @param {prepaid_accountsUpdateArgs} args - Arguments to update one Prepaid_accounts.
     * @example
     * // Update one Prepaid_accounts
     * const prepaid_accounts = await prisma.prepaid_accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prepaid_accountsUpdateArgs>(args: SelectSubset<T, prepaid_accountsUpdateArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prepaid_accounts.
     * @param {prepaid_accountsDeleteManyArgs} args - Arguments to filter Prepaid_accounts to delete.
     * @example
     * // Delete a few Prepaid_accounts
     * const { count } = await prisma.prepaid_accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prepaid_accountsDeleteManyArgs>(args?: SelectSubset<T, prepaid_accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prepaid_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prepaid_accounts
     * const prepaid_accounts = await prisma.prepaid_accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prepaid_accountsUpdateManyArgs>(args: SelectSubset<T, prepaid_accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prepaid_accounts.
     * @param {prepaid_accountsUpsertArgs} args - Arguments to update or create a Prepaid_accounts.
     * @example
     * // Update or create a Prepaid_accounts
     * const prepaid_accounts = await prisma.prepaid_accounts.upsert({
     *   create: {
     *     // ... data to create a Prepaid_accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prepaid_accounts we want to update
     *   }
     * })
     */
    upsert<T extends prepaid_accountsUpsertArgs>(args: SelectSubset<T, prepaid_accountsUpsertArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prepaid_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_accountsCountArgs} args - Arguments to filter Prepaid_accounts to count.
     * @example
     * // Count the number of Prepaid_accounts
     * const count = await prisma.prepaid_accounts.count({
     *   where: {
     *     // ... the filter for the Prepaid_accounts we want to count
     *   }
     * })
    **/
    count<T extends prepaid_accountsCountArgs>(
      args?: Subset<T, prepaid_accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prepaid_accountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prepaid_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prepaid_accountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prepaid_accountsAggregateArgs>(args: Subset<T, Prepaid_accountsAggregateArgs>): Prisma.PrismaPromise<GetPrepaid_accountsAggregateType<T>>

    /**
     * Group by Prepaid_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prepaid_accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prepaid_accountsGroupByArgs['orderBy'] }
        : { orderBy?: prepaid_accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prepaid_accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrepaid_accountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prepaid_accounts model
   */
  readonly fields: prepaid_accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prepaid_accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prepaid_accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consumers<T extends consumersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, consumersDefaultArgs<ExtArgs>>): Prisma__consumersClient<$Result.GetResult<Prisma.$consumersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prepaid_alerts<T extends prepaid_accounts$prepaid_alertsArgs<ExtArgs> = {}>(args?: Subset<T, prepaid_accounts$prepaid_alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_alertsPayload<ExtArgs>, T, "findMany"> | Null>
    prepaid_recharges<T extends prepaid_accounts$prepaid_rechargesArgs<ExtArgs> = {}>(args?: Subset<T, prepaid_accounts$prepaid_rechargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_rechargesPayload<ExtArgs>, T, "findMany"> | Null>
    prepaid_transactions<T extends prepaid_accounts$prepaid_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, prepaid_accounts$prepaid_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prepaid_accounts model
   */ 
  interface prepaid_accountsFieldRefs {
    readonly id: FieldRef<"prepaid_accounts", 'Int'>
    readonly consumerId: FieldRef<"prepaid_accounts", 'Int'>
    readonly accountNumber: FieldRef<"prepaid_accounts", 'String'>
    readonly currentBalance: FieldRef<"prepaid_accounts", 'Float'>
    readonly totalRecharged: FieldRef<"prepaid_accounts", 'Float'>
    readonly totalConsumed: FieldRef<"prepaid_accounts", 'Float'>
    readonly isActive: FieldRef<"prepaid_accounts", 'Boolean'>
    readonly isBlocked: FieldRef<"prepaid_accounts", 'Boolean'>
    readonly blockReason: FieldRef<"prepaid_accounts", 'String'>
    readonly blockedAt: FieldRef<"prepaid_accounts", 'DateTime'>
    readonly blockedBy: FieldRef<"prepaid_accounts", 'Int'>
    readonly lowBalanceThreshold: FieldRef<"prepaid_accounts", 'Float'>
    readonly emergencyThreshold: FieldRef<"prepaid_accounts", 'Float'>
    readonly autoRechargeEnabled: FieldRef<"prepaid_accounts", 'Boolean'>
    readonly autoRechargeAmount: FieldRef<"prepaid_accounts", 'Float'>
    readonly autoRechargeThreshold: FieldRef<"prepaid_accounts", 'Float'>
    readonly createdAt: FieldRef<"prepaid_accounts", 'DateTime'>
    readonly updatedAt: FieldRef<"prepaid_accounts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * prepaid_accounts findUnique
   */
  export type prepaid_accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_accounts to fetch.
     */
    where: prepaid_accountsWhereUniqueInput
  }

  /**
   * prepaid_accounts findUniqueOrThrow
   */
  export type prepaid_accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_accounts to fetch.
     */
    where: prepaid_accountsWhereUniqueInput
  }

  /**
   * prepaid_accounts findFirst
   */
  export type prepaid_accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_accounts to fetch.
     */
    where?: prepaid_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_accounts to fetch.
     */
    orderBy?: prepaid_accountsOrderByWithRelationInput | prepaid_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prepaid_accounts.
     */
    cursor?: prepaid_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prepaid_accounts.
     */
    distinct?: Prepaid_accountsScalarFieldEnum | Prepaid_accountsScalarFieldEnum[]
  }

  /**
   * prepaid_accounts findFirstOrThrow
   */
  export type prepaid_accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_accounts to fetch.
     */
    where?: prepaid_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_accounts to fetch.
     */
    orderBy?: prepaid_accountsOrderByWithRelationInput | prepaid_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prepaid_accounts.
     */
    cursor?: prepaid_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prepaid_accounts.
     */
    distinct?: Prepaid_accountsScalarFieldEnum | Prepaid_accountsScalarFieldEnum[]
  }

  /**
   * prepaid_accounts findMany
   */
  export type prepaid_accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_accounts to fetch.
     */
    where?: prepaid_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_accounts to fetch.
     */
    orderBy?: prepaid_accountsOrderByWithRelationInput | prepaid_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prepaid_accounts.
     */
    cursor?: prepaid_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_accounts.
     */
    skip?: number
    distinct?: Prepaid_accountsScalarFieldEnum | Prepaid_accountsScalarFieldEnum[]
  }

  /**
   * prepaid_accounts create
   */
  export type prepaid_accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsInclude<ExtArgs> | null
    /**
     * The data needed to create a prepaid_accounts.
     */
    data: XOR<prepaid_accountsCreateInput, prepaid_accountsUncheckedCreateInput>
  }

  /**
   * prepaid_accounts createMany
   */
  export type prepaid_accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prepaid_accounts.
     */
    data: prepaid_accountsCreateManyInput | prepaid_accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prepaid_accounts createManyAndReturn
   */
  export type prepaid_accountsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many prepaid_accounts.
     */
    data: prepaid_accountsCreateManyInput | prepaid_accountsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * prepaid_accounts update
   */
  export type prepaid_accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsInclude<ExtArgs> | null
    /**
     * The data needed to update a prepaid_accounts.
     */
    data: XOR<prepaid_accountsUpdateInput, prepaid_accountsUncheckedUpdateInput>
    /**
     * Choose, which prepaid_accounts to update.
     */
    where: prepaid_accountsWhereUniqueInput
  }

  /**
   * prepaid_accounts updateMany
   */
  export type prepaid_accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prepaid_accounts.
     */
    data: XOR<prepaid_accountsUpdateManyMutationInput, prepaid_accountsUncheckedUpdateManyInput>
    /**
     * Filter which prepaid_accounts to update
     */
    where?: prepaid_accountsWhereInput
  }

  /**
   * prepaid_accounts upsert
   */
  export type prepaid_accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsInclude<ExtArgs> | null
    /**
     * The filter to search for the prepaid_accounts to update in case it exists.
     */
    where: prepaid_accountsWhereUniqueInput
    /**
     * In case the prepaid_accounts found by the `where` argument doesn't exist, create a new prepaid_accounts with this data.
     */
    create: XOR<prepaid_accountsCreateInput, prepaid_accountsUncheckedCreateInput>
    /**
     * In case the prepaid_accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prepaid_accountsUpdateInput, prepaid_accountsUncheckedUpdateInput>
  }

  /**
   * prepaid_accounts delete
   */
  export type prepaid_accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsInclude<ExtArgs> | null
    /**
     * Filter which prepaid_accounts to delete.
     */
    where: prepaid_accountsWhereUniqueInput
  }

  /**
   * prepaid_accounts deleteMany
   */
  export type prepaid_accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prepaid_accounts to delete
     */
    where?: prepaid_accountsWhereInput
  }

  /**
   * prepaid_accounts.prepaid_alerts
   */
  export type prepaid_accounts$prepaid_alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsInclude<ExtArgs> | null
    where?: prepaid_alertsWhereInput
    orderBy?: prepaid_alertsOrderByWithRelationInput | prepaid_alertsOrderByWithRelationInput[]
    cursor?: prepaid_alertsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Prepaid_alertsScalarFieldEnum | Prepaid_alertsScalarFieldEnum[]
  }

  /**
   * prepaid_accounts.prepaid_recharges
   */
  export type prepaid_accounts$prepaid_rechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesInclude<ExtArgs> | null
    where?: prepaid_rechargesWhereInput
    orderBy?: prepaid_rechargesOrderByWithRelationInput | prepaid_rechargesOrderByWithRelationInput[]
    cursor?: prepaid_rechargesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Prepaid_rechargesScalarFieldEnum | Prepaid_rechargesScalarFieldEnum[]
  }

  /**
   * prepaid_accounts.prepaid_transactions
   */
  export type prepaid_accounts$prepaid_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
    where?: prepaid_transactionsWhereInput
    orderBy?: prepaid_transactionsOrderByWithRelationInput | prepaid_transactionsOrderByWithRelationInput[]
    cursor?: prepaid_transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Prepaid_transactionsScalarFieldEnum | Prepaid_transactionsScalarFieldEnum[]
  }

  /**
   * prepaid_accounts without action
   */
  export type prepaid_accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_accounts
     */
    select?: prepaid_accountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_accountsInclude<ExtArgs> | null
  }


  /**
   * Model prepaid_alerts
   */

  export type AggregatePrepaid_alerts = {
    _count: Prepaid_alertsCountAggregateOutputType | null
    _avg: Prepaid_alertsAvgAggregateOutputType | null
    _sum: Prepaid_alertsSumAggregateOutputType | null
    _min: Prepaid_alertsMinAggregateOutputType | null
    _max: Prepaid_alertsMaxAggregateOutputType | null
  }

  export type Prepaid_alertsAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    balanceAtAlert: number | null
    consumptionAtAlert: number | null
    thresholdValue: number | null
  }

  export type Prepaid_alertsSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    balanceAtAlert: number | null
    consumptionAtAlert: number | null
    thresholdValue: number | null
  }

  export type Prepaid_alertsMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    alertType: $Enums.PrepaidAlertType | null
    alertLevel: $Enums.PrepaidAlertLevel | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    balanceAtAlert: number | null
    consumptionAtAlert: number | null
    thresholdValue: number | null
    createdAt: Date | null
  }

  export type Prepaid_alertsMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    alertType: $Enums.PrepaidAlertType | null
    alertLevel: $Enums.PrepaidAlertLevel | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    balanceAtAlert: number | null
    consumptionAtAlert: number | null
    thresholdValue: number | null
    createdAt: Date | null
  }

  export type Prepaid_alertsCountAggregateOutputType = {
    id: number
    accountId: number
    alertType: number
    alertLevel: number
    message: number
    isRead: number
    readAt: number
    balanceAtAlert: number
    consumptionAtAlert: number
    thresholdValue: number
    createdAt: number
    _all: number
  }


  export type Prepaid_alertsAvgAggregateInputType = {
    id?: true
    accountId?: true
    balanceAtAlert?: true
    consumptionAtAlert?: true
    thresholdValue?: true
  }

  export type Prepaid_alertsSumAggregateInputType = {
    id?: true
    accountId?: true
    balanceAtAlert?: true
    consumptionAtAlert?: true
    thresholdValue?: true
  }

  export type Prepaid_alertsMinAggregateInputType = {
    id?: true
    accountId?: true
    alertType?: true
    alertLevel?: true
    message?: true
    isRead?: true
    readAt?: true
    balanceAtAlert?: true
    consumptionAtAlert?: true
    thresholdValue?: true
    createdAt?: true
  }

  export type Prepaid_alertsMaxAggregateInputType = {
    id?: true
    accountId?: true
    alertType?: true
    alertLevel?: true
    message?: true
    isRead?: true
    readAt?: true
    balanceAtAlert?: true
    consumptionAtAlert?: true
    thresholdValue?: true
    createdAt?: true
  }

  export type Prepaid_alertsCountAggregateInputType = {
    id?: true
    accountId?: true
    alertType?: true
    alertLevel?: true
    message?: true
    isRead?: true
    readAt?: true
    balanceAtAlert?: true
    consumptionAtAlert?: true
    thresholdValue?: true
    createdAt?: true
    _all?: true
  }

  export type Prepaid_alertsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prepaid_alerts to aggregate.
     */
    where?: prepaid_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_alerts to fetch.
     */
    orderBy?: prepaid_alertsOrderByWithRelationInput | prepaid_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prepaid_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prepaid_alerts
    **/
    _count?: true | Prepaid_alertsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prepaid_alertsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prepaid_alertsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prepaid_alertsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prepaid_alertsMaxAggregateInputType
  }

  export type GetPrepaid_alertsAggregateType<T extends Prepaid_alertsAggregateArgs> = {
        [P in keyof T & keyof AggregatePrepaid_alerts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrepaid_alerts[P]>
      : GetScalarType<T[P], AggregatePrepaid_alerts[P]>
  }




  export type prepaid_alertsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prepaid_alertsWhereInput
    orderBy?: prepaid_alertsOrderByWithAggregationInput | prepaid_alertsOrderByWithAggregationInput[]
    by: Prepaid_alertsScalarFieldEnum[] | Prepaid_alertsScalarFieldEnum
    having?: prepaid_alertsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prepaid_alertsCountAggregateInputType | true
    _avg?: Prepaid_alertsAvgAggregateInputType
    _sum?: Prepaid_alertsSumAggregateInputType
    _min?: Prepaid_alertsMinAggregateInputType
    _max?: Prepaid_alertsMaxAggregateInputType
  }

  export type Prepaid_alertsGroupByOutputType = {
    id: number
    accountId: number
    alertType: $Enums.PrepaidAlertType
    alertLevel: $Enums.PrepaidAlertLevel
    message: string
    isRead: boolean
    readAt: Date | null
    balanceAtAlert: number | null
    consumptionAtAlert: number | null
    thresholdValue: number | null
    createdAt: Date
    _count: Prepaid_alertsCountAggregateOutputType | null
    _avg: Prepaid_alertsAvgAggregateOutputType | null
    _sum: Prepaid_alertsSumAggregateOutputType | null
    _min: Prepaid_alertsMinAggregateOutputType | null
    _max: Prepaid_alertsMaxAggregateOutputType | null
  }

  type GetPrepaid_alertsGroupByPayload<T extends prepaid_alertsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Prepaid_alertsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prepaid_alertsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prepaid_alertsGroupByOutputType[P]>
            : GetScalarType<T[P], Prepaid_alertsGroupByOutputType[P]>
        }
      >
    >


  export type prepaid_alertsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    alertType?: boolean
    alertLevel?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    balanceAtAlert?: boolean
    consumptionAtAlert?: boolean
    thresholdValue?: boolean
    createdAt?: boolean
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prepaid_alerts"]>

  export type prepaid_alertsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    alertType?: boolean
    alertLevel?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    balanceAtAlert?: boolean
    consumptionAtAlert?: boolean
    thresholdValue?: boolean
    createdAt?: boolean
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prepaid_alerts"]>

  export type prepaid_alertsSelectScalar = {
    id?: boolean
    accountId?: boolean
    alertType?: boolean
    alertLevel?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    balanceAtAlert?: boolean
    consumptionAtAlert?: boolean
    thresholdValue?: boolean
    createdAt?: boolean
  }

  export type prepaid_alertsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
  }
  export type prepaid_alertsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
  }

  export type $prepaid_alertsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prepaid_alerts"
    objects: {
      prepaid_accounts: Prisma.$prepaid_accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accountId: number
      alertType: $Enums.PrepaidAlertType
      alertLevel: $Enums.PrepaidAlertLevel
      message: string
      isRead: boolean
      readAt: Date | null
      balanceAtAlert: number | null
      consumptionAtAlert: number | null
      thresholdValue: number | null
      createdAt: Date
    }, ExtArgs["result"]["prepaid_alerts"]>
    composites: {}
  }

  type prepaid_alertsGetPayload<S extends boolean | null | undefined | prepaid_alertsDefaultArgs> = $Result.GetResult<Prisma.$prepaid_alertsPayload, S>

  type prepaid_alertsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<prepaid_alertsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Prepaid_alertsCountAggregateInputType | true
    }

  export interface prepaid_alertsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prepaid_alerts'], meta: { name: 'prepaid_alerts' } }
    /**
     * Find zero or one Prepaid_alerts that matches the filter.
     * @param {prepaid_alertsFindUniqueArgs} args - Arguments to find a Prepaid_alerts
     * @example
     * // Get one Prepaid_alerts
     * const prepaid_alerts = await prisma.prepaid_alerts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prepaid_alertsFindUniqueArgs>(args: SelectSubset<T, prepaid_alertsFindUniqueArgs<ExtArgs>>): Prisma__prepaid_alertsClient<$Result.GetResult<Prisma.$prepaid_alertsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prepaid_alerts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {prepaid_alertsFindUniqueOrThrowArgs} args - Arguments to find a Prepaid_alerts
     * @example
     * // Get one Prepaid_alerts
     * const prepaid_alerts = await prisma.prepaid_alerts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prepaid_alertsFindUniqueOrThrowArgs>(args: SelectSubset<T, prepaid_alertsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prepaid_alertsClient<$Result.GetResult<Prisma.$prepaid_alertsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prepaid_alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_alertsFindFirstArgs} args - Arguments to find a Prepaid_alerts
     * @example
     * // Get one Prepaid_alerts
     * const prepaid_alerts = await prisma.prepaid_alerts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prepaid_alertsFindFirstArgs>(args?: SelectSubset<T, prepaid_alertsFindFirstArgs<ExtArgs>>): Prisma__prepaid_alertsClient<$Result.GetResult<Prisma.$prepaid_alertsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prepaid_alerts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_alertsFindFirstOrThrowArgs} args - Arguments to find a Prepaid_alerts
     * @example
     * // Get one Prepaid_alerts
     * const prepaid_alerts = await prisma.prepaid_alerts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prepaid_alertsFindFirstOrThrowArgs>(args?: SelectSubset<T, prepaid_alertsFindFirstOrThrowArgs<ExtArgs>>): Prisma__prepaid_alertsClient<$Result.GetResult<Prisma.$prepaid_alertsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prepaid_alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_alertsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prepaid_alerts
     * const prepaid_alerts = await prisma.prepaid_alerts.findMany()
     * 
     * // Get first 10 Prepaid_alerts
     * const prepaid_alerts = await prisma.prepaid_alerts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prepaid_alertsWithIdOnly = await prisma.prepaid_alerts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends prepaid_alertsFindManyArgs>(args?: SelectSubset<T, prepaid_alertsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_alertsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prepaid_alerts.
     * @param {prepaid_alertsCreateArgs} args - Arguments to create a Prepaid_alerts.
     * @example
     * // Create one Prepaid_alerts
     * const Prepaid_alerts = await prisma.prepaid_alerts.create({
     *   data: {
     *     // ... data to create a Prepaid_alerts
     *   }
     * })
     * 
     */
    create<T extends prepaid_alertsCreateArgs>(args: SelectSubset<T, prepaid_alertsCreateArgs<ExtArgs>>): Prisma__prepaid_alertsClient<$Result.GetResult<Prisma.$prepaid_alertsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prepaid_alerts.
     * @param {prepaid_alertsCreateManyArgs} args - Arguments to create many Prepaid_alerts.
     * @example
     * // Create many Prepaid_alerts
     * const prepaid_alerts = await prisma.prepaid_alerts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prepaid_alertsCreateManyArgs>(args?: SelectSubset<T, prepaid_alertsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prepaid_alerts and returns the data saved in the database.
     * @param {prepaid_alertsCreateManyAndReturnArgs} args - Arguments to create many Prepaid_alerts.
     * @example
     * // Create many Prepaid_alerts
     * const prepaid_alerts = await prisma.prepaid_alerts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prepaid_alerts and only return the `id`
     * const prepaid_alertsWithIdOnly = await prisma.prepaid_alerts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends prepaid_alertsCreateManyAndReturnArgs>(args?: SelectSubset<T, prepaid_alertsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_alertsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prepaid_alerts.
     * @param {prepaid_alertsDeleteArgs} args - Arguments to delete one Prepaid_alerts.
     * @example
     * // Delete one Prepaid_alerts
     * const Prepaid_alerts = await prisma.prepaid_alerts.delete({
     *   where: {
     *     // ... filter to delete one Prepaid_alerts
     *   }
     * })
     * 
     */
    delete<T extends prepaid_alertsDeleteArgs>(args: SelectSubset<T, prepaid_alertsDeleteArgs<ExtArgs>>): Prisma__prepaid_alertsClient<$Result.GetResult<Prisma.$prepaid_alertsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prepaid_alerts.
     * @param {prepaid_alertsUpdateArgs} args - Arguments to update one Prepaid_alerts.
     * @example
     * // Update one Prepaid_alerts
     * const prepaid_alerts = await prisma.prepaid_alerts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prepaid_alertsUpdateArgs>(args: SelectSubset<T, prepaid_alertsUpdateArgs<ExtArgs>>): Prisma__prepaid_alertsClient<$Result.GetResult<Prisma.$prepaid_alertsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prepaid_alerts.
     * @param {prepaid_alertsDeleteManyArgs} args - Arguments to filter Prepaid_alerts to delete.
     * @example
     * // Delete a few Prepaid_alerts
     * const { count } = await prisma.prepaid_alerts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prepaid_alertsDeleteManyArgs>(args?: SelectSubset<T, prepaid_alertsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prepaid_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_alertsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prepaid_alerts
     * const prepaid_alerts = await prisma.prepaid_alerts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prepaid_alertsUpdateManyArgs>(args: SelectSubset<T, prepaid_alertsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prepaid_alerts.
     * @param {prepaid_alertsUpsertArgs} args - Arguments to update or create a Prepaid_alerts.
     * @example
     * // Update or create a Prepaid_alerts
     * const prepaid_alerts = await prisma.prepaid_alerts.upsert({
     *   create: {
     *     // ... data to create a Prepaid_alerts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prepaid_alerts we want to update
     *   }
     * })
     */
    upsert<T extends prepaid_alertsUpsertArgs>(args: SelectSubset<T, prepaid_alertsUpsertArgs<ExtArgs>>): Prisma__prepaid_alertsClient<$Result.GetResult<Prisma.$prepaid_alertsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prepaid_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_alertsCountArgs} args - Arguments to filter Prepaid_alerts to count.
     * @example
     * // Count the number of Prepaid_alerts
     * const count = await prisma.prepaid_alerts.count({
     *   where: {
     *     // ... the filter for the Prepaid_alerts we want to count
     *   }
     * })
    **/
    count<T extends prepaid_alertsCountArgs>(
      args?: Subset<T, prepaid_alertsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prepaid_alertsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prepaid_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prepaid_alertsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prepaid_alertsAggregateArgs>(args: Subset<T, Prepaid_alertsAggregateArgs>): Prisma.PrismaPromise<GetPrepaid_alertsAggregateType<T>>

    /**
     * Group by Prepaid_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_alertsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prepaid_alertsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prepaid_alertsGroupByArgs['orderBy'] }
        : { orderBy?: prepaid_alertsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prepaid_alertsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrepaid_alertsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prepaid_alerts model
   */
  readonly fields: prepaid_alertsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prepaid_alerts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prepaid_alertsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prepaid_accounts<T extends prepaid_accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, prepaid_accountsDefaultArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prepaid_alerts model
   */ 
  interface prepaid_alertsFieldRefs {
    readonly id: FieldRef<"prepaid_alerts", 'Int'>
    readonly accountId: FieldRef<"prepaid_alerts", 'Int'>
    readonly alertType: FieldRef<"prepaid_alerts", 'PrepaidAlertType'>
    readonly alertLevel: FieldRef<"prepaid_alerts", 'PrepaidAlertLevel'>
    readonly message: FieldRef<"prepaid_alerts", 'String'>
    readonly isRead: FieldRef<"prepaid_alerts", 'Boolean'>
    readonly readAt: FieldRef<"prepaid_alerts", 'DateTime'>
    readonly balanceAtAlert: FieldRef<"prepaid_alerts", 'Float'>
    readonly consumptionAtAlert: FieldRef<"prepaid_alerts", 'Float'>
    readonly thresholdValue: FieldRef<"prepaid_alerts", 'Float'>
    readonly createdAt: FieldRef<"prepaid_alerts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * prepaid_alerts findUnique
   */
  export type prepaid_alertsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_alerts to fetch.
     */
    where: prepaid_alertsWhereUniqueInput
  }

  /**
   * prepaid_alerts findUniqueOrThrow
   */
  export type prepaid_alertsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_alerts to fetch.
     */
    where: prepaid_alertsWhereUniqueInput
  }

  /**
   * prepaid_alerts findFirst
   */
  export type prepaid_alertsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_alerts to fetch.
     */
    where?: prepaid_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_alerts to fetch.
     */
    orderBy?: prepaid_alertsOrderByWithRelationInput | prepaid_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prepaid_alerts.
     */
    cursor?: prepaid_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prepaid_alerts.
     */
    distinct?: Prepaid_alertsScalarFieldEnum | Prepaid_alertsScalarFieldEnum[]
  }

  /**
   * prepaid_alerts findFirstOrThrow
   */
  export type prepaid_alertsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_alerts to fetch.
     */
    where?: prepaid_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_alerts to fetch.
     */
    orderBy?: prepaid_alertsOrderByWithRelationInput | prepaid_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prepaid_alerts.
     */
    cursor?: prepaid_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prepaid_alerts.
     */
    distinct?: Prepaid_alertsScalarFieldEnum | Prepaid_alertsScalarFieldEnum[]
  }

  /**
   * prepaid_alerts findMany
   */
  export type prepaid_alertsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_alerts to fetch.
     */
    where?: prepaid_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_alerts to fetch.
     */
    orderBy?: prepaid_alertsOrderByWithRelationInput | prepaid_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prepaid_alerts.
     */
    cursor?: prepaid_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_alerts.
     */
    skip?: number
    distinct?: Prepaid_alertsScalarFieldEnum | Prepaid_alertsScalarFieldEnum[]
  }

  /**
   * prepaid_alerts create
   */
  export type prepaid_alertsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsInclude<ExtArgs> | null
    /**
     * The data needed to create a prepaid_alerts.
     */
    data: XOR<prepaid_alertsCreateInput, prepaid_alertsUncheckedCreateInput>
  }

  /**
   * prepaid_alerts createMany
   */
  export type prepaid_alertsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prepaid_alerts.
     */
    data: prepaid_alertsCreateManyInput | prepaid_alertsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prepaid_alerts createManyAndReturn
   */
  export type prepaid_alertsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many prepaid_alerts.
     */
    data: prepaid_alertsCreateManyInput | prepaid_alertsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * prepaid_alerts update
   */
  export type prepaid_alertsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsInclude<ExtArgs> | null
    /**
     * The data needed to update a prepaid_alerts.
     */
    data: XOR<prepaid_alertsUpdateInput, prepaid_alertsUncheckedUpdateInput>
    /**
     * Choose, which prepaid_alerts to update.
     */
    where: prepaid_alertsWhereUniqueInput
  }

  /**
   * prepaid_alerts updateMany
   */
  export type prepaid_alertsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prepaid_alerts.
     */
    data: XOR<prepaid_alertsUpdateManyMutationInput, prepaid_alertsUncheckedUpdateManyInput>
    /**
     * Filter which prepaid_alerts to update
     */
    where?: prepaid_alertsWhereInput
  }

  /**
   * prepaid_alerts upsert
   */
  export type prepaid_alertsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsInclude<ExtArgs> | null
    /**
     * The filter to search for the prepaid_alerts to update in case it exists.
     */
    where: prepaid_alertsWhereUniqueInput
    /**
     * In case the prepaid_alerts found by the `where` argument doesn't exist, create a new prepaid_alerts with this data.
     */
    create: XOR<prepaid_alertsCreateInput, prepaid_alertsUncheckedCreateInput>
    /**
     * In case the prepaid_alerts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prepaid_alertsUpdateInput, prepaid_alertsUncheckedUpdateInput>
  }

  /**
   * prepaid_alerts delete
   */
  export type prepaid_alertsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsInclude<ExtArgs> | null
    /**
     * Filter which prepaid_alerts to delete.
     */
    where: prepaid_alertsWhereUniqueInput
  }

  /**
   * prepaid_alerts deleteMany
   */
  export type prepaid_alertsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prepaid_alerts to delete
     */
    where?: prepaid_alertsWhereInput
  }

  /**
   * prepaid_alerts without action
   */
  export type prepaid_alertsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_alerts
     */
    select?: prepaid_alertsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_alertsInclude<ExtArgs> | null
  }


  /**
   * Model prepaid_recharges
   */

  export type AggregatePrepaid_recharges = {
    _count: Prepaid_rechargesCountAggregateOutputType | null
    _avg: Prepaid_rechargesAvgAggregateOutputType | null
    _sum: Prepaid_rechargesSumAggregateOutputType | null
    _min: Prepaid_rechargesMinAggregateOutputType | null
    _max: Prepaid_rechargesMaxAggregateOutputType | null
  }

  export type Prepaid_rechargesAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    amount: number | null
    discountAmount: number | null
    bonusAmount: number | null
  }

  export type Prepaid_rechargesSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    amount: number | null
    discountAmount: number | null
    bonusAmount: number | null
  }

  export type Prepaid_rechargesMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    rechargeId: string | null
    amount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    gatewayName: string | null
    gatewayTransactionId: string | null
    rechargeType: $Enums.PrepaidRechargeType | null
    rechargeSource: $Enums.PrepaidRechargeSource | null
    isPromotional: boolean | null
    promotionalCode: string | null
    discountAmount: number | null
    bonusAmount: number | null
    receiptNumber: string | null
    receiptUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Prepaid_rechargesMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    rechargeId: string | null
    amount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    gatewayName: string | null
    gatewayTransactionId: string | null
    rechargeType: $Enums.PrepaidRechargeType | null
    rechargeSource: $Enums.PrepaidRechargeSource | null
    isPromotional: boolean | null
    promotionalCode: string | null
    discountAmount: number | null
    bonusAmount: number | null
    receiptNumber: string | null
    receiptUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Prepaid_rechargesCountAggregateOutputType = {
    id: number
    accountId: number
    rechargeId: number
    amount: number
    paymentMethod: number
    paymentStatus: number
    gatewayName: number
    gatewayTransactionId: number
    gatewayResponse: number
    rechargeType: number
    rechargeSource: number
    isPromotional: number
    promotionalCode: number
    discountAmount: number
    bonusAmount: number
    receiptNumber: number
    receiptUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Prepaid_rechargesAvgAggregateInputType = {
    id?: true
    accountId?: true
    amount?: true
    discountAmount?: true
    bonusAmount?: true
  }

  export type Prepaid_rechargesSumAggregateInputType = {
    id?: true
    accountId?: true
    amount?: true
    discountAmount?: true
    bonusAmount?: true
  }

  export type Prepaid_rechargesMinAggregateInputType = {
    id?: true
    accountId?: true
    rechargeId?: true
    amount?: true
    paymentMethod?: true
    paymentStatus?: true
    gatewayName?: true
    gatewayTransactionId?: true
    rechargeType?: true
    rechargeSource?: true
    isPromotional?: true
    promotionalCode?: true
    discountAmount?: true
    bonusAmount?: true
    receiptNumber?: true
    receiptUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Prepaid_rechargesMaxAggregateInputType = {
    id?: true
    accountId?: true
    rechargeId?: true
    amount?: true
    paymentMethod?: true
    paymentStatus?: true
    gatewayName?: true
    gatewayTransactionId?: true
    rechargeType?: true
    rechargeSource?: true
    isPromotional?: true
    promotionalCode?: true
    discountAmount?: true
    bonusAmount?: true
    receiptNumber?: true
    receiptUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Prepaid_rechargesCountAggregateInputType = {
    id?: true
    accountId?: true
    rechargeId?: true
    amount?: true
    paymentMethod?: true
    paymentStatus?: true
    gatewayName?: true
    gatewayTransactionId?: true
    gatewayResponse?: true
    rechargeType?: true
    rechargeSource?: true
    isPromotional?: true
    promotionalCode?: true
    discountAmount?: true
    bonusAmount?: true
    receiptNumber?: true
    receiptUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Prepaid_rechargesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prepaid_recharges to aggregate.
     */
    where?: prepaid_rechargesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_recharges to fetch.
     */
    orderBy?: prepaid_rechargesOrderByWithRelationInput | prepaid_rechargesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prepaid_rechargesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_recharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prepaid_recharges
    **/
    _count?: true | Prepaid_rechargesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prepaid_rechargesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prepaid_rechargesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prepaid_rechargesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prepaid_rechargesMaxAggregateInputType
  }

  export type GetPrepaid_rechargesAggregateType<T extends Prepaid_rechargesAggregateArgs> = {
        [P in keyof T & keyof AggregatePrepaid_recharges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrepaid_recharges[P]>
      : GetScalarType<T[P], AggregatePrepaid_recharges[P]>
  }




  export type prepaid_rechargesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prepaid_rechargesWhereInput
    orderBy?: prepaid_rechargesOrderByWithAggregationInput | prepaid_rechargesOrderByWithAggregationInput[]
    by: Prepaid_rechargesScalarFieldEnum[] | Prepaid_rechargesScalarFieldEnum
    having?: prepaid_rechargesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prepaid_rechargesCountAggregateInputType | true
    _avg?: Prepaid_rechargesAvgAggregateInputType
    _sum?: Prepaid_rechargesSumAggregateInputType
    _min?: Prepaid_rechargesMinAggregateInputType
    _max?: Prepaid_rechargesMaxAggregateInputType
  }

  export type Prepaid_rechargesGroupByOutputType = {
    id: number
    accountId: number
    rechargeId: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus: $Enums.PaymentStatus
    gatewayName: string | null
    gatewayTransactionId: string | null
    gatewayResponse: JsonValue | null
    rechargeType: $Enums.PrepaidRechargeType
    rechargeSource: $Enums.PrepaidRechargeSource
    isPromotional: boolean
    promotionalCode: string | null
    discountAmount: number
    bonusAmount: number
    receiptNumber: string | null
    receiptUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: Prepaid_rechargesCountAggregateOutputType | null
    _avg: Prepaid_rechargesAvgAggregateOutputType | null
    _sum: Prepaid_rechargesSumAggregateOutputType | null
    _min: Prepaid_rechargesMinAggregateOutputType | null
    _max: Prepaid_rechargesMaxAggregateOutputType | null
  }

  type GetPrepaid_rechargesGroupByPayload<T extends prepaid_rechargesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Prepaid_rechargesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prepaid_rechargesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prepaid_rechargesGroupByOutputType[P]>
            : GetScalarType<T[P], Prepaid_rechargesGroupByOutputType[P]>
        }
      >
    >


  export type prepaid_rechargesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    rechargeId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    gatewayName?: boolean
    gatewayTransactionId?: boolean
    gatewayResponse?: boolean
    rechargeType?: boolean
    rechargeSource?: boolean
    isPromotional?: boolean
    promotionalCode?: boolean
    discountAmount?: boolean
    bonusAmount?: boolean
    receiptNumber?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prepaid_recharges"]>

  export type prepaid_rechargesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    rechargeId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    gatewayName?: boolean
    gatewayTransactionId?: boolean
    gatewayResponse?: boolean
    rechargeType?: boolean
    rechargeSource?: boolean
    isPromotional?: boolean
    promotionalCode?: boolean
    discountAmount?: boolean
    bonusAmount?: boolean
    receiptNumber?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prepaid_recharges"]>

  export type prepaid_rechargesSelectScalar = {
    id?: boolean
    accountId?: boolean
    rechargeId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    gatewayName?: boolean
    gatewayTransactionId?: boolean
    gatewayResponse?: boolean
    rechargeType?: boolean
    rechargeSource?: boolean
    isPromotional?: boolean
    promotionalCode?: boolean
    discountAmount?: boolean
    bonusAmount?: boolean
    receiptNumber?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type prepaid_rechargesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
  }
  export type prepaid_rechargesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
  }

  export type $prepaid_rechargesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prepaid_recharges"
    objects: {
      prepaid_accounts: Prisma.$prepaid_accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accountId: number
      rechargeId: string
      amount: number
      paymentMethod: $Enums.PaymentMethod
      paymentStatus: $Enums.PaymentStatus
      gatewayName: string | null
      gatewayTransactionId: string | null
      gatewayResponse: Prisma.JsonValue | null
      rechargeType: $Enums.PrepaidRechargeType
      rechargeSource: $Enums.PrepaidRechargeSource
      isPromotional: boolean
      promotionalCode: string | null
      discountAmount: number
      bonusAmount: number
      receiptNumber: string | null
      receiptUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prepaid_recharges"]>
    composites: {}
  }

  type prepaid_rechargesGetPayload<S extends boolean | null | undefined | prepaid_rechargesDefaultArgs> = $Result.GetResult<Prisma.$prepaid_rechargesPayload, S>

  type prepaid_rechargesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<prepaid_rechargesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Prepaid_rechargesCountAggregateInputType | true
    }

  export interface prepaid_rechargesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prepaid_recharges'], meta: { name: 'prepaid_recharges' } }
    /**
     * Find zero or one Prepaid_recharges that matches the filter.
     * @param {prepaid_rechargesFindUniqueArgs} args - Arguments to find a Prepaid_recharges
     * @example
     * // Get one Prepaid_recharges
     * const prepaid_recharges = await prisma.prepaid_recharges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prepaid_rechargesFindUniqueArgs>(args: SelectSubset<T, prepaid_rechargesFindUniqueArgs<ExtArgs>>): Prisma__prepaid_rechargesClient<$Result.GetResult<Prisma.$prepaid_rechargesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prepaid_recharges that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {prepaid_rechargesFindUniqueOrThrowArgs} args - Arguments to find a Prepaid_recharges
     * @example
     * // Get one Prepaid_recharges
     * const prepaid_recharges = await prisma.prepaid_recharges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prepaid_rechargesFindUniqueOrThrowArgs>(args: SelectSubset<T, prepaid_rechargesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prepaid_rechargesClient<$Result.GetResult<Prisma.$prepaid_rechargesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prepaid_recharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_rechargesFindFirstArgs} args - Arguments to find a Prepaid_recharges
     * @example
     * // Get one Prepaid_recharges
     * const prepaid_recharges = await prisma.prepaid_recharges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prepaid_rechargesFindFirstArgs>(args?: SelectSubset<T, prepaid_rechargesFindFirstArgs<ExtArgs>>): Prisma__prepaid_rechargesClient<$Result.GetResult<Prisma.$prepaid_rechargesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prepaid_recharges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_rechargesFindFirstOrThrowArgs} args - Arguments to find a Prepaid_recharges
     * @example
     * // Get one Prepaid_recharges
     * const prepaid_recharges = await prisma.prepaid_recharges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prepaid_rechargesFindFirstOrThrowArgs>(args?: SelectSubset<T, prepaid_rechargesFindFirstOrThrowArgs<ExtArgs>>): Prisma__prepaid_rechargesClient<$Result.GetResult<Prisma.$prepaid_rechargesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prepaid_recharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_rechargesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prepaid_recharges
     * const prepaid_recharges = await prisma.prepaid_recharges.findMany()
     * 
     * // Get first 10 Prepaid_recharges
     * const prepaid_recharges = await prisma.prepaid_recharges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prepaid_rechargesWithIdOnly = await prisma.prepaid_recharges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends prepaid_rechargesFindManyArgs>(args?: SelectSubset<T, prepaid_rechargesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_rechargesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prepaid_recharges.
     * @param {prepaid_rechargesCreateArgs} args - Arguments to create a Prepaid_recharges.
     * @example
     * // Create one Prepaid_recharges
     * const Prepaid_recharges = await prisma.prepaid_recharges.create({
     *   data: {
     *     // ... data to create a Prepaid_recharges
     *   }
     * })
     * 
     */
    create<T extends prepaid_rechargesCreateArgs>(args: SelectSubset<T, prepaid_rechargesCreateArgs<ExtArgs>>): Prisma__prepaid_rechargesClient<$Result.GetResult<Prisma.$prepaid_rechargesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prepaid_recharges.
     * @param {prepaid_rechargesCreateManyArgs} args - Arguments to create many Prepaid_recharges.
     * @example
     * // Create many Prepaid_recharges
     * const prepaid_recharges = await prisma.prepaid_recharges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prepaid_rechargesCreateManyArgs>(args?: SelectSubset<T, prepaid_rechargesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prepaid_recharges and returns the data saved in the database.
     * @param {prepaid_rechargesCreateManyAndReturnArgs} args - Arguments to create many Prepaid_recharges.
     * @example
     * // Create many Prepaid_recharges
     * const prepaid_recharges = await prisma.prepaid_recharges.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prepaid_recharges and only return the `id`
     * const prepaid_rechargesWithIdOnly = await prisma.prepaid_recharges.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends prepaid_rechargesCreateManyAndReturnArgs>(args?: SelectSubset<T, prepaid_rechargesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_rechargesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prepaid_recharges.
     * @param {prepaid_rechargesDeleteArgs} args - Arguments to delete one Prepaid_recharges.
     * @example
     * // Delete one Prepaid_recharges
     * const Prepaid_recharges = await prisma.prepaid_recharges.delete({
     *   where: {
     *     // ... filter to delete one Prepaid_recharges
     *   }
     * })
     * 
     */
    delete<T extends prepaid_rechargesDeleteArgs>(args: SelectSubset<T, prepaid_rechargesDeleteArgs<ExtArgs>>): Prisma__prepaid_rechargesClient<$Result.GetResult<Prisma.$prepaid_rechargesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prepaid_recharges.
     * @param {prepaid_rechargesUpdateArgs} args - Arguments to update one Prepaid_recharges.
     * @example
     * // Update one Prepaid_recharges
     * const prepaid_recharges = await prisma.prepaid_recharges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prepaid_rechargesUpdateArgs>(args: SelectSubset<T, prepaid_rechargesUpdateArgs<ExtArgs>>): Prisma__prepaid_rechargesClient<$Result.GetResult<Prisma.$prepaid_rechargesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prepaid_recharges.
     * @param {prepaid_rechargesDeleteManyArgs} args - Arguments to filter Prepaid_recharges to delete.
     * @example
     * // Delete a few Prepaid_recharges
     * const { count } = await prisma.prepaid_recharges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prepaid_rechargesDeleteManyArgs>(args?: SelectSubset<T, prepaid_rechargesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prepaid_recharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_rechargesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prepaid_recharges
     * const prepaid_recharges = await prisma.prepaid_recharges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prepaid_rechargesUpdateManyArgs>(args: SelectSubset<T, prepaid_rechargesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prepaid_recharges.
     * @param {prepaid_rechargesUpsertArgs} args - Arguments to update or create a Prepaid_recharges.
     * @example
     * // Update or create a Prepaid_recharges
     * const prepaid_recharges = await prisma.prepaid_recharges.upsert({
     *   create: {
     *     // ... data to create a Prepaid_recharges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prepaid_recharges we want to update
     *   }
     * })
     */
    upsert<T extends prepaid_rechargesUpsertArgs>(args: SelectSubset<T, prepaid_rechargesUpsertArgs<ExtArgs>>): Prisma__prepaid_rechargesClient<$Result.GetResult<Prisma.$prepaid_rechargesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prepaid_recharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_rechargesCountArgs} args - Arguments to filter Prepaid_recharges to count.
     * @example
     * // Count the number of Prepaid_recharges
     * const count = await prisma.prepaid_recharges.count({
     *   where: {
     *     // ... the filter for the Prepaid_recharges we want to count
     *   }
     * })
    **/
    count<T extends prepaid_rechargesCountArgs>(
      args?: Subset<T, prepaid_rechargesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prepaid_rechargesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prepaid_recharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prepaid_rechargesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prepaid_rechargesAggregateArgs>(args: Subset<T, Prepaid_rechargesAggregateArgs>): Prisma.PrismaPromise<GetPrepaid_rechargesAggregateType<T>>

    /**
     * Group by Prepaid_recharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_rechargesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prepaid_rechargesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prepaid_rechargesGroupByArgs['orderBy'] }
        : { orderBy?: prepaid_rechargesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prepaid_rechargesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrepaid_rechargesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prepaid_recharges model
   */
  readonly fields: prepaid_rechargesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prepaid_recharges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prepaid_rechargesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prepaid_accounts<T extends prepaid_accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, prepaid_accountsDefaultArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prepaid_recharges model
   */ 
  interface prepaid_rechargesFieldRefs {
    readonly id: FieldRef<"prepaid_recharges", 'Int'>
    readonly accountId: FieldRef<"prepaid_recharges", 'Int'>
    readonly rechargeId: FieldRef<"prepaid_recharges", 'String'>
    readonly amount: FieldRef<"prepaid_recharges", 'Float'>
    readonly paymentMethod: FieldRef<"prepaid_recharges", 'PaymentMethod'>
    readonly paymentStatus: FieldRef<"prepaid_recharges", 'PaymentStatus'>
    readonly gatewayName: FieldRef<"prepaid_recharges", 'String'>
    readonly gatewayTransactionId: FieldRef<"prepaid_recharges", 'String'>
    readonly gatewayResponse: FieldRef<"prepaid_recharges", 'Json'>
    readonly rechargeType: FieldRef<"prepaid_recharges", 'PrepaidRechargeType'>
    readonly rechargeSource: FieldRef<"prepaid_recharges", 'PrepaidRechargeSource'>
    readonly isPromotional: FieldRef<"prepaid_recharges", 'Boolean'>
    readonly promotionalCode: FieldRef<"prepaid_recharges", 'String'>
    readonly discountAmount: FieldRef<"prepaid_recharges", 'Float'>
    readonly bonusAmount: FieldRef<"prepaid_recharges", 'Float'>
    readonly receiptNumber: FieldRef<"prepaid_recharges", 'String'>
    readonly receiptUrl: FieldRef<"prepaid_recharges", 'String'>
    readonly createdAt: FieldRef<"prepaid_recharges", 'DateTime'>
    readonly updatedAt: FieldRef<"prepaid_recharges", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * prepaid_recharges findUnique
   */
  export type prepaid_rechargesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_recharges to fetch.
     */
    where: prepaid_rechargesWhereUniqueInput
  }

  /**
   * prepaid_recharges findUniqueOrThrow
   */
  export type prepaid_rechargesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_recharges to fetch.
     */
    where: prepaid_rechargesWhereUniqueInput
  }

  /**
   * prepaid_recharges findFirst
   */
  export type prepaid_rechargesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_recharges to fetch.
     */
    where?: prepaid_rechargesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_recharges to fetch.
     */
    orderBy?: prepaid_rechargesOrderByWithRelationInput | prepaid_rechargesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prepaid_recharges.
     */
    cursor?: prepaid_rechargesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_recharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prepaid_recharges.
     */
    distinct?: Prepaid_rechargesScalarFieldEnum | Prepaid_rechargesScalarFieldEnum[]
  }

  /**
   * prepaid_recharges findFirstOrThrow
   */
  export type prepaid_rechargesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_recharges to fetch.
     */
    where?: prepaid_rechargesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_recharges to fetch.
     */
    orderBy?: prepaid_rechargesOrderByWithRelationInput | prepaid_rechargesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prepaid_recharges.
     */
    cursor?: prepaid_rechargesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_recharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prepaid_recharges.
     */
    distinct?: Prepaid_rechargesScalarFieldEnum | Prepaid_rechargesScalarFieldEnum[]
  }

  /**
   * prepaid_recharges findMany
   */
  export type prepaid_rechargesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_recharges to fetch.
     */
    where?: prepaid_rechargesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_recharges to fetch.
     */
    orderBy?: prepaid_rechargesOrderByWithRelationInput | prepaid_rechargesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prepaid_recharges.
     */
    cursor?: prepaid_rechargesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_recharges.
     */
    skip?: number
    distinct?: Prepaid_rechargesScalarFieldEnum | Prepaid_rechargesScalarFieldEnum[]
  }

  /**
   * prepaid_recharges create
   */
  export type prepaid_rechargesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesInclude<ExtArgs> | null
    /**
     * The data needed to create a prepaid_recharges.
     */
    data: XOR<prepaid_rechargesCreateInput, prepaid_rechargesUncheckedCreateInput>
  }

  /**
   * prepaid_recharges createMany
   */
  export type prepaid_rechargesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prepaid_recharges.
     */
    data: prepaid_rechargesCreateManyInput | prepaid_rechargesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prepaid_recharges createManyAndReturn
   */
  export type prepaid_rechargesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many prepaid_recharges.
     */
    data: prepaid_rechargesCreateManyInput | prepaid_rechargesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * prepaid_recharges update
   */
  export type prepaid_rechargesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesInclude<ExtArgs> | null
    /**
     * The data needed to update a prepaid_recharges.
     */
    data: XOR<prepaid_rechargesUpdateInput, prepaid_rechargesUncheckedUpdateInput>
    /**
     * Choose, which prepaid_recharges to update.
     */
    where: prepaid_rechargesWhereUniqueInput
  }

  /**
   * prepaid_recharges updateMany
   */
  export type prepaid_rechargesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prepaid_recharges.
     */
    data: XOR<prepaid_rechargesUpdateManyMutationInput, prepaid_rechargesUncheckedUpdateManyInput>
    /**
     * Filter which prepaid_recharges to update
     */
    where?: prepaid_rechargesWhereInput
  }

  /**
   * prepaid_recharges upsert
   */
  export type prepaid_rechargesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesInclude<ExtArgs> | null
    /**
     * The filter to search for the prepaid_recharges to update in case it exists.
     */
    where: prepaid_rechargesWhereUniqueInput
    /**
     * In case the prepaid_recharges found by the `where` argument doesn't exist, create a new prepaid_recharges with this data.
     */
    create: XOR<prepaid_rechargesCreateInput, prepaid_rechargesUncheckedCreateInput>
    /**
     * In case the prepaid_recharges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prepaid_rechargesUpdateInput, prepaid_rechargesUncheckedUpdateInput>
  }

  /**
   * prepaid_recharges delete
   */
  export type prepaid_rechargesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesInclude<ExtArgs> | null
    /**
     * Filter which prepaid_recharges to delete.
     */
    where: prepaid_rechargesWhereUniqueInput
  }

  /**
   * prepaid_recharges deleteMany
   */
  export type prepaid_rechargesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prepaid_recharges to delete
     */
    where?: prepaid_rechargesWhereInput
  }

  /**
   * prepaid_recharges without action
   */
  export type prepaid_rechargesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_recharges
     */
    select?: prepaid_rechargesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_rechargesInclude<ExtArgs> | null
  }


  /**
   * Model prepaid_transactions
   */

  export type AggregatePrepaid_transactions = {
    _count: Prepaid_transactionsCountAggregateOutputType | null
    _avg: Prepaid_transactionsAvgAggregateOutputType | null
    _sum: Prepaid_transactionsSumAggregateOutputType | null
    _min: Prepaid_transactionsMinAggregateOutputType | null
    _max: Prepaid_transactionsMaxAggregateOutputType | null
  }

  export type Prepaid_transactionsAvgAggregateOutputType = {
    id: number | null
    accountId: number | null
    amount: number | null
    balanceBefore: number | null
    balanceAfter: number | null
    consumptionKWh: number | null
    ratePerUnit: number | null
    fixedCharges: number | null
    readingId: number | null
  }

  export type Prepaid_transactionsSumAggregateOutputType = {
    id: number | null
    accountId: number | null
    amount: number | null
    balanceBefore: number | null
    balanceAfter: number | null
    consumptionKWh: number | null
    ratePerUnit: number | null
    fixedCharges: number | null
    readingId: number | null
  }

  export type Prepaid_transactionsMinAggregateOutputType = {
    id: number | null
    accountId: number | null
    transactionId: string | null
    transactionType: $Enums.PrepaidTransactionType | null
    amount: number | null
    balanceBefore: number | null
    balanceAfter: number | null
    consumptionKWh: number | null
    ratePerUnit: number | null
    fixedCharges: number | null
    readingId: number | null
    status: $Enums.PrepaidTransactionStatus | null
    failureReason: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Prepaid_transactionsMaxAggregateOutputType = {
    id: number | null
    accountId: number | null
    transactionId: string | null
    transactionType: $Enums.PrepaidTransactionType | null
    amount: number | null
    balanceBefore: number | null
    balanceAfter: number | null
    consumptionKWh: number | null
    ratePerUnit: number | null
    fixedCharges: number | null
    readingId: number | null
    status: $Enums.PrepaidTransactionStatus | null
    failureReason: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Prepaid_transactionsCountAggregateOutputType = {
    id: number
    accountId: number
    transactionId: number
    transactionType: number
    amount: number
    balanceBefore: number
    balanceAfter: number
    consumptionKWh: number
    ratePerUnit: number
    fixedCharges: number
    taxes: number
    readingId: number
    status: number
    failureReason: number
    description: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Prepaid_transactionsAvgAggregateInputType = {
    id?: true
    accountId?: true
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
    consumptionKWh?: true
    ratePerUnit?: true
    fixedCharges?: true
    readingId?: true
  }

  export type Prepaid_transactionsSumAggregateInputType = {
    id?: true
    accountId?: true
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
    consumptionKWh?: true
    ratePerUnit?: true
    fixedCharges?: true
    readingId?: true
  }

  export type Prepaid_transactionsMinAggregateInputType = {
    id?: true
    accountId?: true
    transactionId?: true
    transactionType?: true
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
    consumptionKWh?: true
    ratePerUnit?: true
    fixedCharges?: true
    readingId?: true
    status?: true
    failureReason?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Prepaid_transactionsMaxAggregateInputType = {
    id?: true
    accountId?: true
    transactionId?: true
    transactionType?: true
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
    consumptionKWh?: true
    ratePerUnit?: true
    fixedCharges?: true
    readingId?: true
    status?: true
    failureReason?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Prepaid_transactionsCountAggregateInputType = {
    id?: true
    accountId?: true
    transactionId?: true
    transactionType?: true
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
    consumptionKWh?: true
    ratePerUnit?: true
    fixedCharges?: true
    taxes?: true
    readingId?: true
    status?: true
    failureReason?: true
    description?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Prepaid_transactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prepaid_transactions to aggregate.
     */
    where?: prepaid_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_transactions to fetch.
     */
    orderBy?: prepaid_transactionsOrderByWithRelationInput | prepaid_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prepaid_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prepaid_transactions
    **/
    _count?: true | Prepaid_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prepaid_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prepaid_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prepaid_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prepaid_transactionsMaxAggregateInputType
  }

  export type GetPrepaid_transactionsAggregateType<T extends Prepaid_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePrepaid_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrepaid_transactions[P]>
      : GetScalarType<T[P], AggregatePrepaid_transactions[P]>
  }




  export type prepaid_transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prepaid_transactionsWhereInput
    orderBy?: prepaid_transactionsOrderByWithAggregationInput | prepaid_transactionsOrderByWithAggregationInput[]
    by: Prepaid_transactionsScalarFieldEnum[] | Prepaid_transactionsScalarFieldEnum
    having?: prepaid_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prepaid_transactionsCountAggregateInputType | true
    _avg?: Prepaid_transactionsAvgAggregateInputType
    _sum?: Prepaid_transactionsSumAggregateInputType
    _min?: Prepaid_transactionsMinAggregateInputType
    _max?: Prepaid_transactionsMaxAggregateInputType
  }

  export type Prepaid_transactionsGroupByOutputType = {
    id: number
    accountId: number
    transactionId: string
    transactionType: $Enums.PrepaidTransactionType
    amount: number
    balanceBefore: number
    balanceAfter: number
    consumptionKWh: number | null
    ratePerUnit: number | null
    fixedCharges: number | null
    taxes: JsonValue | null
    readingId: number | null
    status: $Enums.PrepaidTransactionStatus
    failureReason: string | null
    description: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: Prepaid_transactionsCountAggregateOutputType | null
    _avg: Prepaid_transactionsAvgAggregateOutputType | null
    _sum: Prepaid_transactionsSumAggregateOutputType | null
    _min: Prepaid_transactionsMinAggregateOutputType | null
    _max: Prepaid_transactionsMaxAggregateOutputType | null
  }

  type GetPrepaid_transactionsGroupByPayload<T extends prepaid_transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Prepaid_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prepaid_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prepaid_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Prepaid_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type prepaid_transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    transactionId?: boolean
    transactionType?: boolean
    amount?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    consumptionKWh?: boolean
    ratePerUnit?: boolean
    fixedCharges?: boolean
    taxes?: boolean
    readingId?: boolean
    status?: boolean
    failureReason?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
    meter_readings?: boolean | prepaid_transactions$meter_readingsArgs<ExtArgs>
  }, ExtArgs["result"]["prepaid_transactions"]>

  export type prepaid_transactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    transactionId?: boolean
    transactionType?: boolean
    amount?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    consumptionKWh?: boolean
    ratePerUnit?: boolean
    fixedCharges?: boolean
    taxes?: boolean
    readingId?: boolean
    status?: boolean
    failureReason?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
    meter_readings?: boolean | prepaid_transactions$meter_readingsArgs<ExtArgs>
  }, ExtArgs["result"]["prepaid_transactions"]>

  export type prepaid_transactionsSelectScalar = {
    id?: boolean
    accountId?: boolean
    transactionId?: boolean
    transactionType?: boolean
    amount?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    consumptionKWh?: boolean
    ratePerUnit?: boolean
    fixedCharges?: boolean
    taxes?: boolean
    readingId?: boolean
    status?: boolean
    failureReason?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type prepaid_transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
    meter_readings?: boolean | prepaid_transactions$meter_readingsArgs<ExtArgs>
  }
  export type prepaid_transactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prepaid_accounts?: boolean | prepaid_accountsDefaultArgs<ExtArgs>
    meter_readings?: boolean | prepaid_transactions$meter_readingsArgs<ExtArgs>
  }

  export type $prepaid_transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prepaid_transactions"
    objects: {
      prepaid_accounts: Prisma.$prepaid_accountsPayload<ExtArgs>
      meter_readings: Prisma.$meter_readingsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accountId: number
      transactionId: string
      transactionType: $Enums.PrepaidTransactionType
      amount: number
      balanceBefore: number
      balanceAfter: number
      consumptionKWh: number | null
      ratePerUnit: number | null
      fixedCharges: number | null
      taxes: Prisma.JsonValue | null
      readingId: number | null
      status: $Enums.PrepaidTransactionStatus
      failureReason: string | null
      description: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prepaid_transactions"]>
    composites: {}
  }

  type prepaid_transactionsGetPayload<S extends boolean | null | undefined | prepaid_transactionsDefaultArgs> = $Result.GetResult<Prisma.$prepaid_transactionsPayload, S>

  type prepaid_transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<prepaid_transactionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Prepaid_transactionsCountAggregateInputType | true
    }

  export interface prepaid_transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prepaid_transactions'], meta: { name: 'prepaid_transactions' } }
    /**
     * Find zero or one Prepaid_transactions that matches the filter.
     * @param {prepaid_transactionsFindUniqueArgs} args - Arguments to find a Prepaid_transactions
     * @example
     * // Get one Prepaid_transactions
     * const prepaid_transactions = await prisma.prepaid_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prepaid_transactionsFindUniqueArgs>(args: SelectSubset<T, prepaid_transactionsFindUniqueArgs<ExtArgs>>): Prisma__prepaid_transactionsClient<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prepaid_transactions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {prepaid_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Prepaid_transactions
     * @example
     * // Get one Prepaid_transactions
     * const prepaid_transactions = await prisma.prepaid_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prepaid_transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, prepaid_transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prepaid_transactionsClient<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prepaid_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_transactionsFindFirstArgs} args - Arguments to find a Prepaid_transactions
     * @example
     * // Get one Prepaid_transactions
     * const prepaid_transactions = await prisma.prepaid_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prepaid_transactionsFindFirstArgs>(args?: SelectSubset<T, prepaid_transactionsFindFirstArgs<ExtArgs>>): Prisma__prepaid_transactionsClient<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prepaid_transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_transactionsFindFirstOrThrowArgs} args - Arguments to find a Prepaid_transactions
     * @example
     * // Get one Prepaid_transactions
     * const prepaid_transactions = await prisma.prepaid_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prepaid_transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, prepaid_transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__prepaid_transactionsClient<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prepaid_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prepaid_transactions
     * const prepaid_transactions = await prisma.prepaid_transactions.findMany()
     * 
     * // Get first 10 Prepaid_transactions
     * const prepaid_transactions = await prisma.prepaid_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prepaid_transactionsWithIdOnly = await prisma.prepaid_transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends prepaid_transactionsFindManyArgs>(args?: SelectSubset<T, prepaid_transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prepaid_transactions.
     * @param {prepaid_transactionsCreateArgs} args - Arguments to create a Prepaid_transactions.
     * @example
     * // Create one Prepaid_transactions
     * const Prepaid_transactions = await prisma.prepaid_transactions.create({
     *   data: {
     *     // ... data to create a Prepaid_transactions
     *   }
     * })
     * 
     */
    create<T extends prepaid_transactionsCreateArgs>(args: SelectSubset<T, prepaid_transactionsCreateArgs<ExtArgs>>): Prisma__prepaid_transactionsClient<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prepaid_transactions.
     * @param {prepaid_transactionsCreateManyArgs} args - Arguments to create many Prepaid_transactions.
     * @example
     * // Create many Prepaid_transactions
     * const prepaid_transactions = await prisma.prepaid_transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prepaid_transactionsCreateManyArgs>(args?: SelectSubset<T, prepaid_transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prepaid_transactions and returns the data saved in the database.
     * @param {prepaid_transactionsCreateManyAndReturnArgs} args - Arguments to create many Prepaid_transactions.
     * @example
     * // Create many Prepaid_transactions
     * const prepaid_transactions = await prisma.prepaid_transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prepaid_transactions and only return the `id`
     * const prepaid_transactionsWithIdOnly = await prisma.prepaid_transactions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends prepaid_transactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, prepaid_transactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prepaid_transactions.
     * @param {prepaid_transactionsDeleteArgs} args - Arguments to delete one Prepaid_transactions.
     * @example
     * // Delete one Prepaid_transactions
     * const Prepaid_transactions = await prisma.prepaid_transactions.delete({
     *   where: {
     *     // ... filter to delete one Prepaid_transactions
     *   }
     * })
     * 
     */
    delete<T extends prepaid_transactionsDeleteArgs>(args: SelectSubset<T, prepaid_transactionsDeleteArgs<ExtArgs>>): Prisma__prepaid_transactionsClient<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prepaid_transactions.
     * @param {prepaid_transactionsUpdateArgs} args - Arguments to update one Prepaid_transactions.
     * @example
     * // Update one Prepaid_transactions
     * const prepaid_transactions = await prisma.prepaid_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prepaid_transactionsUpdateArgs>(args: SelectSubset<T, prepaid_transactionsUpdateArgs<ExtArgs>>): Prisma__prepaid_transactionsClient<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prepaid_transactions.
     * @param {prepaid_transactionsDeleteManyArgs} args - Arguments to filter Prepaid_transactions to delete.
     * @example
     * // Delete a few Prepaid_transactions
     * const { count } = await prisma.prepaid_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prepaid_transactionsDeleteManyArgs>(args?: SelectSubset<T, prepaid_transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prepaid_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prepaid_transactions
     * const prepaid_transactions = await prisma.prepaid_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prepaid_transactionsUpdateManyArgs>(args: SelectSubset<T, prepaid_transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prepaid_transactions.
     * @param {prepaid_transactionsUpsertArgs} args - Arguments to update or create a Prepaid_transactions.
     * @example
     * // Update or create a Prepaid_transactions
     * const prepaid_transactions = await prisma.prepaid_transactions.upsert({
     *   create: {
     *     // ... data to create a Prepaid_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prepaid_transactions we want to update
     *   }
     * })
     */
    upsert<T extends prepaid_transactionsUpsertArgs>(args: SelectSubset<T, prepaid_transactionsUpsertArgs<ExtArgs>>): Prisma__prepaid_transactionsClient<$Result.GetResult<Prisma.$prepaid_transactionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prepaid_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_transactionsCountArgs} args - Arguments to filter Prepaid_transactions to count.
     * @example
     * // Count the number of Prepaid_transactions
     * const count = await prisma.prepaid_transactions.count({
     *   where: {
     *     // ... the filter for the Prepaid_transactions we want to count
     *   }
     * })
    **/
    count<T extends prepaid_transactionsCountArgs>(
      args?: Subset<T, prepaid_transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prepaid_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prepaid_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prepaid_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prepaid_transactionsAggregateArgs>(args: Subset<T, Prepaid_transactionsAggregateArgs>): Prisma.PrismaPromise<GetPrepaid_transactionsAggregateType<T>>

    /**
     * Group by Prepaid_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prepaid_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prepaid_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prepaid_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: prepaid_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prepaid_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrepaid_transactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prepaid_transactions model
   */
  readonly fields: prepaid_transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prepaid_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prepaid_transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prepaid_accounts<T extends prepaid_accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, prepaid_accountsDefaultArgs<ExtArgs>>): Prisma__prepaid_accountsClient<$Result.GetResult<Prisma.$prepaid_accountsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    meter_readings<T extends prepaid_transactions$meter_readingsArgs<ExtArgs> = {}>(args?: Subset<T, prepaid_transactions$meter_readingsArgs<ExtArgs>>): Prisma__meter_readingsClient<$Result.GetResult<Prisma.$meter_readingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prepaid_transactions model
   */ 
  interface prepaid_transactionsFieldRefs {
    readonly id: FieldRef<"prepaid_transactions", 'Int'>
    readonly accountId: FieldRef<"prepaid_transactions", 'Int'>
    readonly transactionId: FieldRef<"prepaid_transactions", 'String'>
    readonly transactionType: FieldRef<"prepaid_transactions", 'PrepaidTransactionType'>
    readonly amount: FieldRef<"prepaid_transactions", 'Float'>
    readonly balanceBefore: FieldRef<"prepaid_transactions", 'Float'>
    readonly balanceAfter: FieldRef<"prepaid_transactions", 'Float'>
    readonly consumptionKWh: FieldRef<"prepaid_transactions", 'Float'>
    readonly ratePerUnit: FieldRef<"prepaid_transactions", 'Float'>
    readonly fixedCharges: FieldRef<"prepaid_transactions", 'Float'>
    readonly taxes: FieldRef<"prepaid_transactions", 'Json'>
    readonly readingId: FieldRef<"prepaid_transactions", 'Int'>
    readonly status: FieldRef<"prepaid_transactions", 'PrepaidTransactionStatus'>
    readonly failureReason: FieldRef<"prepaid_transactions", 'String'>
    readonly description: FieldRef<"prepaid_transactions", 'String'>
    readonly metadata: FieldRef<"prepaid_transactions", 'Json'>
    readonly createdAt: FieldRef<"prepaid_transactions", 'DateTime'>
    readonly updatedAt: FieldRef<"prepaid_transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * prepaid_transactions findUnique
   */
  export type prepaid_transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_transactions to fetch.
     */
    where: prepaid_transactionsWhereUniqueInput
  }

  /**
   * prepaid_transactions findUniqueOrThrow
   */
  export type prepaid_transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_transactions to fetch.
     */
    where: prepaid_transactionsWhereUniqueInput
  }

  /**
   * prepaid_transactions findFirst
   */
  export type prepaid_transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_transactions to fetch.
     */
    where?: prepaid_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_transactions to fetch.
     */
    orderBy?: prepaid_transactionsOrderByWithRelationInput | prepaid_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prepaid_transactions.
     */
    cursor?: prepaid_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prepaid_transactions.
     */
    distinct?: Prepaid_transactionsScalarFieldEnum | Prepaid_transactionsScalarFieldEnum[]
  }

  /**
   * prepaid_transactions findFirstOrThrow
   */
  export type prepaid_transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_transactions to fetch.
     */
    where?: prepaid_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_transactions to fetch.
     */
    orderBy?: prepaid_transactionsOrderByWithRelationInput | prepaid_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prepaid_transactions.
     */
    cursor?: prepaid_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prepaid_transactions.
     */
    distinct?: Prepaid_transactionsScalarFieldEnum | Prepaid_transactionsScalarFieldEnum[]
  }

  /**
   * prepaid_transactions findMany
   */
  export type prepaid_transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which prepaid_transactions to fetch.
     */
    where?: prepaid_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prepaid_transactions to fetch.
     */
    orderBy?: prepaid_transactionsOrderByWithRelationInput | prepaid_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prepaid_transactions.
     */
    cursor?: prepaid_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prepaid_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prepaid_transactions.
     */
    skip?: number
    distinct?: Prepaid_transactionsScalarFieldEnum | Prepaid_transactionsScalarFieldEnum[]
  }

  /**
   * prepaid_transactions create
   */
  export type prepaid_transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a prepaid_transactions.
     */
    data: XOR<prepaid_transactionsCreateInput, prepaid_transactionsUncheckedCreateInput>
  }

  /**
   * prepaid_transactions createMany
   */
  export type prepaid_transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prepaid_transactions.
     */
    data: prepaid_transactionsCreateManyInput | prepaid_transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prepaid_transactions createManyAndReturn
   */
  export type prepaid_transactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many prepaid_transactions.
     */
    data: prepaid_transactionsCreateManyInput | prepaid_transactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * prepaid_transactions update
   */
  export type prepaid_transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a prepaid_transactions.
     */
    data: XOR<prepaid_transactionsUpdateInput, prepaid_transactionsUncheckedUpdateInput>
    /**
     * Choose, which prepaid_transactions to update.
     */
    where: prepaid_transactionsWhereUniqueInput
  }

  /**
   * prepaid_transactions updateMany
   */
  export type prepaid_transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prepaid_transactions.
     */
    data: XOR<prepaid_transactionsUpdateManyMutationInput, prepaid_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which prepaid_transactions to update
     */
    where?: prepaid_transactionsWhereInput
  }

  /**
   * prepaid_transactions upsert
   */
  export type prepaid_transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the prepaid_transactions to update in case it exists.
     */
    where: prepaid_transactionsWhereUniqueInput
    /**
     * In case the prepaid_transactions found by the `where` argument doesn't exist, create a new prepaid_transactions with this data.
     */
    create: XOR<prepaid_transactionsCreateInput, prepaid_transactionsUncheckedCreateInput>
    /**
     * In case the prepaid_transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prepaid_transactionsUpdateInput, prepaid_transactionsUncheckedUpdateInput>
  }

  /**
   * prepaid_transactions delete
   */
  export type prepaid_transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
    /**
     * Filter which prepaid_transactions to delete.
     */
    where: prepaid_transactionsWhereUniqueInput
  }

  /**
   * prepaid_transactions deleteMany
   */
  export type prepaid_transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prepaid_transactions to delete
     */
    where?: prepaid_transactionsWhereInput
  }

  /**
   * prepaid_transactions.meter_readings
   */
  export type prepaid_transactions$meter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meter_readings
     */
    select?: meter_readingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meter_readingsInclude<ExtArgs> | null
    where?: meter_readingsWhereInput
  }

  /**
   * prepaid_transactions without action
   */
  export type prepaid_transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prepaid_transactions
     */
    select?: prepaid_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prepaid_transactionsInclude<ExtArgs> | null
  }


  /**
   * Model tamper_code_desc
   */

  export type AggregateTamper_code_desc = {
    _count: Tamper_code_descCountAggregateOutputType | null
    _avg: Tamper_code_descAvgAggregateOutputType | null
    _sum: Tamper_code_descSumAggregateOutputType | null
    _min: Tamper_code_descMinAggregateOutputType | null
    _max: Tamper_code_descMaxAggregateOutputType | null
  }

  export type Tamper_code_descAvgAggregateOutputType = {
    id: number | null
    tamperCode: number | null
  }

  export type Tamper_code_descSumAggregateOutputType = {
    id: number | null
    tamperCode: number | null
  }

  export type Tamper_code_descMinAggregateOutputType = {
    id: number | null
    tamperCode: number | null
    tamperDesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tamper_code_descMaxAggregateOutputType = {
    id: number | null
    tamperCode: number | null
    tamperDesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tamper_code_descCountAggregateOutputType = {
    id: number
    tamperCode: number
    tamperDesc: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tamper_code_descAvgAggregateInputType = {
    id?: true
    tamperCode?: true
  }

  export type Tamper_code_descSumAggregateInputType = {
    id?: true
    tamperCode?: true
  }

  export type Tamper_code_descMinAggregateInputType = {
    id?: true
    tamperCode?: true
    tamperDesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tamper_code_descMaxAggregateInputType = {
    id?: true
    tamperCode?: true
    tamperDesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tamper_code_descCountAggregateInputType = {
    id?: true
    tamperCode?: true
    tamperDesc?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tamper_code_descAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tamper_code_desc to aggregate.
     */
    where?: tamper_code_descWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tamper_code_descs to fetch.
     */
    orderBy?: tamper_code_descOrderByWithRelationInput | tamper_code_descOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tamper_code_descWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tamper_code_descs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tamper_code_descs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tamper_code_descs
    **/
    _count?: true | Tamper_code_descCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tamper_code_descAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tamper_code_descSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tamper_code_descMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tamper_code_descMaxAggregateInputType
  }

  export type GetTamper_code_descAggregateType<T extends Tamper_code_descAggregateArgs> = {
        [P in keyof T & keyof AggregateTamper_code_desc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTamper_code_desc[P]>
      : GetScalarType<T[P], AggregateTamper_code_desc[P]>
  }




  export type tamper_code_descGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tamper_code_descWhereInput
    orderBy?: tamper_code_descOrderByWithAggregationInput | tamper_code_descOrderByWithAggregationInput[]
    by: Tamper_code_descScalarFieldEnum[] | Tamper_code_descScalarFieldEnum
    having?: tamper_code_descScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tamper_code_descCountAggregateInputType | true
    _avg?: Tamper_code_descAvgAggregateInputType
    _sum?: Tamper_code_descSumAggregateInputType
    _min?: Tamper_code_descMinAggregateInputType
    _max?: Tamper_code_descMaxAggregateInputType
  }

  export type Tamper_code_descGroupByOutputType = {
    id: number
    tamperCode: number
    tamperDesc: string
    createdAt: Date
    updatedAt: Date
    _count: Tamper_code_descCountAggregateOutputType | null
    _avg: Tamper_code_descAvgAggregateOutputType | null
    _sum: Tamper_code_descSumAggregateOutputType | null
    _min: Tamper_code_descMinAggregateOutputType | null
    _max: Tamper_code_descMaxAggregateOutputType | null
  }

  type GetTamper_code_descGroupByPayload<T extends tamper_code_descGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tamper_code_descGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tamper_code_descGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tamper_code_descGroupByOutputType[P]>
            : GetScalarType<T[P], Tamper_code_descGroupByOutputType[P]>
        }
      >
    >


  export type tamper_code_descSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tamperCode?: boolean
    tamperDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tamper_code_desc"]>

  export type tamper_code_descSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tamperCode?: boolean
    tamperDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tamper_code_desc"]>

  export type tamper_code_descSelectScalar = {
    id?: boolean
    tamperCode?: boolean
    tamperDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $tamper_code_descPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tamper_code_desc"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tamperCode: number
      tamperDesc: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tamper_code_desc"]>
    composites: {}
  }

  type tamper_code_descGetPayload<S extends boolean | null | undefined | tamper_code_descDefaultArgs> = $Result.GetResult<Prisma.$tamper_code_descPayload, S>

  type tamper_code_descCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tamper_code_descFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tamper_code_descCountAggregateInputType | true
    }

  export interface tamper_code_descDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tamper_code_desc'], meta: { name: 'tamper_code_desc' } }
    /**
     * Find zero or one Tamper_code_desc that matches the filter.
     * @param {tamper_code_descFindUniqueArgs} args - Arguments to find a Tamper_code_desc
     * @example
     * // Get one Tamper_code_desc
     * const tamper_code_desc = await prisma.tamper_code_desc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tamper_code_descFindUniqueArgs>(args: SelectSubset<T, tamper_code_descFindUniqueArgs<ExtArgs>>): Prisma__tamper_code_descClient<$Result.GetResult<Prisma.$tamper_code_descPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tamper_code_desc that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tamper_code_descFindUniqueOrThrowArgs} args - Arguments to find a Tamper_code_desc
     * @example
     * // Get one Tamper_code_desc
     * const tamper_code_desc = await prisma.tamper_code_desc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tamper_code_descFindUniqueOrThrowArgs>(args: SelectSubset<T, tamper_code_descFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tamper_code_descClient<$Result.GetResult<Prisma.$tamper_code_descPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tamper_code_desc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_code_descFindFirstArgs} args - Arguments to find a Tamper_code_desc
     * @example
     * // Get one Tamper_code_desc
     * const tamper_code_desc = await prisma.tamper_code_desc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tamper_code_descFindFirstArgs>(args?: SelectSubset<T, tamper_code_descFindFirstArgs<ExtArgs>>): Prisma__tamper_code_descClient<$Result.GetResult<Prisma.$tamper_code_descPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tamper_code_desc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_code_descFindFirstOrThrowArgs} args - Arguments to find a Tamper_code_desc
     * @example
     * // Get one Tamper_code_desc
     * const tamper_code_desc = await prisma.tamper_code_desc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tamper_code_descFindFirstOrThrowArgs>(args?: SelectSubset<T, tamper_code_descFindFirstOrThrowArgs<ExtArgs>>): Prisma__tamper_code_descClient<$Result.GetResult<Prisma.$tamper_code_descPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tamper_code_descs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_code_descFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tamper_code_descs
     * const tamper_code_descs = await prisma.tamper_code_desc.findMany()
     * 
     * // Get first 10 Tamper_code_descs
     * const tamper_code_descs = await prisma.tamper_code_desc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tamper_code_descWithIdOnly = await prisma.tamper_code_desc.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tamper_code_descFindManyArgs>(args?: SelectSubset<T, tamper_code_descFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tamper_code_descPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tamper_code_desc.
     * @param {tamper_code_descCreateArgs} args - Arguments to create a Tamper_code_desc.
     * @example
     * // Create one Tamper_code_desc
     * const Tamper_code_desc = await prisma.tamper_code_desc.create({
     *   data: {
     *     // ... data to create a Tamper_code_desc
     *   }
     * })
     * 
     */
    create<T extends tamper_code_descCreateArgs>(args: SelectSubset<T, tamper_code_descCreateArgs<ExtArgs>>): Prisma__tamper_code_descClient<$Result.GetResult<Prisma.$tamper_code_descPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tamper_code_descs.
     * @param {tamper_code_descCreateManyArgs} args - Arguments to create many Tamper_code_descs.
     * @example
     * // Create many Tamper_code_descs
     * const tamper_code_desc = await prisma.tamper_code_desc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tamper_code_descCreateManyArgs>(args?: SelectSubset<T, tamper_code_descCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tamper_code_descs and returns the data saved in the database.
     * @param {tamper_code_descCreateManyAndReturnArgs} args - Arguments to create many Tamper_code_descs.
     * @example
     * // Create many Tamper_code_descs
     * const tamper_code_desc = await prisma.tamper_code_desc.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tamper_code_descs and only return the `id`
     * const tamper_code_descWithIdOnly = await prisma.tamper_code_desc.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tamper_code_descCreateManyAndReturnArgs>(args?: SelectSubset<T, tamper_code_descCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tamper_code_descPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tamper_code_desc.
     * @param {tamper_code_descDeleteArgs} args - Arguments to delete one Tamper_code_desc.
     * @example
     * // Delete one Tamper_code_desc
     * const Tamper_code_desc = await prisma.tamper_code_desc.delete({
     *   where: {
     *     // ... filter to delete one Tamper_code_desc
     *   }
     * })
     * 
     */
    delete<T extends tamper_code_descDeleteArgs>(args: SelectSubset<T, tamper_code_descDeleteArgs<ExtArgs>>): Prisma__tamper_code_descClient<$Result.GetResult<Prisma.$tamper_code_descPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tamper_code_desc.
     * @param {tamper_code_descUpdateArgs} args - Arguments to update one Tamper_code_desc.
     * @example
     * // Update one Tamper_code_desc
     * const tamper_code_desc = await prisma.tamper_code_desc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tamper_code_descUpdateArgs>(args: SelectSubset<T, tamper_code_descUpdateArgs<ExtArgs>>): Prisma__tamper_code_descClient<$Result.GetResult<Prisma.$tamper_code_descPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tamper_code_descs.
     * @param {tamper_code_descDeleteManyArgs} args - Arguments to filter Tamper_code_descs to delete.
     * @example
     * // Delete a few Tamper_code_descs
     * const { count } = await prisma.tamper_code_desc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tamper_code_descDeleteManyArgs>(args?: SelectSubset<T, tamper_code_descDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tamper_code_descs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_code_descUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tamper_code_descs
     * const tamper_code_desc = await prisma.tamper_code_desc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tamper_code_descUpdateManyArgs>(args: SelectSubset<T, tamper_code_descUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tamper_code_desc.
     * @param {tamper_code_descUpsertArgs} args - Arguments to update or create a Tamper_code_desc.
     * @example
     * // Update or create a Tamper_code_desc
     * const tamper_code_desc = await prisma.tamper_code_desc.upsert({
     *   create: {
     *     // ... data to create a Tamper_code_desc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tamper_code_desc we want to update
     *   }
     * })
     */
    upsert<T extends tamper_code_descUpsertArgs>(args: SelectSubset<T, tamper_code_descUpsertArgs<ExtArgs>>): Prisma__tamper_code_descClient<$Result.GetResult<Prisma.$tamper_code_descPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tamper_code_descs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_code_descCountArgs} args - Arguments to filter Tamper_code_descs to count.
     * @example
     * // Count the number of Tamper_code_descs
     * const count = await prisma.tamper_code_desc.count({
     *   where: {
     *     // ... the filter for the Tamper_code_descs we want to count
     *   }
     * })
    **/
    count<T extends tamper_code_descCountArgs>(
      args?: Subset<T, tamper_code_descCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tamper_code_descCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tamper_code_desc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tamper_code_descAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tamper_code_descAggregateArgs>(args: Subset<T, Tamper_code_descAggregateArgs>): Prisma.PrismaPromise<GetTamper_code_descAggregateType<T>>

    /**
     * Group by Tamper_code_desc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_code_descGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tamper_code_descGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tamper_code_descGroupByArgs['orderBy'] }
        : { orderBy?: tamper_code_descGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tamper_code_descGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTamper_code_descGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tamper_code_desc model
   */
  readonly fields: tamper_code_descFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tamper_code_desc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tamper_code_descClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tamper_code_desc model
   */ 
  interface tamper_code_descFieldRefs {
    readonly id: FieldRef<"tamper_code_desc", 'Int'>
    readonly tamperCode: FieldRef<"tamper_code_desc", 'Int'>
    readonly tamperDesc: FieldRef<"tamper_code_desc", 'String'>
    readonly createdAt: FieldRef<"tamper_code_desc", 'DateTime'>
    readonly updatedAt: FieldRef<"tamper_code_desc", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tamper_code_desc findUnique
   */
  export type tamper_code_descFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_code_desc
     */
    select?: tamper_code_descSelect<ExtArgs> | null
    /**
     * Filter, which tamper_code_desc to fetch.
     */
    where: tamper_code_descWhereUniqueInput
  }

  /**
   * tamper_code_desc findUniqueOrThrow
   */
  export type tamper_code_descFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_code_desc
     */
    select?: tamper_code_descSelect<ExtArgs> | null
    /**
     * Filter, which tamper_code_desc to fetch.
     */
    where: tamper_code_descWhereUniqueInput
  }

  /**
   * tamper_code_desc findFirst
   */
  export type tamper_code_descFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_code_desc
     */
    select?: tamper_code_descSelect<ExtArgs> | null
    /**
     * Filter, which tamper_code_desc to fetch.
     */
    where?: tamper_code_descWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tamper_code_descs to fetch.
     */
    orderBy?: tamper_code_descOrderByWithRelationInput | tamper_code_descOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tamper_code_descs.
     */
    cursor?: tamper_code_descWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tamper_code_descs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tamper_code_descs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tamper_code_descs.
     */
    distinct?: Tamper_code_descScalarFieldEnum | Tamper_code_descScalarFieldEnum[]
  }

  /**
   * tamper_code_desc findFirstOrThrow
   */
  export type tamper_code_descFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_code_desc
     */
    select?: tamper_code_descSelect<ExtArgs> | null
    /**
     * Filter, which tamper_code_desc to fetch.
     */
    where?: tamper_code_descWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tamper_code_descs to fetch.
     */
    orderBy?: tamper_code_descOrderByWithRelationInput | tamper_code_descOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tamper_code_descs.
     */
    cursor?: tamper_code_descWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tamper_code_descs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tamper_code_descs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tamper_code_descs.
     */
    distinct?: Tamper_code_descScalarFieldEnum | Tamper_code_descScalarFieldEnum[]
  }

  /**
   * tamper_code_desc findMany
   */
  export type tamper_code_descFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_code_desc
     */
    select?: tamper_code_descSelect<ExtArgs> | null
    /**
     * Filter, which tamper_code_descs to fetch.
     */
    where?: tamper_code_descWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tamper_code_descs to fetch.
     */
    orderBy?: tamper_code_descOrderByWithRelationInput | tamper_code_descOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tamper_code_descs.
     */
    cursor?: tamper_code_descWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tamper_code_descs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tamper_code_descs.
     */
    skip?: number
    distinct?: Tamper_code_descScalarFieldEnum | Tamper_code_descScalarFieldEnum[]
  }

  /**
   * tamper_code_desc create
   */
  export type tamper_code_descCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_code_desc
     */
    select?: tamper_code_descSelect<ExtArgs> | null
    /**
     * The data needed to create a tamper_code_desc.
     */
    data: XOR<tamper_code_descCreateInput, tamper_code_descUncheckedCreateInput>
  }

  /**
   * tamper_code_desc createMany
   */
  export type tamper_code_descCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tamper_code_descs.
     */
    data: tamper_code_descCreateManyInput | tamper_code_descCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tamper_code_desc createManyAndReturn
   */
  export type tamper_code_descCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_code_desc
     */
    select?: tamper_code_descSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tamper_code_descs.
     */
    data: tamper_code_descCreateManyInput | tamper_code_descCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tamper_code_desc update
   */
  export type tamper_code_descUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_code_desc
     */
    select?: tamper_code_descSelect<ExtArgs> | null
    /**
     * The data needed to update a tamper_code_desc.
     */
    data: XOR<tamper_code_descUpdateInput, tamper_code_descUncheckedUpdateInput>
    /**
     * Choose, which tamper_code_desc to update.
     */
    where: tamper_code_descWhereUniqueInput
  }

  /**
   * tamper_code_desc updateMany
   */
  export type tamper_code_descUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tamper_code_descs.
     */
    data: XOR<tamper_code_descUpdateManyMutationInput, tamper_code_descUncheckedUpdateManyInput>
    /**
     * Filter which tamper_code_descs to update
     */
    where?: tamper_code_descWhereInput
  }

  /**
   * tamper_code_desc upsert
   */
  export type tamper_code_descUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_code_desc
     */
    select?: tamper_code_descSelect<ExtArgs> | null
    /**
     * The filter to search for the tamper_code_desc to update in case it exists.
     */
    where: tamper_code_descWhereUniqueInput
    /**
     * In case the tamper_code_desc found by the `where` argument doesn't exist, create a new tamper_code_desc with this data.
     */
    create: XOR<tamper_code_descCreateInput, tamper_code_descUncheckedCreateInput>
    /**
     * In case the tamper_code_desc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tamper_code_descUpdateInput, tamper_code_descUncheckedUpdateInput>
  }

  /**
   * tamper_code_desc delete
   */
  export type tamper_code_descDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_code_desc
     */
    select?: tamper_code_descSelect<ExtArgs> | null
    /**
     * Filter which tamper_code_desc to delete.
     */
    where: tamper_code_descWhereUniqueInput
  }

  /**
   * tamper_code_desc deleteMany
   */
  export type tamper_code_descDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tamper_code_descs to delete
     */
    where?: tamper_code_descWhereInput
  }

  /**
   * tamper_code_desc without action
   */
  export type tamper_code_descDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_code_desc
     */
    select?: tamper_code_descSelect<ExtArgs> | null
  }


  /**
   * Model tamper_events
   */

  export type AggregateTamper_events = {
    _count: Tamper_eventsCountAggregateOutputType | null
    _avg: Tamper_eventsAvgAggregateOutputType | null
    _sum: Tamper_eventsSumAggregateOutputType | null
    _min: Tamper_eventsMinAggregateOutputType | null
    _max: Tamper_eventsMaxAggregateOutputType | null
  }

  export type Tamper_eventsAvgAggregateOutputType = {
    id: number | null
    meterId: number | null
    avgCurrent: number | null
    avgVoltage: number | null
    avgPowerFactor: number | null
    frequency: number | null
    kwh: number | null
    kwhExport: number | null
    kwhImport: number | null
    kwhNet: number | null
    kwhTotal: number | null
    kwExport: number | null
    kwImport: number | null
    kvaExport: number | null
    kvaImport: number | null
    voltageR: number | null
    voltageY: number | null
    voltageB: number | null
    currentR: number | null
    currentY: number | null
    currentB: number | null
    powerFactorR: number | null
    powerFactorY: number | null
    powerFactorB: number | null
    tamperCount: number | null
    param1: number | null
    param2: number | null
    param3: number | null
    param4: number | null
    param5: number | null
  }

  export type Tamper_eventsSumAggregateOutputType = {
    id: number | null
    meterId: number | null
    avgCurrent: number | null
    avgVoltage: number | null
    avgPowerFactor: number | null
    frequency: number | null
    kwh: number | null
    kwhExport: number | null
    kwhImport: number | null
    kwhNet: number | null
    kwhTotal: number | null
    kwExport: number | null
    kwImport: number | null
    kvaExport: number | null
    kvaImport: number | null
    voltageR: number | null
    voltageY: number | null
    voltageB: number | null
    currentR: number | null
    currentY: number | null
    currentB: number | null
    powerFactorR: number | null
    powerFactorY: number | null
    powerFactorB: number | null
    tamperCount: number | null
    param1: number | null
    param2: number | null
    param3: number | null
    param4: number | null
    param5: number | null
  }

  export type Tamper_eventsMinAggregateOutputType = {
    id: number | null
    meterId: number | null
    tamperDatetime: Date | null
    tamperType: $Enums.TamperType | null
    tamperStatus: $Enums.TamperStatus | null
    avgCurrent: number | null
    avgVoltage: number | null
    avgPowerFactor: number | null
    frequency: number | null
    kwh: number | null
    kwhExport: number | null
    kwhImport: number | null
    kwhNet: number | null
    kwhTotal: number | null
    kwExport: number | null
    kwImport: number | null
    kvaExport: number | null
    kvaImport: number | null
    voltageR: number | null
    voltageY: number | null
    voltageB: number | null
    currentR: number | null
    currentY: number | null
    currentB: number | null
    powerFactorR: number | null
    powerFactorY: number | null
    powerFactorB: number | null
    tamperCount: number | null
    param1: number | null
    param2: number | null
    param3: number | null
    param4: number | null
    param5: number | null
    isProcessed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tamper_eventsMaxAggregateOutputType = {
    id: number | null
    meterId: number | null
    tamperDatetime: Date | null
    tamperType: $Enums.TamperType | null
    tamperStatus: $Enums.TamperStatus | null
    avgCurrent: number | null
    avgVoltage: number | null
    avgPowerFactor: number | null
    frequency: number | null
    kwh: number | null
    kwhExport: number | null
    kwhImport: number | null
    kwhNet: number | null
    kwhTotal: number | null
    kwExport: number | null
    kwImport: number | null
    kvaExport: number | null
    kvaImport: number | null
    voltageR: number | null
    voltageY: number | null
    voltageB: number | null
    currentR: number | null
    currentY: number | null
    currentB: number | null
    powerFactorR: number | null
    powerFactorY: number | null
    powerFactorB: number | null
    tamperCount: number | null
    param1: number | null
    param2: number | null
    param3: number | null
    param4: number | null
    param5: number | null
    isProcessed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tamper_eventsCountAggregateOutputType = {
    id: number
    meterId: number
    tamperDatetime: number
    tamperType: number
    tamperStatus: number
    avgCurrent: number
    avgVoltage: number
    avgPowerFactor: number
    frequency: number
    kwh: number
    kwhExport: number
    kwhImport: number
    kwhNet: number
    kwhTotal: number
    kwExport: number
    kwImport: number
    kvaExport: number
    kvaImport: number
    voltageR: number
    voltageY: number
    voltageB: number
    currentR: number
    currentY: number
    currentB: number
    powerFactorR: number
    powerFactorY: number
    powerFactorB: number
    tamperCount: number
    param1: number
    param2: number
    param3: number
    param4: number
    param5: number
    isProcessed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tamper_eventsAvgAggregateInputType = {
    id?: true
    meterId?: true
    avgCurrent?: true
    avgVoltage?: true
    avgPowerFactor?: true
    frequency?: true
    kwh?: true
    kwhExport?: true
    kwhImport?: true
    kwhNet?: true
    kwhTotal?: true
    kwExport?: true
    kwImport?: true
    kvaExport?: true
    kvaImport?: true
    voltageR?: true
    voltageY?: true
    voltageB?: true
    currentR?: true
    currentY?: true
    currentB?: true
    powerFactorR?: true
    powerFactorY?: true
    powerFactorB?: true
    tamperCount?: true
    param1?: true
    param2?: true
    param3?: true
    param4?: true
    param5?: true
  }

  export type Tamper_eventsSumAggregateInputType = {
    id?: true
    meterId?: true
    avgCurrent?: true
    avgVoltage?: true
    avgPowerFactor?: true
    frequency?: true
    kwh?: true
    kwhExport?: true
    kwhImport?: true
    kwhNet?: true
    kwhTotal?: true
    kwExport?: true
    kwImport?: true
    kvaExport?: true
    kvaImport?: true
    voltageR?: true
    voltageY?: true
    voltageB?: true
    currentR?: true
    currentY?: true
    currentB?: true
    powerFactorR?: true
    powerFactorY?: true
    powerFactorB?: true
    tamperCount?: true
    param1?: true
    param2?: true
    param3?: true
    param4?: true
    param5?: true
  }

  export type Tamper_eventsMinAggregateInputType = {
    id?: true
    meterId?: true
    tamperDatetime?: true
    tamperType?: true
    tamperStatus?: true
    avgCurrent?: true
    avgVoltage?: true
    avgPowerFactor?: true
    frequency?: true
    kwh?: true
    kwhExport?: true
    kwhImport?: true
    kwhNet?: true
    kwhTotal?: true
    kwExport?: true
    kwImport?: true
    kvaExport?: true
    kvaImport?: true
    voltageR?: true
    voltageY?: true
    voltageB?: true
    currentR?: true
    currentY?: true
    currentB?: true
    powerFactorR?: true
    powerFactorY?: true
    powerFactorB?: true
    tamperCount?: true
    param1?: true
    param2?: true
    param3?: true
    param4?: true
    param5?: true
    isProcessed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tamper_eventsMaxAggregateInputType = {
    id?: true
    meterId?: true
    tamperDatetime?: true
    tamperType?: true
    tamperStatus?: true
    avgCurrent?: true
    avgVoltage?: true
    avgPowerFactor?: true
    frequency?: true
    kwh?: true
    kwhExport?: true
    kwhImport?: true
    kwhNet?: true
    kwhTotal?: true
    kwExport?: true
    kwImport?: true
    kvaExport?: true
    kvaImport?: true
    voltageR?: true
    voltageY?: true
    voltageB?: true
    currentR?: true
    currentY?: true
    currentB?: true
    powerFactorR?: true
    powerFactorY?: true
    powerFactorB?: true
    tamperCount?: true
    param1?: true
    param2?: true
    param3?: true
    param4?: true
    param5?: true
    isProcessed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tamper_eventsCountAggregateInputType = {
    id?: true
    meterId?: true
    tamperDatetime?: true
    tamperType?: true
    tamperStatus?: true
    avgCurrent?: true
    avgVoltage?: true
    avgPowerFactor?: true
    frequency?: true
    kwh?: true
    kwhExport?: true
    kwhImport?: true
    kwhNet?: true
    kwhTotal?: true
    kwExport?: true
    kwImport?: true
    kvaExport?: true
    kvaImport?: true
    voltageR?: true
    voltageY?: true
    voltageB?: true
    currentR?: true
    currentY?: true
    currentB?: true
    powerFactorR?: true
    powerFactorY?: true
    powerFactorB?: true
    tamperCount?: true
    param1?: true
    param2?: true
    param3?: true
    param4?: true
    param5?: true
    isProcessed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tamper_eventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tamper_events to aggregate.
     */
    where?: tamper_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tamper_events to fetch.
     */
    orderBy?: tamper_eventsOrderByWithRelationInput | tamper_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tamper_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tamper_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tamper_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tamper_events
    **/
    _count?: true | Tamper_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tamper_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tamper_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tamper_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tamper_eventsMaxAggregateInputType
  }

  export type GetTamper_eventsAggregateType<T extends Tamper_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateTamper_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTamper_events[P]>
      : GetScalarType<T[P], AggregateTamper_events[P]>
  }




  export type tamper_eventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tamper_eventsWhereInput
    orderBy?: tamper_eventsOrderByWithAggregationInput | tamper_eventsOrderByWithAggregationInput[]
    by: Tamper_eventsScalarFieldEnum[] | Tamper_eventsScalarFieldEnum
    having?: tamper_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tamper_eventsCountAggregateInputType | true
    _avg?: Tamper_eventsAvgAggregateInputType
    _sum?: Tamper_eventsSumAggregateInputType
    _min?: Tamper_eventsMinAggregateInputType
    _max?: Tamper_eventsMaxAggregateInputType
  }

  export type Tamper_eventsGroupByOutputType = {
    id: number
    meterId: number
    tamperDatetime: Date
    tamperType: $Enums.TamperType
    tamperStatus: $Enums.TamperStatus
    avgCurrent: number | null
    avgVoltage: number | null
    avgPowerFactor: number | null
    frequency: number | null
    kwh: number | null
    kwhExport: number | null
    kwhImport: number | null
    kwhNet: number | null
    kwhTotal: number | null
    kwExport: number | null
    kwImport: number | null
    kvaExport: number | null
    kvaImport: number | null
    voltageR: number | null
    voltageY: number | null
    voltageB: number | null
    currentR: number | null
    currentY: number | null
    currentB: number | null
    powerFactorR: number | null
    powerFactorY: number | null
    powerFactorB: number | null
    tamperCount: number | null
    param1: number | null
    param2: number | null
    param3: number | null
    param4: number | null
    param5: number | null
    isProcessed: boolean
    createdAt: Date
    updatedAt: Date
    _count: Tamper_eventsCountAggregateOutputType | null
    _avg: Tamper_eventsAvgAggregateOutputType | null
    _sum: Tamper_eventsSumAggregateOutputType | null
    _min: Tamper_eventsMinAggregateOutputType | null
    _max: Tamper_eventsMaxAggregateOutputType | null
  }

  type GetTamper_eventsGroupByPayload<T extends tamper_eventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tamper_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tamper_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tamper_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], Tamper_eventsGroupByOutputType[P]>
        }
      >
    >


  export type tamper_eventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterId?: boolean
    tamperDatetime?: boolean
    tamperType?: boolean
    tamperStatus?: boolean
    avgCurrent?: boolean
    avgVoltage?: boolean
    avgPowerFactor?: boolean
    frequency?: boolean
    kwh?: boolean
    kwhExport?: boolean
    kwhImport?: boolean
    kwhNet?: boolean
    kwhTotal?: boolean
    kwExport?: boolean
    kwImport?: boolean
    kvaExport?: boolean
    kvaImport?: boolean
    voltageR?: boolean
    voltageY?: boolean
    voltageB?: boolean
    currentR?: boolean
    currentY?: boolean
    currentB?: boolean
    powerFactorR?: boolean
    powerFactorY?: boolean
    powerFactorB?: boolean
    tamperCount?: boolean
    param1?: boolean
    param2?: boolean
    param3?: boolean
    param4?: boolean
    param5?: boolean
    isProcessed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tamper_events"]>

  export type tamper_eventsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meterId?: boolean
    tamperDatetime?: boolean
    tamperType?: boolean
    tamperStatus?: boolean
    avgCurrent?: boolean
    avgVoltage?: boolean
    avgPowerFactor?: boolean
    frequency?: boolean
    kwh?: boolean
    kwhExport?: boolean
    kwhImport?: boolean
    kwhNet?: boolean
    kwhTotal?: boolean
    kwExport?: boolean
    kwImport?: boolean
    kvaExport?: boolean
    kvaImport?: boolean
    voltageR?: boolean
    voltageY?: boolean
    voltageB?: boolean
    currentR?: boolean
    currentY?: boolean
    currentB?: boolean
    powerFactorR?: boolean
    powerFactorY?: boolean
    powerFactorB?: boolean
    tamperCount?: boolean
    param1?: boolean
    param2?: boolean
    param3?: boolean
    param4?: boolean
    param5?: boolean
    isProcessed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tamper_events"]>

  export type tamper_eventsSelectScalar = {
    id?: boolean
    meterId?: boolean
    tamperDatetime?: boolean
    tamperType?: boolean
    tamperStatus?: boolean
    avgCurrent?: boolean
    avgVoltage?: boolean
    avgPowerFactor?: boolean
    frequency?: boolean
    kwh?: boolean
    kwhExport?: boolean
    kwhImport?: boolean
    kwhNet?: boolean
    kwhTotal?: boolean
    kwExport?: boolean
    kwImport?: boolean
    kvaExport?: boolean
    kvaImport?: boolean
    voltageR?: boolean
    voltageY?: boolean
    voltageB?: boolean
    currentR?: boolean
    currentY?: boolean
    currentB?: boolean
    powerFactorR?: boolean
    powerFactorY?: boolean
    powerFactorB?: boolean
    tamperCount?: boolean
    param1?: boolean
    param2?: boolean
    param3?: boolean
    param4?: boolean
    param5?: boolean
    isProcessed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tamper_eventsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }
  export type tamper_eventsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meters?: boolean | metersDefaultArgs<ExtArgs>
  }

  export type $tamper_eventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tamper_events"
    objects: {
      meters: Prisma.$metersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      meterId: number
      tamperDatetime: Date
      tamperType: $Enums.TamperType
      tamperStatus: $Enums.TamperStatus
      avgCurrent: number | null
      avgVoltage: number | null
      avgPowerFactor: number | null
      frequency: number | null
      kwh: number | null
      kwhExport: number | null
      kwhImport: number | null
      kwhNet: number | null
      kwhTotal: number | null
      kwExport: number | null
      kwImport: number | null
      kvaExport: number | null
      kvaImport: number | null
      voltageR: number | null
      voltageY: number | null
      voltageB: number | null
      currentR: number | null
      currentY: number | null
      currentB: number | null
      powerFactorR: number | null
      powerFactorY: number | null
      powerFactorB: number | null
      tamperCount: number | null
      param1: number | null
      param2: number | null
      param3: number | null
      param4: number | null
      param5: number | null
      isProcessed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tamper_events"]>
    composites: {}
  }

  type tamper_eventsGetPayload<S extends boolean | null | undefined | tamper_eventsDefaultArgs> = $Result.GetResult<Prisma.$tamper_eventsPayload, S>

  type tamper_eventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tamper_eventsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tamper_eventsCountAggregateInputType | true
    }

  export interface tamper_eventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tamper_events'], meta: { name: 'tamper_events' } }
    /**
     * Find zero or one Tamper_events that matches the filter.
     * @param {tamper_eventsFindUniqueArgs} args - Arguments to find a Tamper_events
     * @example
     * // Get one Tamper_events
     * const tamper_events = await prisma.tamper_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tamper_eventsFindUniqueArgs>(args: SelectSubset<T, tamper_eventsFindUniqueArgs<ExtArgs>>): Prisma__tamper_eventsClient<$Result.GetResult<Prisma.$tamper_eventsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tamper_events that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tamper_eventsFindUniqueOrThrowArgs} args - Arguments to find a Tamper_events
     * @example
     * // Get one Tamper_events
     * const tamper_events = await prisma.tamper_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tamper_eventsFindUniqueOrThrowArgs>(args: SelectSubset<T, tamper_eventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tamper_eventsClient<$Result.GetResult<Prisma.$tamper_eventsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tamper_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_eventsFindFirstArgs} args - Arguments to find a Tamper_events
     * @example
     * // Get one Tamper_events
     * const tamper_events = await prisma.tamper_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tamper_eventsFindFirstArgs>(args?: SelectSubset<T, tamper_eventsFindFirstArgs<ExtArgs>>): Prisma__tamper_eventsClient<$Result.GetResult<Prisma.$tamper_eventsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tamper_events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_eventsFindFirstOrThrowArgs} args - Arguments to find a Tamper_events
     * @example
     * // Get one Tamper_events
     * const tamper_events = await prisma.tamper_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tamper_eventsFindFirstOrThrowArgs>(args?: SelectSubset<T, tamper_eventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tamper_eventsClient<$Result.GetResult<Prisma.$tamper_eventsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tamper_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_eventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tamper_events
     * const tamper_events = await prisma.tamper_events.findMany()
     * 
     * // Get first 10 Tamper_events
     * const tamper_events = await prisma.tamper_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tamper_eventsWithIdOnly = await prisma.tamper_events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tamper_eventsFindManyArgs>(args?: SelectSubset<T, tamper_eventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tamper_eventsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tamper_events.
     * @param {tamper_eventsCreateArgs} args - Arguments to create a Tamper_events.
     * @example
     * // Create one Tamper_events
     * const Tamper_events = await prisma.tamper_events.create({
     *   data: {
     *     // ... data to create a Tamper_events
     *   }
     * })
     * 
     */
    create<T extends tamper_eventsCreateArgs>(args: SelectSubset<T, tamper_eventsCreateArgs<ExtArgs>>): Prisma__tamper_eventsClient<$Result.GetResult<Prisma.$tamper_eventsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tamper_events.
     * @param {tamper_eventsCreateManyArgs} args - Arguments to create many Tamper_events.
     * @example
     * // Create many Tamper_events
     * const tamper_events = await prisma.tamper_events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tamper_eventsCreateManyArgs>(args?: SelectSubset<T, tamper_eventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tamper_events and returns the data saved in the database.
     * @param {tamper_eventsCreateManyAndReturnArgs} args - Arguments to create many Tamper_events.
     * @example
     * // Create many Tamper_events
     * const tamper_events = await prisma.tamper_events.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tamper_events and only return the `id`
     * const tamper_eventsWithIdOnly = await prisma.tamper_events.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tamper_eventsCreateManyAndReturnArgs>(args?: SelectSubset<T, tamper_eventsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tamper_eventsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tamper_events.
     * @param {tamper_eventsDeleteArgs} args - Arguments to delete one Tamper_events.
     * @example
     * // Delete one Tamper_events
     * const Tamper_events = await prisma.tamper_events.delete({
     *   where: {
     *     // ... filter to delete one Tamper_events
     *   }
     * })
     * 
     */
    delete<T extends tamper_eventsDeleteArgs>(args: SelectSubset<T, tamper_eventsDeleteArgs<ExtArgs>>): Prisma__tamper_eventsClient<$Result.GetResult<Prisma.$tamper_eventsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tamper_events.
     * @param {tamper_eventsUpdateArgs} args - Arguments to update one Tamper_events.
     * @example
     * // Update one Tamper_events
     * const tamper_events = await prisma.tamper_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tamper_eventsUpdateArgs>(args: SelectSubset<T, tamper_eventsUpdateArgs<ExtArgs>>): Prisma__tamper_eventsClient<$Result.GetResult<Prisma.$tamper_eventsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tamper_events.
     * @param {tamper_eventsDeleteManyArgs} args - Arguments to filter Tamper_events to delete.
     * @example
     * // Delete a few Tamper_events
     * const { count } = await prisma.tamper_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tamper_eventsDeleteManyArgs>(args?: SelectSubset<T, tamper_eventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tamper_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tamper_events
     * const tamper_events = await prisma.tamper_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tamper_eventsUpdateManyArgs>(args: SelectSubset<T, tamper_eventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tamper_events.
     * @param {tamper_eventsUpsertArgs} args - Arguments to update or create a Tamper_events.
     * @example
     * // Update or create a Tamper_events
     * const tamper_events = await prisma.tamper_events.upsert({
     *   create: {
     *     // ... data to create a Tamper_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tamper_events we want to update
     *   }
     * })
     */
    upsert<T extends tamper_eventsUpsertArgs>(args: SelectSubset<T, tamper_eventsUpsertArgs<ExtArgs>>): Prisma__tamper_eventsClient<$Result.GetResult<Prisma.$tamper_eventsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tamper_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_eventsCountArgs} args - Arguments to filter Tamper_events to count.
     * @example
     * // Count the number of Tamper_events
     * const count = await prisma.tamper_events.count({
     *   where: {
     *     // ... the filter for the Tamper_events we want to count
     *   }
     * })
    **/
    count<T extends tamper_eventsCountArgs>(
      args?: Subset<T, tamper_eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tamper_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tamper_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tamper_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tamper_eventsAggregateArgs>(args: Subset<T, Tamper_eventsAggregateArgs>): Prisma.PrismaPromise<GetTamper_eventsAggregateType<T>>

    /**
     * Group by Tamper_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tamper_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tamper_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tamper_eventsGroupByArgs['orderBy'] }
        : { orderBy?: tamper_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tamper_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTamper_eventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tamper_events model
   */
  readonly fields: tamper_eventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tamper_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tamper_eventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meters<T extends metersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, metersDefaultArgs<ExtArgs>>): Prisma__metersClient<$Result.GetResult<Prisma.$metersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tamper_events model
   */ 
  interface tamper_eventsFieldRefs {
    readonly id: FieldRef<"tamper_events", 'Int'>
    readonly meterId: FieldRef<"tamper_events", 'Int'>
    readonly tamperDatetime: FieldRef<"tamper_events", 'DateTime'>
    readonly tamperType: FieldRef<"tamper_events", 'TamperType'>
    readonly tamperStatus: FieldRef<"tamper_events", 'TamperStatus'>
    readonly avgCurrent: FieldRef<"tamper_events", 'Float'>
    readonly avgVoltage: FieldRef<"tamper_events", 'Float'>
    readonly avgPowerFactor: FieldRef<"tamper_events", 'Float'>
    readonly frequency: FieldRef<"tamper_events", 'Float'>
    readonly kwh: FieldRef<"tamper_events", 'Float'>
    readonly kwhExport: FieldRef<"tamper_events", 'Float'>
    readonly kwhImport: FieldRef<"tamper_events", 'Float'>
    readonly kwhNet: FieldRef<"tamper_events", 'Float'>
    readonly kwhTotal: FieldRef<"tamper_events", 'Float'>
    readonly kwExport: FieldRef<"tamper_events", 'Float'>
    readonly kwImport: FieldRef<"tamper_events", 'Float'>
    readonly kvaExport: FieldRef<"tamper_events", 'Float'>
    readonly kvaImport: FieldRef<"tamper_events", 'Float'>
    readonly voltageR: FieldRef<"tamper_events", 'Float'>
    readonly voltageY: FieldRef<"tamper_events", 'Float'>
    readonly voltageB: FieldRef<"tamper_events", 'Float'>
    readonly currentR: FieldRef<"tamper_events", 'Float'>
    readonly currentY: FieldRef<"tamper_events", 'Float'>
    readonly currentB: FieldRef<"tamper_events", 'Float'>
    readonly powerFactorR: FieldRef<"tamper_events", 'Float'>
    readonly powerFactorY: FieldRef<"tamper_events", 'Float'>
    readonly powerFactorB: FieldRef<"tamper_events", 'Float'>
    readonly tamperCount: FieldRef<"tamper_events", 'Int'>
    readonly param1: FieldRef<"tamper_events", 'Float'>
    readonly param2: FieldRef<"tamper_events", 'Float'>
    readonly param3: FieldRef<"tamper_events", 'Float'>
    readonly param4: FieldRef<"tamper_events", 'Float'>
    readonly param5: FieldRef<"tamper_events", 'Float'>
    readonly isProcessed: FieldRef<"tamper_events", 'Boolean'>
    readonly createdAt: FieldRef<"tamper_events", 'DateTime'>
    readonly updatedAt: FieldRef<"tamper_events", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tamper_events findUnique
   */
  export type tamper_eventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsInclude<ExtArgs> | null
    /**
     * Filter, which tamper_events to fetch.
     */
    where: tamper_eventsWhereUniqueInput
  }

  /**
   * tamper_events findUniqueOrThrow
   */
  export type tamper_eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsInclude<ExtArgs> | null
    /**
     * Filter, which tamper_events to fetch.
     */
    where: tamper_eventsWhereUniqueInput
  }

  /**
   * tamper_events findFirst
   */
  export type tamper_eventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsInclude<ExtArgs> | null
    /**
     * Filter, which tamper_events to fetch.
     */
    where?: tamper_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tamper_events to fetch.
     */
    orderBy?: tamper_eventsOrderByWithRelationInput | tamper_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tamper_events.
     */
    cursor?: tamper_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tamper_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tamper_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tamper_events.
     */
    distinct?: Tamper_eventsScalarFieldEnum | Tamper_eventsScalarFieldEnum[]
  }

  /**
   * tamper_events findFirstOrThrow
   */
  export type tamper_eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsInclude<ExtArgs> | null
    /**
     * Filter, which tamper_events to fetch.
     */
    where?: tamper_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tamper_events to fetch.
     */
    orderBy?: tamper_eventsOrderByWithRelationInput | tamper_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tamper_events.
     */
    cursor?: tamper_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tamper_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tamper_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tamper_events.
     */
    distinct?: Tamper_eventsScalarFieldEnum | Tamper_eventsScalarFieldEnum[]
  }

  /**
   * tamper_events findMany
   */
  export type tamper_eventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsInclude<ExtArgs> | null
    /**
     * Filter, which tamper_events to fetch.
     */
    where?: tamper_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tamper_events to fetch.
     */
    orderBy?: tamper_eventsOrderByWithRelationInput | tamper_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tamper_events.
     */
    cursor?: tamper_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tamper_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tamper_events.
     */
    skip?: number
    distinct?: Tamper_eventsScalarFieldEnum | Tamper_eventsScalarFieldEnum[]
  }

  /**
   * tamper_events create
   */
  export type tamper_eventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsInclude<ExtArgs> | null
    /**
     * The data needed to create a tamper_events.
     */
    data: XOR<tamper_eventsCreateInput, tamper_eventsUncheckedCreateInput>
  }

  /**
   * tamper_events createMany
   */
  export type tamper_eventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tamper_events.
     */
    data: tamper_eventsCreateManyInput | tamper_eventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tamper_events createManyAndReturn
   */
  export type tamper_eventsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tamper_events.
     */
    data: tamper_eventsCreateManyInput | tamper_eventsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tamper_events update
   */
  export type tamper_eventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsInclude<ExtArgs> | null
    /**
     * The data needed to update a tamper_events.
     */
    data: XOR<tamper_eventsUpdateInput, tamper_eventsUncheckedUpdateInput>
    /**
     * Choose, which tamper_events to update.
     */
    where: tamper_eventsWhereUniqueInput
  }

  /**
   * tamper_events updateMany
   */
  export type tamper_eventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tamper_events.
     */
    data: XOR<tamper_eventsUpdateManyMutationInput, tamper_eventsUncheckedUpdateManyInput>
    /**
     * Filter which tamper_events to update
     */
    where?: tamper_eventsWhereInput
  }

  /**
   * tamper_events upsert
   */
  export type tamper_eventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsInclude<ExtArgs> | null
    /**
     * The filter to search for the tamper_events to update in case it exists.
     */
    where: tamper_eventsWhereUniqueInput
    /**
     * In case the tamper_events found by the `where` argument doesn't exist, create a new tamper_events with this data.
     */
    create: XOR<tamper_eventsCreateInput, tamper_eventsUncheckedCreateInput>
    /**
     * In case the tamper_events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tamper_eventsUpdateInput, tamper_eventsUncheckedUpdateInput>
  }

  /**
   * tamper_events delete
   */
  export type tamper_eventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsInclude<ExtArgs> | null
    /**
     * Filter which tamper_events to delete.
     */
    where: tamper_eventsWhereUniqueInput
  }

  /**
   * tamper_events deleteMany
   */
  export type tamper_eventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tamper_events to delete
     */
    where?: tamper_eventsWhereInput
  }

  /**
   * tamper_events without action
   */
  export type tamper_eventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tamper_events
     */
    select?: tamper_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tamper_eventsInclude<ExtArgs> | null
  }


  /**
   * Model tariff
   */

  export type AggregateTariff = {
    _count: TariffCountAggregateOutputType | null
    _avg: TariffAvgAggregateOutputType | null
    _sum: TariffSumAggregateOutputType | null
    _min: TariffMinAggregateOutputType | null
    _max: TariffMaxAggregateOutputType | null
  }

  export type TariffAvgAggregateOutputType = {
    id: number | null
    client_id: number | null
    category: number | null
    min_demand: number | null
    min_demand_unit_rate: number | null
    min_demand_excess_unit_rate: number | null
    base_unit_rate: number | null
    elec_duty_unit_rate: number | null
    ims: number | null
    gst: number | null
  }

  export type TariffSumAggregateOutputType = {
    id: number | null
    client_id: number | null
    category: number | null
    min_demand: number | null
    min_demand_unit_rate: number | null
    min_demand_excess_unit_rate: number | null
    base_unit_rate: number | null
    elec_duty_unit_rate: number | null
    ims: number | null
    gst: number | null
  }

  export type TariffMinAggregateOutputType = {
    id: number | null
    client_id: number | null
    category: number | null
    tariff_name: string | null
    type: string | null
    device: string | null
    min_demand: number | null
    min_demand_unit_rate: number | null
    min_demand_excess_unit_rate: number | null
    base_unit_rate: number | null
    elec_duty_unit_rate: number | null
    ims: number | null
    gst: number | null
    valid_from: Date | null
    valid_to: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TariffMaxAggregateOutputType = {
    id: number | null
    client_id: number | null
    category: number | null
    tariff_name: string | null
    type: string | null
    device: string | null
    min_demand: number | null
    min_demand_unit_rate: number | null
    min_demand_excess_unit_rate: number | null
    base_unit_rate: number | null
    elec_duty_unit_rate: number | null
    ims: number | null
    gst: number | null
    valid_from: Date | null
    valid_to: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TariffCountAggregateOutputType = {
    id: number
    client_id: number
    category: number
    tariff_name: number
    type: number
    device: number
    min_demand: number
    min_demand_unit_rate: number
    min_demand_excess_unit_rate: number
    base_unit_rate: number
    elec_duty_unit_rate: number
    ims: number
    gst: number
    valid_from: number
    valid_to: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TariffAvgAggregateInputType = {
    id?: true
    client_id?: true
    category?: true
    min_demand?: true
    min_demand_unit_rate?: true
    min_demand_excess_unit_rate?: true
    base_unit_rate?: true
    elec_duty_unit_rate?: true
    ims?: true
    gst?: true
  }

  export type TariffSumAggregateInputType = {
    id?: true
    client_id?: true
    category?: true
    min_demand?: true
    min_demand_unit_rate?: true
    min_demand_excess_unit_rate?: true
    base_unit_rate?: true
    elec_duty_unit_rate?: true
    ims?: true
    gst?: true
  }

  export type TariffMinAggregateInputType = {
    id?: true
    client_id?: true
    category?: true
    tariff_name?: true
    type?: true
    device?: true
    min_demand?: true
    min_demand_unit_rate?: true
    min_demand_excess_unit_rate?: true
    base_unit_rate?: true
    elec_duty_unit_rate?: true
    ims?: true
    gst?: true
    valid_from?: true
    valid_to?: true
    created_at?: true
    updated_at?: true
  }

  export type TariffMaxAggregateInputType = {
    id?: true
    client_id?: true
    category?: true
    tariff_name?: true
    type?: true
    device?: true
    min_demand?: true
    min_demand_unit_rate?: true
    min_demand_excess_unit_rate?: true
    base_unit_rate?: true
    elec_duty_unit_rate?: true
    ims?: true
    gst?: true
    valid_from?: true
    valid_to?: true
    created_at?: true
    updated_at?: true
  }

  export type TariffCountAggregateInputType = {
    id?: true
    client_id?: true
    category?: true
    tariff_name?: true
    type?: true
    device?: true
    min_demand?: true
    min_demand_unit_rate?: true
    min_demand_excess_unit_rate?: true
    base_unit_rate?: true
    elec_duty_unit_rate?: true
    ims?: true
    gst?: true
    valid_from?: true
    valid_to?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TariffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tariff to aggregate.
     */
    where?: tariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tariffs to fetch.
     */
    orderBy?: tariffOrderByWithRelationInput | tariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tariffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tariffs
    **/
    _count?: true | TariffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TariffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TariffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TariffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TariffMaxAggregateInputType
  }

  export type GetTariffAggregateType<T extends TariffAggregateArgs> = {
        [P in keyof T & keyof AggregateTariff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTariff[P]>
      : GetScalarType<T[P], AggregateTariff[P]>
  }




  export type tariffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tariffWhereInput
    orderBy?: tariffOrderByWithAggregationInput | tariffOrderByWithAggregationInput[]
    by: TariffScalarFieldEnum[] | TariffScalarFieldEnum
    having?: tariffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TariffCountAggregateInputType | true
    _avg?: TariffAvgAggregateInputType
    _sum?: TariffSumAggregateInputType
    _min?: TariffMinAggregateInputType
    _max?: TariffMaxAggregateInputType
  }

  export type TariffGroupByOutputType = {
    id: number
    client_id: number
    category: number
    tariff_name: string
    type: string
    device: string
    min_demand: number | null
    min_demand_unit_rate: number | null
    min_demand_excess_unit_rate: number | null
    base_unit_rate: number
    elec_duty_unit_rate: number | null
    ims: number | null
    gst: number | null
    valid_from: Date
    valid_to: Date | null
    created_at: Date
    updated_at: Date
    _count: TariffCountAggregateOutputType | null
    _avg: TariffAvgAggregateOutputType | null
    _sum: TariffSumAggregateOutputType | null
    _min: TariffMinAggregateOutputType | null
    _max: TariffMaxAggregateOutputType | null
  }

  type GetTariffGroupByPayload<T extends tariffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TariffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TariffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TariffGroupByOutputType[P]>
            : GetScalarType<T[P], TariffGroupByOutputType[P]>
        }
      >
    >


  export type tariffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    category?: boolean
    tariff_name?: boolean
    type?: boolean
    device?: boolean
    min_demand?: boolean
    min_demand_unit_rate?: boolean
    min_demand_excess_unit_rate?: boolean
    base_unit_rate?: boolean
    elec_duty_unit_rate?: boolean
    ims?: boolean
    gst?: boolean
    valid_from?: boolean
    valid_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    tariff_slabs?: boolean | tariff$tariff_slabsArgs<ExtArgs>
    _count?: boolean | TariffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariff"]>

  export type tariffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    category?: boolean
    tariff_name?: boolean
    type?: boolean
    device?: boolean
    min_demand?: boolean
    min_demand_unit_rate?: boolean
    min_demand_excess_unit_rate?: boolean
    base_unit_rate?: boolean
    elec_duty_unit_rate?: boolean
    ims?: boolean
    gst?: boolean
    valid_from?: boolean
    valid_to?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tariff"]>

  export type tariffSelectScalar = {
    id?: boolean
    client_id?: boolean
    category?: boolean
    tariff_name?: boolean
    type?: boolean
    device?: boolean
    min_demand?: boolean
    min_demand_unit_rate?: boolean
    min_demand_excess_unit_rate?: boolean
    base_unit_rate?: boolean
    elec_duty_unit_rate?: boolean
    ims?: boolean
    gst?: boolean
    valid_from?: boolean
    valid_to?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tariffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariff_slabs?: boolean | tariff$tariff_slabsArgs<ExtArgs>
    _count?: boolean | TariffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tariffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tariffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tariff"
    objects: {
      tariff_slabs: Prisma.$tariff_slabsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      client_id: number
      category: number
      tariff_name: string
      type: string
      device: string
      min_demand: number | null
      min_demand_unit_rate: number | null
      min_demand_excess_unit_rate: number | null
      base_unit_rate: number
      elec_duty_unit_rate: number | null
      ims: number | null
      gst: number | null
      valid_from: Date
      valid_to: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tariff"]>
    composites: {}
  }

  type tariffGetPayload<S extends boolean | null | undefined | tariffDefaultArgs> = $Result.GetResult<Prisma.$tariffPayload, S>

  type tariffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tariffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TariffCountAggregateInputType | true
    }

  export interface tariffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tariff'], meta: { name: 'tariff' } }
    /**
     * Find zero or one Tariff that matches the filter.
     * @param {tariffFindUniqueArgs} args - Arguments to find a Tariff
     * @example
     * // Get one Tariff
     * const tariff = await prisma.tariff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tariffFindUniqueArgs>(args: SelectSubset<T, tariffFindUniqueArgs<ExtArgs>>): Prisma__tariffClient<$Result.GetResult<Prisma.$tariffPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tariff that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tariffFindUniqueOrThrowArgs} args - Arguments to find a Tariff
     * @example
     * // Get one Tariff
     * const tariff = await prisma.tariff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tariffFindUniqueOrThrowArgs>(args: SelectSubset<T, tariffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tariffClient<$Result.GetResult<Prisma.$tariffPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tariff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariffFindFirstArgs} args - Arguments to find a Tariff
     * @example
     * // Get one Tariff
     * const tariff = await prisma.tariff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tariffFindFirstArgs>(args?: SelectSubset<T, tariffFindFirstArgs<ExtArgs>>): Prisma__tariffClient<$Result.GetResult<Prisma.$tariffPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tariff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariffFindFirstOrThrowArgs} args - Arguments to find a Tariff
     * @example
     * // Get one Tariff
     * const tariff = await prisma.tariff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tariffFindFirstOrThrowArgs>(args?: SelectSubset<T, tariffFindFirstOrThrowArgs<ExtArgs>>): Prisma__tariffClient<$Result.GetResult<Prisma.$tariffPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tariffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tariffs
     * const tariffs = await prisma.tariff.findMany()
     * 
     * // Get first 10 Tariffs
     * const tariffs = await prisma.tariff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tariffWithIdOnly = await prisma.tariff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tariffFindManyArgs>(args?: SelectSubset<T, tariffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tariffPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tariff.
     * @param {tariffCreateArgs} args - Arguments to create a Tariff.
     * @example
     * // Create one Tariff
     * const Tariff = await prisma.tariff.create({
     *   data: {
     *     // ... data to create a Tariff
     *   }
     * })
     * 
     */
    create<T extends tariffCreateArgs>(args: SelectSubset<T, tariffCreateArgs<ExtArgs>>): Prisma__tariffClient<$Result.GetResult<Prisma.$tariffPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tariffs.
     * @param {tariffCreateManyArgs} args - Arguments to create many Tariffs.
     * @example
     * // Create many Tariffs
     * const tariff = await prisma.tariff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tariffCreateManyArgs>(args?: SelectSubset<T, tariffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tariffs and returns the data saved in the database.
     * @param {tariffCreateManyAndReturnArgs} args - Arguments to create many Tariffs.
     * @example
     * // Create many Tariffs
     * const tariff = await prisma.tariff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tariffs and only return the `id`
     * const tariffWithIdOnly = await prisma.tariff.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tariffCreateManyAndReturnArgs>(args?: SelectSubset<T, tariffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tariffPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tariff.
     * @param {tariffDeleteArgs} args - Arguments to delete one Tariff.
     * @example
     * // Delete one Tariff
     * const Tariff = await prisma.tariff.delete({
     *   where: {
     *     // ... filter to delete one Tariff
     *   }
     * })
     * 
     */
    delete<T extends tariffDeleteArgs>(args: SelectSubset<T, tariffDeleteArgs<ExtArgs>>): Prisma__tariffClient<$Result.GetResult<Prisma.$tariffPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tariff.
     * @param {tariffUpdateArgs} args - Arguments to update one Tariff.
     * @example
     * // Update one Tariff
     * const tariff = await prisma.tariff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tariffUpdateArgs>(args: SelectSubset<T, tariffUpdateArgs<ExtArgs>>): Prisma__tariffClient<$Result.GetResult<Prisma.$tariffPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tariffs.
     * @param {tariffDeleteManyArgs} args - Arguments to filter Tariffs to delete.
     * @example
     * // Delete a few Tariffs
     * const { count } = await prisma.tariff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tariffDeleteManyArgs>(args?: SelectSubset<T, tariffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tariffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tariffs
     * const tariff = await prisma.tariff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tariffUpdateManyArgs>(args: SelectSubset<T, tariffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tariff.
     * @param {tariffUpsertArgs} args - Arguments to update or create a Tariff.
     * @example
     * // Update or create a Tariff
     * const tariff = await prisma.tariff.upsert({
     *   create: {
     *     // ... data to create a Tariff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tariff we want to update
     *   }
     * })
     */
    upsert<T extends tariffUpsertArgs>(args: SelectSubset<T, tariffUpsertArgs<ExtArgs>>): Prisma__tariffClient<$Result.GetResult<Prisma.$tariffPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tariffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariffCountArgs} args - Arguments to filter Tariffs to count.
     * @example
     * // Count the number of Tariffs
     * const count = await prisma.tariff.count({
     *   where: {
     *     // ... the filter for the Tariffs we want to count
     *   }
     * })
    **/
    count<T extends tariffCountArgs>(
      args?: Subset<T, tariffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TariffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tariff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TariffAggregateArgs>(args: Subset<T, TariffAggregateArgs>): Prisma.PrismaPromise<GetTariffAggregateType<T>>

    /**
     * Group by Tariff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tariffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tariffGroupByArgs['orderBy'] }
        : { orderBy?: tariffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tariffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTariffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tariff model
   */
  readonly fields: tariffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tariff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tariffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tariff_slabs<T extends tariff$tariff_slabsArgs<ExtArgs> = {}>(args?: Subset<T, tariff$tariff_slabsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tariff_slabsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tariff model
   */ 
  interface tariffFieldRefs {
    readonly id: FieldRef<"tariff", 'Int'>
    readonly client_id: FieldRef<"tariff", 'Int'>
    readonly category: FieldRef<"tariff", 'Int'>
    readonly tariff_name: FieldRef<"tariff", 'String'>
    readonly type: FieldRef<"tariff", 'String'>
    readonly device: FieldRef<"tariff", 'String'>
    readonly min_demand: FieldRef<"tariff", 'Int'>
    readonly min_demand_unit_rate: FieldRef<"tariff", 'Float'>
    readonly min_demand_excess_unit_rate: FieldRef<"tariff", 'Float'>
    readonly base_unit_rate: FieldRef<"tariff", 'Float'>
    readonly elec_duty_unit_rate: FieldRef<"tariff", 'Float'>
    readonly ims: FieldRef<"tariff", 'Float'>
    readonly gst: FieldRef<"tariff", 'Float'>
    readonly valid_from: FieldRef<"tariff", 'DateTime'>
    readonly valid_to: FieldRef<"tariff", 'DateTime'>
    readonly created_at: FieldRef<"tariff", 'DateTime'>
    readonly updated_at: FieldRef<"tariff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tariff findUnique
   */
  export type tariffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff
     */
    select?: tariffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariffInclude<ExtArgs> | null
    /**
     * Filter, which tariff to fetch.
     */
    where: tariffWhereUniqueInput
  }

  /**
   * tariff findUniqueOrThrow
   */
  export type tariffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff
     */
    select?: tariffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariffInclude<ExtArgs> | null
    /**
     * Filter, which tariff to fetch.
     */
    where: tariffWhereUniqueInput
  }

  /**
   * tariff findFirst
   */
  export type tariffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff
     */
    select?: tariffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariffInclude<ExtArgs> | null
    /**
     * Filter, which tariff to fetch.
     */
    where?: tariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tariffs to fetch.
     */
    orderBy?: tariffOrderByWithRelationInput | tariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tariffs.
     */
    cursor?: tariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tariffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tariffs.
     */
    distinct?: TariffScalarFieldEnum | TariffScalarFieldEnum[]
  }

  /**
   * tariff findFirstOrThrow
   */
  export type tariffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff
     */
    select?: tariffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariffInclude<ExtArgs> | null
    /**
     * Filter, which tariff to fetch.
     */
    where?: tariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tariffs to fetch.
     */
    orderBy?: tariffOrderByWithRelationInput | tariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tariffs.
     */
    cursor?: tariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tariffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tariffs.
     */
    distinct?: TariffScalarFieldEnum | TariffScalarFieldEnum[]
  }

  /**
   * tariff findMany
   */
  export type tariffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff
     */
    select?: tariffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariffInclude<ExtArgs> | null
    /**
     * Filter, which tariffs to fetch.
     */
    where?: tariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tariffs to fetch.
     */
    orderBy?: tariffOrderByWithRelationInput | tariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tariffs.
     */
    cursor?: tariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tariffs.
     */
    skip?: number
    distinct?: TariffScalarFieldEnum | TariffScalarFieldEnum[]
  }

  /**
   * tariff create
   */
  export type tariffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff
     */
    select?: tariffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariffInclude<ExtArgs> | null
    /**
     * The data needed to create a tariff.
     */
    data: XOR<tariffCreateInput, tariffUncheckedCreateInput>
  }

  /**
   * tariff createMany
   */
  export type tariffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tariffs.
     */
    data: tariffCreateManyInput | tariffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tariff createManyAndReturn
   */
  export type tariffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff
     */
    select?: tariffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tariffs.
     */
    data: tariffCreateManyInput | tariffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tariff update
   */
  export type tariffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff
     */
    select?: tariffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariffInclude<ExtArgs> | null
    /**
     * The data needed to update a tariff.
     */
    data: XOR<tariffUpdateInput, tariffUncheckedUpdateInput>
    /**
     * Choose, which tariff to update.
     */
    where: tariffWhereUniqueInput
  }

  /**
   * tariff updateMany
   */
  export type tariffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tariffs.
     */
    data: XOR<tariffUpdateManyMutationInput, tariffUncheckedUpdateManyInput>
    /**
     * Filter which tariffs to update
     */
    where?: tariffWhereInput
  }

  /**
   * tariff upsert
   */
  export type tariffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff
     */
    select?: tariffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariffInclude<ExtArgs> | null
    /**
     * The filter to search for the tariff to update in case it exists.
     */
    where: tariffWhereUniqueInput
    /**
     * In case the tariff found by the `where` argument doesn't exist, create a new tariff with this data.
     */
    create: XOR<tariffCreateInput, tariffUncheckedCreateInput>
    /**
     * In case the tariff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tariffUpdateInput, tariffUncheckedUpdateInput>
  }

  /**
   * tariff delete
   */
  export type tariffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff
     */
    select?: tariffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariffInclude<ExtArgs> | null
    /**
     * Filter which tariff to delete.
     */
    where: tariffWhereUniqueInput
  }

  /**
   * tariff deleteMany
   */
  export type tariffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tariffs to delete
     */
    where?: tariffWhereInput
  }

  /**
   * tariff.tariff_slabs
   */
  export type tariff$tariff_slabsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsInclude<ExtArgs> | null
    where?: tariff_slabsWhereInput
    orderBy?: tariff_slabsOrderByWithRelationInput | tariff_slabsOrderByWithRelationInput[]
    cursor?: tariff_slabsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tariff_slabsScalarFieldEnum | Tariff_slabsScalarFieldEnum[]
  }

  /**
   * tariff without action
   */
  export type tariffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff
     */
    select?: tariffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariffInclude<ExtArgs> | null
  }


  /**
   * Model tariff_slabs
   */

  export type AggregateTariff_slabs = {
    _count: Tariff_slabsCountAggregateOutputType | null
    _avg: Tariff_slabsAvgAggregateOutputType | null
    _sum: Tariff_slabsSumAggregateOutputType | null
    _min: Tariff_slabsMinAggregateOutputType | null
    _max: Tariff_slabsMaxAggregateOutputType | null
  }

  export type Tariff_slabsAvgAggregateOutputType = {
    id: number | null
    tariff_id: number | null
    slab_order: number | null
    unit_limit: number | null
    unit_rate: number | null
  }

  export type Tariff_slabsSumAggregateOutputType = {
    id: number | null
    tariff_id: number | null
    slab_order: number | null
    unit_limit: number | null
    unit_rate: number | null
  }

  export type Tariff_slabsMinAggregateOutputType = {
    id: number | null
    tariff_id: number | null
    slab_order: number | null
    unit_limit: number | null
    unit_rate: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Tariff_slabsMaxAggregateOutputType = {
    id: number | null
    tariff_id: number | null
    slab_order: number | null
    unit_limit: number | null
    unit_rate: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Tariff_slabsCountAggregateOutputType = {
    id: number
    tariff_id: number
    slab_order: number
    unit_limit: number
    unit_rate: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Tariff_slabsAvgAggregateInputType = {
    id?: true
    tariff_id?: true
    slab_order?: true
    unit_limit?: true
    unit_rate?: true
  }

  export type Tariff_slabsSumAggregateInputType = {
    id?: true
    tariff_id?: true
    slab_order?: true
    unit_limit?: true
    unit_rate?: true
  }

  export type Tariff_slabsMinAggregateInputType = {
    id?: true
    tariff_id?: true
    slab_order?: true
    unit_limit?: true
    unit_rate?: true
    created_at?: true
    updated_at?: true
  }

  export type Tariff_slabsMaxAggregateInputType = {
    id?: true
    tariff_id?: true
    slab_order?: true
    unit_limit?: true
    unit_rate?: true
    created_at?: true
    updated_at?: true
  }

  export type Tariff_slabsCountAggregateInputType = {
    id?: true
    tariff_id?: true
    slab_order?: true
    unit_limit?: true
    unit_rate?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Tariff_slabsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tariff_slabs to aggregate.
     */
    where?: tariff_slabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tariff_slabs to fetch.
     */
    orderBy?: tariff_slabsOrderByWithRelationInput | tariff_slabsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tariff_slabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tariff_slabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tariff_slabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tariff_slabs
    **/
    _count?: true | Tariff_slabsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tariff_slabsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tariff_slabsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tariff_slabsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tariff_slabsMaxAggregateInputType
  }

  export type GetTariff_slabsAggregateType<T extends Tariff_slabsAggregateArgs> = {
        [P in keyof T & keyof AggregateTariff_slabs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTariff_slabs[P]>
      : GetScalarType<T[P], AggregateTariff_slabs[P]>
  }




  export type tariff_slabsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tariff_slabsWhereInput
    orderBy?: tariff_slabsOrderByWithAggregationInput | tariff_slabsOrderByWithAggregationInput[]
    by: Tariff_slabsScalarFieldEnum[] | Tariff_slabsScalarFieldEnum
    having?: tariff_slabsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tariff_slabsCountAggregateInputType | true
    _avg?: Tariff_slabsAvgAggregateInputType
    _sum?: Tariff_slabsSumAggregateInputType
    _min?: Tariff_slabsMinAggregateInputType
    _max?: Tariff_slabsMaxAggregateInputType
  }

  export type Tariff_slabsGroupByOutputType = {
    id: number
    tariff_id: number
    slab_order: number
    unit_limit: number
    unit_rate: number
    created_at: Date
    updated_at: Date
    _count: Tariff_slabsCountAggregateOutputType | null
    _avg: Tariff_slabsAvgAggregateOutputType | null
    _sum: Tariff_slabsSumAggregateOutputType | null
    _min: Tariff_slabsMinAggregateOutputType | null
    _max: Tariff_slabsMaxAggregateOutputType | null
  }

  type GetTariff_slabsGroupByPayload<T extends tariff_slabsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tariff_slabsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tariff_slabsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tariff_slabsGroupByOutputType[P]>
            : GetScalarType<T[P], Tariff_slabsGroupByOutputType[P]>
        }
      >
    >


  export type tariff_slabsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tariff_id?: boolean
    slab_order?: boolean
    unit_limit?: boolean
    unit_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
    tariff?: boolean | tariffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariff_slabs"]>

  export type tariff_slabsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tariff_id?: boolean
    slab_order?: boolean
    unit_limit?: boolean
    unit_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
    tariff?: boolean | tariffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariff_slabs"]>

  export type tariff_slabsSelectScalar = {
    id?: boolean
    tariff_id?: boolean
    slab_order?: boolean
    unit_limit?: boolean
    unit_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tariff_slabsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariff?: boolean | tariffDefaultArgs<ExtArgs>
  }
  export type tariff_slabsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariff?: boolean | tariffDefaultArgs<ExtArgs>
  }

  export type $tariff_slabsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tariff_slabs"
    objects: {
      tariff: Prisma.$tariffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tariff_id: number
      slab_order: number
      unit_limit: number
      unit_rate: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tariff_slabs"]>
    composites: {}
  }

  type tariff_slabsGetPayload<S extends boolean | null | undefined | tariff_slabsDefaultArgs> = $Result.GetResult<Prisma.$tariff_slabsPayload, S>

  type tariff_slabsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tariff_slabsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tariff_slabsCountAggregateInputType | true
    }

  export interface tariff_slabsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tariff_slabs'], meta: { name: 'tariff_slabs' } }
    /**
     * Find zero or one Tariff_slabs that matches the filter.
     * @param {tariff_slabsFindUniqueArgs} args - Arguments to find a Tariff_slabs
     * @example
     * // Get one Tariff_slabs
     * const tariff_slabs = await prisma.tariff_slabs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tariff_slabsFindUniqueArgs>(args: SelectSubset<T, tariff_slabsFindUniqueArgs<ExtArgs>>): Prisma__tariff_slabsClient<$Result.GetResult<Prisma.$tariff_slabsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tariff_slabs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tariff_slabsFindUniqueOrThrowArgs} args - Arguments to find a Tariff_slabs
     * @example
     * // Get one Tariff_slabs
     * const tariff_slabs = await prisma.tariff_slabs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tariff_slabsFindUniqueOrThrowArgs>(args: SelectSubset<T, tariff_slabsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tariff_slabsClient<$Result.GetResult<Prisma.$tariff_slabsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tariff_slabs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariff_slabsFindFirstArgs} args - Arguments to find a Tariff_slabs
     * @example
     * // Get one Tariff_slabs
     * const tariff_slabs = await prisma.tariff_slabs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tariff_slabsFindFirstArgs>(args?: SelectSubset<T, tariff_slabsFindFirstArgs<ExtArgs>>): Prisma__tariff_slabsClient<$Result.GetResult<Prisma.$tariff_slabsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tariff_slabs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariff_slabsFindFirstOrThrowArgs} args - Arguments to find a Tariff_slabs
     * @example
     * // Get one Tariff_slabs
     * const tariff_slabs = await prisma.tariff_slabs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tariff_slabsFindFirstOrThrowArgs>(args?: SelectSubset<T, tariff_slabsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tariff_slabsClient<$Result.GetResult<Prisma.$tariff_slabsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tariff_slabs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariff_slabsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tariff_slabs
     * const tariff_slabs = await prisma.tariff_slabs.findMany()
     * 
     * // Get first 10 Tariff_slabs
     * const tariff_slabs = await prisma.tariff_slabs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tariff_slabsWithIdOnly = await prisma.tariff_slabs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tariff_slabsFindManyArgs>(args?: SelectSubset<T, tariff_slabsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tariff_slabsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tariff_slabs.
     * @param {tariff_slabsCreateArgs} args - Arguments to create a Tariff_slabs.
     * @example
     * // Create one Tariff_slabs
     * const Tariff_slabs = await prisma.tariff_slabs.create({
     *   data: {
     *     // ... data to create a Tariff_slabs
     *   }
     * })
     * 
     */
    create<T extends tariff_slabsCreateArgs>(args: SelectSubset<T, tariff_slabsCreateArgs<ExtArgs>>): Prisma__tariff_slabsClient<$Result.GetResult<Prisma.$tariff_slabsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tariff_slabs.
     * @param {tariff_slabsCreateManyArgs} args - Arguments to create many Tariff_slabs.
     * @example
     * // Create many Tariff_slabs
     * const tariff_slabs = await prisma.tariff_slabs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tariff_slabsCreateManyArgs>(args?: SelectSubset<T, tariff_slabsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tariff_slabs and returns the data saved in the database.
     * @param {tariff_slabsCreateManyAndReturnArgs} args - Arguments to create many Tariff_slabs.
     * @example
     * // Create many Tariff_slabs
     * const tariff_slabs = await prisma.tariff_slabs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tariff_slabs and only return the `id`
     * const tariff_slabsWithIdOnly = await prisma.tariff_slabs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tariff_slabsCreateManyAndReturnArgs>(args?: SelectSubset<T, tariff_slabsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tariff_slabsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tariff_slabs.
     * @param {tariff_slabsDeleteArgs} args - Arguments to delete one Tariff_slabs.
     * @example
     * // Delete one Tariff_slabs
     * const Tariff_slabs = await prisma.tariff_slabs.delete({
     *   where: {
     *     // ... filter to delete one Tariff_slabs
     *   }
     * })
     * 
     */
    delete<T extends tariff_slabsDeleteArgs>(args: SelectSubset<T, tariff_slabsDeleteArgs<ExtArgs>>): Prisma__tariff_slabsClient<$Result.GetResult<Prisma.$tariff_slabsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tariff_slabs.
     * @param {tariff_slabsUpdateArgs} args - Arguments to update one Tariff_slabs.
     * @example
     * // Update one Tariff_slabs
     * const tariff_slabs = await prisma.tariff_slabs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tariff_slabsUpdateArgs>(args: SelectSubset<T, tariff_slabsUpdateArgs<ExtArgs>>): Prisma__tariff_slabsClient<$Result.GetResult<Prisma.$tariff_slabsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tariff_slabs.
     * @param {tariff_slabsDeleteManyArgs} args - Arguments to filter Tariff_slabs to delete.
     * @example
     * // Delete a few Tariff_slabs
     * const { count } = await prisma.tariff_slabs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tariff_slabsDeleteManyArgs>(args?: SelectSubset<T, tariff_slabsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tariff_slabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariff_slabsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tariff_slabs
     * const tariff_slabs = await prisma.tariff_slabs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tariff_slabsUpdateManyArgs>(args: SelectSubset<T, tariff_slabsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tariff_slabs.
     * @param {tariff_slabsUpsertArgs} args - Arguments to update or create a Tariff_slabs.
     * @example
     * // Update or create a Tariff_slabs
     * const tariff_slabs = await prisma.tariff_slabs.upsert({
     *   create: {
     *     // ... data to create a Tariff_slabs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tariff_slabs we want to update
     *   }
     * })
     */
    upsert<T extends tariff_slabsUpsertArgs>(args: SelectSubset<T, tariff_slabsUpsertArgs<ExtArgs>>): Prisma__tariff_slabsClient<$Result.GetResult<Prisma.$tariff_slabsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tariff_slabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariff_slabsCountArgs} args - Arguments to filter Tariff_slabs to count.
     * @example
     * // Count the number of Tariff_slabs
     * const count = await prisma.tariff_slabs.count({
     *   where: {
     *     // ... the filter for the Tariff_slabs we want to count
     *   }
     * })
    **/
    count<T extends tariff_slabsCountArgs>(
      args?: Subset<T, tariff_slabsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tariff_slabsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tariff_slabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tariff_slabsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tariff_slabsAggregateArgs>(args: Subset<T, Tariff_slabsAggregateArgs>): Prisma.PrismaPromise<GetTariff_slabsAggregateType<T>>

    /**
     * Group by Tariff_slabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tariff_slabsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tariff_slabsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tariff_slabsGroupByArgs['orderBy'] }
        : { orderBy?: tariff_slabsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tariff_slabsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTariff_slabsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tariff_slabs model
   */
  readonly fields: tariff_slabsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tariff_slabs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tariff_slabsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tariff<T extends tariffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tariffDefaultArgs<ExtArgs>>): Prisma__tariffClient<$Result.GetResult<Prisma.$tariffPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tariff_slabs model
   */ 
  interface tariff_slabsFieldRefs {
    readonly id: FieldRef<"tariff_slabs", 'Int'>
    readonly tariff_id: FieldRef<"tariff_slabs", 'Int'>
    readonly slab_order: FieldRef<"tariff_slabs", 'Int'>
    readonly unit_limit: FieldRef<"tariff_slabs", 'Int'>
    readonly unit_rate: FieldRef<"tariff_slabs", 'Float'>
    readonly created_at: FieldRef<"tariff_slabs", 'DateTime'>
    readonly updated_at: FieldRef<"tariff_slabs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tariff_slabs findUnique
   */
  export type tariff_slabsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsInclude<ExtArgs> | null
    /**
     * Filter, which tariff_slabs to fetch.
     */
    where: tariff_slabsWhereUniqueInput
  }

  /**
   * tariff_slabs findUniqueOrThrow
   */
  export type tariff_slabsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsInclude<ExtArgs> | null
    /**
     * Filter, which tariff_slabs to fetch.
     */
    where: tariff_slabsWhereUniqueInput
  }

  /**
   * tariff_slabs findFirst
   */
  export type tariff_slabsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsInclude<ExtArgs> | null
    /**
     * Filter, which tariff_slabs to fetch.
     */
    where?: tariff_slabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tariff_slabs to fetch.
     */
    orderBy?: tariff_slabsOrderByWithRelationInput | tariff_slabsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tariff_slabs.
     */
    cursor?: tariff_slabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tariff_slabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tariff_slabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tariff_slabs.
     */
    distinct?: Tariff_slabsScalarFieldEnum | Tariff_slabsScalarFieldEnum[]
  }

  /**
   * tariff_slabs findFirstOrThrow
   */
  export type tariff_slabsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsInclude<ExtArgs> | null
    /**
     * Filter, which tariff_slabs to fetch.
     */
    where?: tariff_slabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tariff_slabs to fetch.
     */
    orderBy?: tariff_slabsOrderByWithRelationInput | tariff_slabsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tariff_slabs.
     */
    cursor?: tariff_slabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tariff_slabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tariff_slabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tariff_slabs.
     */
    distinct?: Tariff_slabsScalarFieldEnum | Tariff_slabsScalarFieldEnum[]
  }

  /**
   * tariff_slabs findMany
   */
  export type tariff_slabsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsInclude<ExtArgs> | null
    /**
     * Filter, which tariff_slabs to fetch.
     */
    where?: tariff_slabsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tariff_slabs to fetch.
     */
    orderBy?: tariff_slabsOrderByWithRelationInput | tariff_slabsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tariff_slabs.
     */
    cursor?: tariff_slabsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tariff_slabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tariff_slabs.
     */
    skip?: number
    distinct?: Tariff_slabsScalarFieldEnum | Tariff_slabsScalarFieldEnum[]
  }

  /**
   * tariff_slabs create
   */
  export type tariff_slabsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsInclude<ExtArgs> | null
    /**
     * The data needed to create a tariff_slabs.
     */
    data: XOR<tariff_slabsCreateInput, tariff_slabsUncheckedCreateInput>
  }

  /**
   * tariff_slabs createMany
   */
  export type tariff_slabsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tariff_slabs.
     */
    data: tariff_slabsCreateManyInput | tariff_slabsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tariff_slabs createManyAndReturn
   */
  export type tariff_slabsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tariff_slabs.
     */
    data: tariff_slabsCreateManyInput | tariff_slabsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tariff_slabs update
   */
  export type tariff_slabsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsInclude<ExtArgs> | null
    /**
     * The data needed to update a tariff_slabs.
     */
    data: XOR<tariff_slabsUpdateInput, tariff_slabsUncheckedUpdateInput>
    /**
     * Choose, which tariff_slabs to update.
     */
    where: tariff_slabsWhereUniqueInput
  }

  /**
   * tariff_slabs updateMany
   */
  export type tariff_slabsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tariff_slabs.
     */
    data: XOR<tariff_slabsUpdateManyMutationInput, tariff_slabsUncheckedUpdateManyInput>
    /**
     * Filter which tariff_slabs to update
     */
    where?: tariff_slabsWhereInput
  }

  /**
   * tariff_slabs upsert
   */
  export type tariff_slabsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsInclude<ExtArgs> | null
    /**
     * The filter to search for the tariff_slabs to update in case it exists.
     */
    where: tariff_slabsWhereUniqueInput
    /**
     * In case the tariff_slabs found by the `where` argument doesn't exist, create a new tariff_slabs with this data.
     */
    create: XOR<tariff_slabsCreateInput, tariff_slabsUncheckedCreateInput>
    /**
     * In case the tariff_slabs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tariff_slabsUpdateInput, tariff_slabsUncheckedUpdateInput>
  }

  /**
   * tariff_slabs delete
   */
  export type tariff_slabsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsInclude<ExtArgs> | null
    /**
     * Filter which tariff_slabs to delete.
     */
    where: tariff_slabsWhereUniqueInput
  }

  /**
   * tariff_slabs deleteMany
   */
  export type tariff_slabsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tariff_slabs to delete
     */
    where?: tariff_slabsWhereInput
  }

  /**
   * tariff_slabs without action
   */
  export type tariff_slabsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tariff_slabs
     */
    select?: tariff_slabsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tariff_slabsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BillsScalarFieldEnum: {
    id: 'id',
    billNumber: 'billNumber',
    meterId: 'meterId',
    consumerId: 'consumerId',
    billMonth: 'billMonth',
    billYear: 'billYear',
    fromDate: 'fromDate',
    toDate: 'toDate',
    dueDate: 'dueDate',
    previousReading: 'previousReading',
    currentReading: 'currentReading',
    unitsConsumed: 'unitsConsumed',
    fixedCharge: 'fixedCharge',
    energyCharge: 'energyCharge',
    powerFactorCharge: 'powerFactorCharge',
    otherCharges: 'otherCharges',
    subTotal: 'subTotal',
    taxes: 'taxes',
    totalAmount: 'totalAmount',
    status: 'status',
    isPaid: 'isPaid',
    paidAmount: 'paidAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillsScalarFieldEnum = (typeof BillsScalarFieldEnum)[keyof typeof BillsScalarFieldEnum]


  export const Consumer_documentsScalarFieldEnum: {
    id: 'id',
    consumerId: 'consumerId',
    type: 'type',
    number: 'number',
    fileUrl: 'fileUrl',
    verificationStatus: 'verificationStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Consumer_documentsScalarFieldEnum = (typeof Consumer_documentsScalarFieldEnum)[keyof typeof Consumer_documentsScalarFieldEnum]


  export const ConsumersScalarFieldEnum: {
    id: 'id',
    consumerNumber: 'consumerNumber',
    name: 'name',
    email: 'email',
    primaryPhone: 'primaryPhone',
    alternatePhone: 'alternatePhone',
    idType: 'idType',
    idNumber: 'idNumber',
    connectionType: 'connectionType',
    category: 'category',
    sanctionedLoad: 'sanctionedLoad',
    connectionDate: 'connectionDate',
    locationId: 'locationId',
    billingCycle: 'billingCycle',
    billDeliveryMode: 'billDeliveryMode',
    defaultPaymentMethod: 'defaultPaymentMethod',
    creditScore: 'creditScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConsumersScalarFieldEnum = (typeof ConsumersScalarFieldEnum)[keyof typeof ConsumersScalarFieldEnum]


  export const Current_transformersScalarFieldEnum: {
    id: 'id',
    meterId: 'meterId',
    serialNumber: 'serialNumber',
    manufacturer: 'manufacturer',
    model: 'model',
    ratedPrimary: 'ratedPrimary',
    ratedSecondary: 'ratedSecondary',
    accuracyClass: 'accuracyClass',
    burden: 'burden',
    installationDate: 'installationDate',
    lastTestedDate: 'lastTestedDate',
    nextTestDue: 'nextTestDue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Current_transformersScalarFieldEnum = (typeof Current_transformersScalarFieldEnum)[keyof typeof Current_transformersScalarFieldEnum]


  export const DepartmentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    parentId: 'parentId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentsScalarFieldEnum = (typeof DepartmentsScalarFieldEnum)[keyof typeof DepartmentsScalarFieldEnum]


  export const Dtr_faultsScalarFieldEnum: {
    id: 'id',
    dtrId: 'dtrId',
    faultType: 'faultType',
    severity: 'severity',
    occuredAt: 'occuredAt',
    resolvedAt: 'resolvedAt',
    description: 'description',
    rootCause: 'rootCause',
    resolution: 'resolution',
    affectedMeters: 'affectedMeters',
    outageMinutes: 'outageMinutes',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Dtr_faultsScalarFieldEnum = (typeof Dtr_faultsScalarFieldEnum)[keyof typeof Dtr_faultsScalarFieldEnum]


  export const Dtr_maintenanceScalarFieldEnum: {
    id: 'id',
    dtrId: 'dtrId',
    maintenanceType: 'maintenanceType',
    scheduledDate: 'scheduledDate',
    completedDate: 'completedDate',
    workDone: 'workDone',
    findings: 'findings',
    recommendations: 'recommendations',
    oilDielectricTest: 'oilDielectricTest',
    oilAcidityTest: 'oilAcidityTest',
    moistureContent: 'moistureContent',
    performedBy: 'performedBy',
    verifiedBy: 'verifiedBy',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Dtr_maintenanceScalarFieldEnum = (typeof Dtr_maintenanceScalarFieldEnum)[keyof typeof Dtr_maintenanceScalarFieldEnum]


  export const Dtr_readingsScalarFieldEnum: {
    id: 'id',
    dtrId: 'dtrId',
    readingDate: 'readingDate',
    readingType: 'readingType',
    loadKVA: 'loadKVA',
    loadPercentage: 'loadPercentage',
    primaryVoltage: 'primaryVoltage',
    secondaryVoltage: 'secondaryVoltage',
    primaryCurrent: 'primaryCurrent',
    secondaryCurrent: 'secondaryCurrent',
    powerFactor: 'powerFactor',
    oilTemperature: 'oilTemperature',
    windingTemperature: 'windingTemperature',
    ambientTemperature: 'ambientTemperature',
    frequency: 'frequency',
    voltageUnbalance: 'voltageUnbalance',
    currentUnbalance: 'currentUnbalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Dtr_readingsScalarFieldEnum = (typeof Dtr_readingsScalarFieldEnum)[keyof typeof Dtr_readingsScalarFieldEnum]


  export const DtrsScalarFieldEnum: {
    id: 'id',
    dtrNumber: 'dtrNumber',
    serialNumber: 'serialNumber',
    manufacturer: 'manufacturer',
    model: 'model',
    capacity: 'capacity',
    type: 'type',
    phase: 'phase',
    primaryVoltage: 'primaryVoltage',
    secondaryVoltage: 'secondaryVoltage',
    frequency: 'frequency',
    impedance: 'impedance',
    coolingType: 'coolingType',
    oilType: 'oilType',
    oilCapacity: 'oilCapacity',
    locationId: 'locationId',
    installationDate: 'installationDate',
    commissionDate: 'commissionDate',
    lastMaintenanceDate: 'lastMaintenanceDate',
    maxLoadLimit: 'maxLoadLimit',
    alarmThreshold: 'alarmThreshold',
    tripThreshold: 'tripThreshold',
    status: 'status',
    healthIndex: 'healthIndex',
    temperature: 'temperature',
    loadPercentage: 'loadPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DtrsScalarFieldEnum = (typeof DtrsScalarFieldEnum)[keyof typeof DtrsScalarFieldEnum]


  export const Location_typesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Location_typesScalarFieldEnum = (typeof Location_typesScalarFieldEnum)[keyof typeof Location_typesScalarFieldEnum]


  export const LocationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    locationTypeId: 'locationTypeId',
    parentId: 'parentId',
    latitude: 'latitude',
    longitude: 'longitude',
    address: 'address',
    pincode: 'pincode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationsScalarFieldEnum = (typeof LocationsScalarFieldEnum)[keyof typeof LocationsScalarFieldEnum]


  export const Login_historyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    ipAddress: 'ipAddress',
    deviceInfo: 'deviceInfo',
    location: 'location',
    failureReason: 'failureReason',
    createdAt: 'createdAt'
  };

  export type Login_historyScalarFieldEnum = (typeof Login_historyScalarFieldEnum)[keyof typeof Login_historyScalarFieldEnum]


  export const Meter_configurationsScalarFieldEnum: {
    id: 'id',
    meterId: 'meterId',
    ctRatio: 'ctRatio',
    ctRatioPrimary: 'ctRatioPrimary',
    ctRatioSecondary: 'ctRatioSecondary',
    adoptedCTRatio: 'adoptedCTRatio',
    ctAccuracyClass: 'ctAccuracyClass',
    ctBurden: 'ctBurden',
    ptRatio: 'ptRatio',
    ptRatioPrimary: 'ptRatioPrimary',
    ptRatioSecondary: 'ptRatioSecondary',
    adoptedPTRatio: 'adoptedPTRatio',
    ptAccuracyClass: 'ptAccuracyClass',
    ptBurden: 'ptBurden',
    mf: 'mf',
    vmf: 'vmf',
    cmf: 'cmf',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Meter_configurationsScalarFieldEnum = (typeof Meter_configurationsScalarFieldEnum)[keyof typeof Meter_configurationsScalarFieldEnum]


  export const Meter_readingsScalarFieldEnum: {
    id: 'id',
    meterId: 'meterId',
    readingDate: 'readingDate',
    readingType: 'readingType',
    readingSource: 'readingSource',
    currentReading: 'currentReading',
    previousReading: 'previousReading',
    consumption: 'consumption',
    kWh: 'kWh',
    kVAh: 'kVAh',
    kVARh: 'kVARh',
    powerFactor: 'powerFactor',
    averagePF: 'averagePF',
    minimumPF: 'minimumPF',
    voltageR: 'voltageR',
    voltageY: 'voltageY',
    voltageB: 'voltageB',
    averageVoltage: 'averageVoltage',
    currentR: 'currentR',
    currentY: 'currentY',
    currentB: 'currentB',
    averageCurrent: 'averageCurrent',
    isValid: 'isValid',
    validatedBy: 'validatedBy',
    validatedAt: 'validatedAt',
    billId: 'billId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    kVA: 'kVA',
    kW: 'kW',
    bphPowerFactor: 'bphPowerFactor',
    frequency: 'frequency',
    rphPowerFactor: 'rphPowerFactor',
    yphPowerFactor: 'yphPowerFactor'
  };

  export type Meter_readingsScalarFieldEnum = (typeof Meter_readingsScalarFieldEnum)[keyof typeof Meter_readingsScalarFieldEnum]


  export const MetersScalarFieldEnum: {
    id: 'id',
    meterNumber: 'meterNumber',
    serialNumber: 'serialNumber',
    manufacturer: 'manufacturer',
    model: 'model',
    type: 'type',
    phase: 'phase',
    status: 'status',
    isInUse: 'isInUse',
    installationDate: 'installationDate',
    lastMaintenanceDate: 'lastMaintenanceDate',
    decommissionDate: 'decommissionDate',
    locationId: 'locationId',
    dtrId: 'dtrId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MetersScalarFieldEnum = (typeof MetersScalarFieldEnum)[keyof typeof MetersScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    consumerId: 'consumerId',
    type: 'type',
    title: 'title',
    message: 'message',
    priority: 'priority',
    channels: 'channels',
    status: 'status',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    billId: 'billId',
    amount: 'amount',
    paymentMode: 'paymentMode',
    paymentStatus: 'paymentStatus',
    gatewayResponse: 'gatewayResponse',
    receiptNumber: 'receiptNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const Potential_transformersScalarFieldEnum: {
    id: 'id',
    meterId: 'meterId',
    serialNumber: 'serialNumber',
    manufacturer: 'manufacturer',
    model: 'model',
    ratedPrimary: 'ratedPrimary',
    ratedSecondary: 'ratedSecondary',
    accuracyClass: 'accuracyClass',
    burden: 'burden',
    installationDate: 'installationDate',
    lastTestedDate: 'lastTestedDate',
    nextTestDue: 'nextTestDue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Potential_transformersScalarFieldEnum = (typeof Potential_transformersScalarFieldEnum)[keyof typeof Potential_transformersScalarFieldEnum]


  export const Role_permissionsScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    isGranted: 'isGranted',
    restrictions: 'restrictions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Role_permissionsScalarFieldEnum = (typeof Role_permissionsScalarFieldEnum)[keyof typeof Role_permissionsScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    level: 'level',
    isSystem: 'isSystem',
    isActive: 'isActive',
    accessLevel: 'accessLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const TicketsScalarFieldEnum: {
    id: 'id',
    ticketNumber: 'ticketNumber',
    dtrId: 'dtrId',
    raisedById: 'raisedById',
    assignedToId: 'assignedToId',
    type: 'type',
    category: 'category',
    priority: 'priority',
    status: 'status',
    subject: 'subject',
    description: 'description',
    resolution: 'resolution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketsScalarFieldEnum = (typeof TicketsScalarFieldEnum)[keyof typeof TicketsScalarFieldEnum]


  export const User_activity_logsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    details: 'details',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type User_activity_logsScalarFieldEnum = (typeof User_activity_logsScalarFieldEnum)[keyof typeof User_activity_logsScalarFieldEnum]


  export const User_permissionsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permissionId: 'permissionId',
    isGranted: 'isGranted',
    reason: 'reason',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type User_permissionsScalarFieldEnum = (typeof User_permissionsScalarFieldEnum)[keyof typeof User_permissionsScalarFieldEnum]


  export const User_sessionsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionToken: 'sessionToken',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    location: 'location',
    isActive: 'isActive',
    lastActivityAt: 'lastActivityAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type User_sessionsScalarFieldEnum = (typeof User_sessionsScalarFieldEnum)[keyof typeof User_sessionsScalarFieldEnum]


  export const Refresh_tokensScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Refresh_tokensScalarFieldEnum = (typeof Refresh_tokensScalarFieldEnum)[keyof typeof Refresh_tokensScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    profileImage: 'profileImage',
    isActive: 'isActive',
    isLocked: 'isLocked',
    lastLoginAt: 'lastLoginAt',
    passwordChangedAt: 'passwordChangedAt',
    failedLoginAttempts: 'failedLoginAttempts',
    lockoutUntil: 'lockoutUntil',
    departmentId: 'departmentId',
    roleId: 'roleId',
    locationId: 'locationId',
    accessLevel: 'accessLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Raw_xml_importScalarFieldEnum: {
    id: 'id',
    doc: 'doc',
    imported_at: 'imported_at'
  };

  export type Raw_xml_importScalarFieldEnum = (typeof Raw_xml_importScalarFieldEnum)[keyof typeof Raw_xml_importScalarFieldEnum]


  export const Prepaid_accountsScalarFieldEnum: {
    id: 'id',
    consumerId: 'consumerId',
    accountNumber: 'accountNumber',
    currentBalance: 'currentBalance',
    totalRecharged: 'totalRecharged',
    totalConsumed: 'totalConsumed',
    isActive: 'isActive',
    isBlocked: 'isBlocked',
    blockReason: 'blockReason',
    blockedAt: 'blockedAt',
    blockedBy: 'blockedBy',
    lowBalanceThreshold: 'lowBalanceThreshold',
    emergencyThreshold: 'emergencyThreshold',
    autoRechargeEnabled: 'autoRechargeEnabled',
    autoRechargeAmount: 'autoRechargeAmount',
    autoRechargeThreshold: 'autoRechargeThreshold',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Prepaid_accountsScalarFieldEnum = (typeof Prepaid_accountsScalarFieldEnum)[keyof typeof Prepaid_accountsScalarFieldEnum]


  export const Prepaid_alertsScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    alertType: 'alertType',
    alertLevel: 'alertLevel',
    message: 'message',
    isRead: 'isRead',
    readAt: 'readAt',
    balanceAtAlert: 'balanceAtAlert',
    consumptionAtAlert: 'consumptionAtAlert',
    thresholdValue: 'thresholdValue',
    createdAt: 'createdAt'
  };

  export type Prepaid_alertsScalarFieldEnum = (typeof Prepaid_alertsScalarFieldEnum)[keyof typeof Prepaid_alertsScalarFieldEnum]


  export const Prepaid_rechargesScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    rechargeId: 'rechargeId',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    paymentStatus: 'paymentStatus',
    gatewayName: 'gatewayName',
    gatewayTransactionId: 'gatewayTransactionId',
    gatewayResponse: 'gatewayResponse',
    rechargeType: 'rechargeType',
    rechargeSource: 'rechargeSource',
    isPromotional: 'isPromotional',
    promotionalCode: 'promotionalCode',
    discountAmount: 'discountAmount',
    bonusAmount: 'bonusAmount',
    receiptNumber: 'receiptNumber',
    receiptUrl: 'receiptUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Prepaid_rechargesScalarFieldEnum = (typeof Prepaid_rechargesScalarFieldEnum)[keyof typeof Prepaid_rechargesScalarFieldEnum]


  export const Prepaid_transactionsScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    transactionId: 'transactionId',
    transactionType: 'transactionType',
    amount: 'amount',
    balanceBefore: 'balanceBefore',
    balanceAfter: 'balanceAfter',
    consumptionKWh: 'consumptionKWh',
    ratePerUnit: 'ratePerUnit',
    fixedCharges: 'fixedCharges',
    taxes: 'taxes',
    readingId: 'readingId',
    status: 'status',
    failureReason: 'failureReason',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Prepaid_transactionsScalarFieldEnum = (typeof Prepaid_transactionsScalarFieldEnum)[keyof typeof Prepaid_transactionsScalarFieldEnum]


  export const Tamper_code_descScalarFieldEnum: {
    id: 'id',
    tamperCode: 'tamperCode',
    tamperDesc: 'tamperDesc',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tamper_code_descScalarFieldEnum = (typeof Tamper_code_descScalarFieldEnum)[keyof typeof Tamper_code_descScalarFieldEnum]


  export const Tamper_eventsScalarFieldEnum: {
    id: 'id',
    meterId: 'meterId',
    tamperDatetime: 'tamperDatetime',
    tamperType: 'tamperType',
    tamperStatus: 'tamperStatus',
    avgCurrent: 'avgCurrent',
    avgVoltage: 'avgVoltage',
    avgPowerFactor: 'avgPowerFactor',
    frequency: 'frequency',
    kwh: 'kwh',
    kwhExport: 'kwhExport',
    kwhImport: 'kwhImport',
    kwhNet: 'kwhNet',
    kwhTotal: 'kwhTotal',
    kwExport: 'kwExport',
    kwImport: 'kwImport',
    kvaExport: 'kvaExport',
    kvaImport: 'kvaImport',
    voltageR: 'voltageR',
    voltageY: 'voltageY',
    voltageB: 'voltageB',
    currentR: 'currentR',
    currentY: 'currentY',
    currentB: 'currentB',
    powerFactorR: 'powerFactorR',
    powerFactorY: 'powerFactorY',
    powerFactorB: 'powerFactorB',
    tamperCount: 'tamperCount',
    param1: 'param1',
    param2: 'param2',
    param3: 'param3',
    param4: 'param4',
    param5: 'param5',
    isProcessed: 'isProcessed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tamper_eventsScalarFieldEnum = (typeof Tamper_eventsScalarFieldEnum)[keyof typeof Tamper_eventsScalarFieldEnum]


  export const TariffScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    category: 'category',
    tariff_name: 'tariff_name',
    type: 'type',
    device: 'device',
    min_demand: 'min_demand',
    min_demand_unit_rate: 'min_demand_unit_rate',
    min_demand_excess_unit_rate: 'min_demand_excess_unit_rate',
    base_unit_rate: 'base_unit_rate',
    elec_duty_unit_rate: 'elec_duty_unit_rate',
    ims: 'ims',
    gst: 'gst',
    valid_from: 'valid_from',
    valid_to: 'valid_to',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TariffScalarFieldEnum = (typeof TariffScalarFieldEnum)[keyof typeof TariffScalarFieldEnum]


  export const Tariff_slabsScalarFieldEnum: {
    id: 'id',
    tariff_id: 'tariff_id',
    slab_order: 'slab_order',
    unit_limit: 'unit_limit',
    unit_rate: 'unit_rate',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Tariff_slabsScalarFieldEnum = (typeof Tariff_slabsScalarFieldEnum)[keyof typeof Tariff_slabsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'BillStatus'
   */
  export type EnumBillStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillStatus'>
    


  /**
   * Reference to a field of type 'BillStatus[]'
   */
  export type ListEnumBillStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'VerificationStatus[]'
   */
  export type ListEnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus[]'>
    


  /**
   * Reference to a field of type 'IdType'
   */
  export type EnumIdTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdType'>
    


  /**
   * Reference to a field of type 'IdType[]'
   */
  export type ListEnumIdTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdType[]'>
    


  /**
   * Reference to a field of type 'ConnectionType'
   */
  export type EnumConnectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectionType'>
    


  /**
   * Reference to a field of type 'ConnectionType[]'
   */
  export type ListEnumConnectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConnectionType[]'>
    


  /**
   * Reference to a field of type 'ConsumerCategory'
   */
  export type EnumConsumerCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsumerCategory'>
    


  /**
   * Reference to a field of type 'ConsumerCategory[]'
   */
  export type ListEnumConsumerCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsumerCategory[]'>
    


  /**
   * Reference to a field of type 'BillingCycle'
   */
  export type EnumBillingCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCycle'>
    


  /**
   * Reference to a field of type 'BillingCycle[]'
   */
  export type ListEnumBillingCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCycle[]'>
    


  /**
   * Reference to a field of type 'BillDeliveryMode[]'
   */
  export type ListEnumBillDeliveryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillDeliveryMode[]'>
    


  /**
   * Reference to a field of type 'BillDeliveryMode'
   */
  export type EnumBillDeliveryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillDeliveryMode'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'FaultType'
   */
  export type EnumFaultTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FaultType'>
    


  /**
   * Reference to a field of type 'FaultType[]'
   */
  export type ListEnumFaultTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FaultType[]'>
    


  /**
   * Reference to a field of type 'FaultSeverity'
   */
  export type EnumFaultSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FaultSeverity'>
    


  /**
   * Reference to a field of type 'FaultSeverity[]'
   */
  export type ListEnumFaultSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FaultSeverity[]'>
    


  /**
   * Reference to a field of type 'FaultStatus'
   */
  export type EnumFaultStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FaultStatus'>
    


  /**
   * Reference to a field of type 'FaultStatus[]'
   */
  export type ListEnumFaultStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FaultStatus[]'>
    


  /**
   * Reference to a field of type 'MaintenanceType'
   */
  export type EnumMaintenanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceType'>
    


  /**
   * Reference to a field of type 'MaintenanceType[]'
   */
  export type ListEnumMaintenanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceType[]'>
    


  /**
   * Reference to a field of type 'MaintenanceStatus'
   */
  export type EnumMaintenanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceStatus'>
    


  /**
   * Reference to a field of type 'MaintenanceStatus[]'
   */
  export type ListEnumMaintenanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceStatus[]'>
    


  /**
   * Reference to a field of type 'DTRReadingType'
   */
  export type EnumDTRReadingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DTRReadingType'>
    


  /**
   * Reference to a field of type 'DTRReadingType[]'
   */
  export type ListEnumDTRReadingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DTRReadingType[]'>
    


  /**
   * Reference to a field of type 'DTRType'
   */
  export type EnumDTRTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DTRType'>
    


  /**
   * Reference to a field of type 'DTRType[]'
   */
  export type ListEnumDTRTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DTRType[]'>
    


  /**
   * Reference to a field of type 'CoolingType'
   */
  export type EnumCoolingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoolingType'>
    


  /**
   * Reference to a field of type 'CoolingType[]'
   */
  export type ListEnumCoolingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoolingType[]'>
    


  /**
   * Reference to a field of type 'OilType'
   */
  export type EnumOilTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OilType'>
    


  /**
   * Reference to a field of type 'OilType[]'
   */
  export type ListEnumOilTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OilType[]'>
    


  /**
   * Reference to a field of type 'DTRStatus'
   */
  export type EnumDTRStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DTRStatus'>
    


  /**
   * Reference to a field of type 'DTRStatus[]'
   */
  export type ListEnumDTRStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DTRStatus[]'>
    


  /**
   * Reference to a field of type 'ReadingType'
   */
  export type EnumReadingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReadingType'>
    


  /**
   * Reference to a field of type 'ReadingType[]'
   */
  export type ListEnumReadingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReadingType[]'>
    


  /**
   * Reference to a field of type 'ReadingSource'
   */
  export type EnumReadingSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReadingSource'>
    


  /**
   * Reference to a field of type 'ReadingSource[]'
   */
  export type ListEnumReadingSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReadingSource[]'>
    


  /**
   * Reference to a field of type 'MeterType'
   */
  export type EnumMeterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeterType'>
    


  /**
   * Reference to a field of type 'MeterType[]'
   */
  export type ListEnumMeterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeterType[]'>
    


  /**
   * Reference to a field of type 'MeterStatus'
   */
  export type EnumMeterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeterStatus'>
    


  /**
   * Reference to a field of type 'MeterStatus[]'
   */
  export type ListEnumMeterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeterStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel[]'
   */
  export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel'
   */
  export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'AccessLevel'
   */
  export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel'>
    


  /**
   * Reference to a field of type 'AccessLevel[]'
   */
  export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel[]'>
    


  /**
   * Reference to a field of type 'TicketType'
   */
  export type EnumTicketTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketType'>
    


  /**
   * Reference to a field of type 'TicketType[]'
   */
  export type ListEnumTicketTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketType[]'>
    


  /**
   * Reference to a field of type 'TicketCategory'
   */
  export type EnumTicketCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketCategory'>
    


  /**
   * Reference to a field of type 'TicketCategory[]'
   */
  export type ListEnumTicketCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketCategory[]'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'TicketPriority[]'
   */
  export type ListEnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'PrepaidAlertType'
   */
  export type EnumPrepaidAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidAlertType'>
    


  /**
   * Reference to a field of type 'PrepaidAlertType[]'
   */
  export type ListEnumPrepaidAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidAlertType[]'>
    


  /**
   * Reference to a field of type 'PrepaidAlertLevel'
   */
  export type EnumPrepaidAlertLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidAlertLevel'>
    


  /**
   * Reference to a field of type 'PrepaidAlertLevel[]'
   */
  export type ListEnumPrepaidAlertLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidAlertLevel[]'>
    


  /**
   * Reference to a field of type 'PrepaidRechargeType'
   */
  export type EnumPrepaidRechargeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidRechargeType'>
    


  /**
   * Reference to a field of type 'PrepaidRechargeType[]'
   */
  export type ListEnumPrepaidRechargeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidRechargeType[]'>
    


  /**
   * Reference to a field of type 'PrepaidRechargeSource'
   */
  export type EnumPrepaidRechargeSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidRechargeSource'>
    


  /**
   * Reference to a field of type 'PrepaidRechargeSource[]'
   */
  export type ListEnumPrepaidRechargeSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidRechargeSource[]'>
    


  /**
   * Reference to a field of type 'PrepaidTransactionType'
   */
  export type EnumPrepaidTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidTransactionType'>
    


  /**
   * Reference to a field of type 'PrepaidTransactionType[]'
   */
  export type ListEnumPrepaidTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidTransactionType[]'>
    


  /**
   * Reference to a field of type 'PrepaidTransactionStatus'
   */
  export type EnumPrepaidTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidTransactionStatus'>
    


  /**
   * Reference to a field of type 'PrepaidTransactionStatus[]'
   */
  export type ListEnumPrepaidTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrepaidTransactionStatus[]'>
    


  /**
   * Reference to a field of type 'TamperType'
   */
  export type EnumTamperTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TamperType'>
    


  /**
   * Reference to a field of type 'TamperType[]'
   */
  export type ListEnumTamperTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TamperType[]'>
    


  /**
   * Reference to a field of type 'TamperStatus'
   */
  export type EnumTamperStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TamperStatus'>
    


  /**
   * Reference to a field of type 'TamperStatus[]'
   */
  export type ListEnumTamperStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TamperStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type billsWhereInput = {
    AND?: billsWhereInput | billsWhereInput[]
    OR?: billsWhereInput[]
    NOT?: billsWhereInput | billsWhereInput[]
    id?: IntFilter<"bills"> | number
    billNumber?: StringFilter<"bills"> | string
    meterId?: IntFilter<"bills"> | number
    consumerId?: IntFilter<"bills"> | number
    billMonth?: IntFilter<"bills"> | number
    billYear?: IntFilter<"bills"> | number
    fromDate?: DateTimeFilter<"bills"> | Date | string
    toDate?: DateTimeFilter<"bills"> | Date | string
    dueDate?: DateTimeFilter<"bills"> | Date | string
    previousReading?: FloatFilter<"bills"> | number
    currentReading?: FloatFilter<"bills"> | number
    unitsConsumed?: FloatFilter<"bills"> | number
    fixedCharge?: FloatFilter<"bills"> | number
    energyCharge?: FloatFilter<"bills"> | number
    powerFactorCharge?: FloatNullableFilter<"bills"> | number | null
    otherCharges?: JsonNullableFilter<"bills">
    subTotal?: FloatFilter<"bills"> | number
    taxes?: JsonFilter<"bills">
    totalAmount?: FloatFilter<"bills"> | number
    status?: EnumBillStatusFilter<"bills"> | $Enums.BillStatus
    isPaid?: BoolFilter<"bills"> | boolean
    paidAmount?: FloatFilter<"bills"> | number
    createdAt?: DateTimeFilter<"bills"> | Date | string
    updatedAt?: DateTimeFilter<"bills"> | Date | string
    consumers?: XOR<ConsumersRelationFilter, consumersWhereInput>
    meters?: XOR<MetersRelationFilter, metersWhereInput>
    meter_readings?: Meter_readingsListRelationFilter
    payments?: PaymentsListRelationFilter
  }

  export type billsOrderByWithRelationInput = {
    id?: SortOrder
    billNumber?: SortOrder
    meterId?: SortOrder
    consumerId?: SortOrder
    billMonth?: SortOrder
    billYear?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    dueDate?: SortOrder
    previousReading?: SortOrder
    currentReading?: SortOrder
    unitsConsumed?: SortOrder
    fixedCharge?: SortOrder
    energyCharge?: SortOrder
    powerFactorCharge?: SortOrderInput | SortOrder
    otherCharges?: SortOrderInput | SortOrder
    subTotal?: SortOrder
    taxes?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    isPaid?: SortOrder
    paidAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consumers?: consumersOrderByWithRelationInput
    meters?: metersOrderByWithRelationInput
    meter_readings?: meter_readingsOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
  }

  export type billsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    billNumber?: string
    AND?: billsWhereInput | billsWhereInput[]
    OR?: billsWhereInput[]
    NOT?: billsWhereInput | billsWhereInput[]
    meterId?: IntFilter<"bills"> | number
    consumerId?: IntFilter<"bills"> | number
    billMonth?: IntFilter<"bills"> | number
    billYear?: IntFilter<"bills"> | number
    fromDate?: DateTimeFilter<"bills"> | Date | string
    toDate?: DateTimeFilter<"bills"> | Date | string
    dueDate?: DateTimeFilter<"bills"> | Date | string
    previousReading?: FloatFilter<"bills"> | number
    currentReading?: FloatFilter<"bills"> | number
    unitsConsumed?: FloatFilter<"bills"> | number
    fixedCharge?: FloatFilter<"bills"> | number
    energyCharge?: FloatFilter<"bills"> | number
    powerFactorCharge?: FloatNullableFilter<"bills"> | number | null
    otherCharges?: JsonNullableFilter<"bills">
    subTotal?: FloatFilter<"bills"> | number
    taxes?: JsonFilter<"bills">
    totalAmount?: FloatFilter<"bills"> | number
    status?: EnumBillStatusFilter<"bills"> | $Enums.BillStatus
    isPaid?: BoolFilter<"bills"> | boolean
    paidAmount?: FloatFilter<"bills"> | number
    createdAt?: DateTimeFilter<"bills"> | Date | string
    updatedAt?: DateTimeFilter<"bills"> | Date | string
    consumers?: XOR<ConsumersRelationFilter, consumersWhereInput>
    meters?: XOR<MetersRelationFilter, metersWhereInput>
    meter_readings?: Meter_readingsListRelationFilter
    payments?: PaymentsListRelationFilter
  }, "id" | "billNumber">

  export type billsOrderByWithAggregationInput = {
    id?: SortOrder
    billNumber?: SortOrder
    meterId?: SortOrder
    consumerId?: SortOrder
    billMonth?: SortOrder
    billYear?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    dueDate?: SortOrder
    previousReading?: SortOrder
    currentReading?: SortOrder
    unitsConsumed?: SortOrder
    fixedCharge?: SortOrder
    energyCharge?: SortOrder
    powerFactorCharge?: SortOrderInput | SortOrder
    otherCharges?: SortOrderInput | SortOrder
    subTotal?: SortOrder
    taxes?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    isPaid?: SortOrder
    paidAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: billsCountOrderByAggregateInput
    _avg?: billsAvgOrderByAggregateInput
    _max?: billsMaxOrderByAggregateInput
    _min?: billsMinOrderByAggregateInput
    _sum?: billsSumOrderByAggregateInput
  }

  export type billsScalarWhereWithAggregatesInput = {
    AND?: billsScalarWhereWithAggregatesInput | billsScalarWhereWithAggregatesInput[]
    OR?: billsScalarWhereWithAggregatesInput[]
    NOT?: billsScalarWhereWithAggregatesInput | billsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bills"> | number
    billNumber?: StringWithAggregatesFilter<"bills"> | string
    meterId?: IntWithAggregatesFilter<"bills"> | number
    consumerId?: IntWithAggregatesFilter<"bills"> | number
    billMonth?: IntWithAggregatesFilter<"bills"> | number
    billYear?: IntWithAggregatesFilter<"bills"> | number
    fromDate?: DateTimeWithAggregatesFilter<"bills"> | Date | string
    toDate?: DateTimeWithAggregatesFilter<"bills"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"bills"> | Date | string
    previousReading?: FloatWithAggregatesFilter<"bills"> | number
    currentReading?: FloatWithAggregatesFilter<"bills"> | number
    unitsConsumed?: FloatWithAggregatesFilter<"bills"> | number
    fixedCharge?: FloatWithAggregatesFilter<"bills"> | number
    energyCharge?: FloatWithAggregatesFilter<"bills"> | number
    powerFactorCharge?: FloatNullableWithAggregatesFilter<"bills"> | number | null
    otherCharges?: JsonNullableWithAggregatesFilter<"bills">
    subTotal?: FloatWithAggregatesFilter<"bills"> | number
    taxes?: JsonWithAggregatesFilter<"bills">
    totalAmount?: FloatWithAggregatesFilter<"bills"> | number
    status?: EnumBillStatusWithAggregatesFilter<"bills"> | $Enums.BillStatus
    isPaid?: BoolWithAggregatesFilter<"bills"> | boolean
    paidAmount?: FloatWithAggregatesFilter<"bills"> | number
    createdAt?: DateTimeWithAggregatesFilter<"bills"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"bills"> | Date | string
  }

  export type consumer_documentsWhereInput = {
    AND?: consumer_documentsWhereInput | consumer_documentsWhereInput[]
    OR?: consumer_documentsWhereInput[]
    NOT?: consumer_documentsWhereInput | consumer_documentsWhereInput[]
    id?: IntFilter<"consumer_documents"> | number
    consumerId?: IntFilter<"consumer_documents"> | number
    type?: EnumDocumentTypeFilter<"consumer_documents"> | $Enums.DocumentType
    number?: StringFilter<"consumer_documents"> | string
    fileUrl?: StringFilter<"consumer_documents"> | string
    verificationStatus?: EnumVerificationStatusFilter<"consumer_documents"> | $Enums.VerificationStatus
    createdAt?: DateTimeFilter<"consumer_documents"> | Date | string
    updatedAt?: DateTimeFilter<"consumer_documents"> | Date | string
    consumers?: XOR<ConsumersRelationFilter, consumersWhereInput>
  }

  export type consumer_documentsOrderByWithRelationInput = {
    id?: SortOrder
    consumerId?: SortOrder
    type?: SortOrder
    number?: SortOrder
    fileUrl?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consumers?: consumersOrderByWithRelationInput
  }

  export type consumer_documentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: consumer_documentsWhereInput | consumer_documentsWhereInput[]
    OR?: consumer_documentsWhereInput[]
    NOT?: consumer_documentsWhereInput | consumer_documentsWhereInput[]
    consumerId?: IntFilter<"consumer_documents"> | number
    type?: EnumDocumentTypeFilter<"consumer_documents"> | $Enums.DocumentType
    number?: StringFilter<"consumer_documents"> | string
    fileUrl?: StringFilter<"consumer_documents"> | string
    verificationStatus?: EnumVerificationStatusFilter<"consumer_documents"> | $Enums.VerificationStatus
    createdAt?: DateTimeFilter<"consumer_documents"> | Date | string
    updatedAt?: DateTimeFilter<"consumer_documents"> | Date | string
    consumers?: XOR<ConsumersRelationFilter, consumersWhereInput>
  }, "id">

  export type consumer_documentsOrderByWithAggregationInput = {
    id?: SortOrder
    consumerId?: SortOrder
    type?: SortOrder
    number?: SortOrder
    fileUrl?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: consumer_documentsCountOrderByAggregateInput
    _avg?: consumer_documentsAvgOrderByAggregateInput
    _max?: consumer_documentsMaxOrderByAggregateInput
    _min?: consumer_documentsMinOrderByAggregateInput
    _sum?: consumer_documentsSumOrderByAggregateInput
  }

  export type consumer_documentsScalarWhereWithAggregatesInput = {
    AND?: consumer_documentsScalarWhereWithAggregatesInput | consumer_documentsScalarWhereWithAggregatesInput[]
    OR?: consumer_documentsScalarWhereWithAggregatesInput[]
    NOT?: consumer_documentsScalarWhereWithAggregatesInput | consumer_documentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"consumer_documents"> | number
    consumerId?: IntWithAggregatesFilter<"consumer_documents"> | number
    type?: EnumDocumentTypeWithAggregatesFilter<"consumer_documents"> | $Enums.DocumentType
    number?: StringWithAggregatesFilter<"consumer_documents"> | string
    fileUrl?: StringWithAggregatesFilter<"consumer_documents"> | string
    verificationStatus?: EnumVerificationStatusWithAggregatesFilter<"consumer_documents"> | $Enums.VerificationStatus
    createdAt?: DateTimeWithAggregatesFilter<"consumer_documents"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"consumer_documents"> | Date | string
  }

  export type consumersWhereInput = {
    AND?: consumersWhereInput | consumersWhereInput[]
    OR?: consumersWhereInput[]
    NOT?: consumersWhereInput | consumersWhereInput[]
    id?: IntFilter<"consumers"> | number
    consumerNumber?: StringFilter<"consumers"> | string
    name?: StringFilter<"consumers"> | string
    email?: StringNullableFilter<"consumers"> | string | null
    primaryPhone?: StringFilter<"consumers"> | string
    alternatePhone?: StringNullableFilter<"consumers"> | string | null
    idType?: EnumIdTypeFilter<"consumers"> | $Enums.IdType
    idNumber?: StringFilter<"consumers"> | string
    connectionType?: EnumConnectionTypeFilter<"consumers"> | $Enums.ConnectionType
    category?: EnumConsumerCategoryFilter<"consumers"> | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFilter<"consumers"> | number
    connectionDate?: DateTimeFilter<"consumers"> | Date | string
    locationId?: IntFilter<"consumers"> | number
    billingCycle?: EnumBillingCycleFilter<"consumers"> | $Enums.BillingCycle
    billDeliveryMode?: EnumBillDeliveryModeNullableListFilter<"consumers">
    defaultPaymentMethod?: EnumPaymentMethodNullableFilter<"consumers"> | $Enums.PaymentMethod | null
    creditScore?: IntNullableFilter<"consumers"> | number | null
    createdAt?: DateTimeFilter<"consumers"> | Date | string
    updatedAt?: DateTimeFilter<"consumers"> | Date | string
    bills?: BillsListRelationFilter
    consumer_documents?: Consumer_documentsListRelationFilter
    locations?: XOR<LocationsRelationFilter, locationsWhereInput>
    notifications?: NotificationsListRelationFilter
    prepaid_accounts?: XOR<Prepaid_accountsNullableRelationFilter, prepaid_accountsWhereInput> | null
  }

  export type consumersOrderByWithRelationInput = {
    id?: SortOrder
    consumerNumber?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    primaryPhone?: SortOrder
    alternatePhone?: SortOrderInput | SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    connectionType?: SortOrder
    category?: SortOrder
    sanctionedLoad?: SortOrder
    connectionDate?: SortOrder
    locationId?: SortOrder
    billingCycle?: SortOrder
    billDeliveryMode?: SortOrder
    defaultPaymentMethod?: SortOrderInput | SortOrder
    creditScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bills?: billsOrderByRelationAggregateInput
    consumer_documents?: consumer_documentsOrderByRelationAggregateInput
    locations?: locationsOrderByWithRelationInput
    notifications?: notificationsOrderByRelationAggregateInput
    prepaid_accounts?: prepaid_accountsOrderByWithRelationInput
  }

  export type consumersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    consumerNumber?: string
    locationId?: number
    AND?: consumersWhereInput | consumersWhereInput[]
    OR?: consumersWhereInput[]
    NOT?: consumersWhereInput | consumersWhereInput[]
    name?: StringFilter<"consumers"> | string
    email?: StringNullableFilter<"consumers"> | string | null
    primaryPhone?: StringFilter<"consumers"> | string
    alternatePhone?: StringNullableFilter<"consumers"> | string | null
    idType?: EnumIdTypeFilter<"consumers"> | $Enums.IdType
    idNumber?: StringFilter<"consumers"> | string
    connectionType?: EnumConnectionTypeFilter<"consumers"> | $Enums.ConnectionType
    category?: EnumConsumerCategoryFilter<"consumers"> | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFilter<"consumers"> | number
    connectionDate?: DateTimeFilter<"consumers"> | Date | string
    billingCycle?: EnumBillingCycleFilter<"consumers"> | $Enums.BillingCycle
    billDeliveryMode?: EnumBillDeliveryModeNullableListFilter<"consumers">
    defaultPaymentMethod?: EnumPaymentMethodNullableFilter<"consumers"> | $Enums.PaymentMethod | null
    creditScore?: IntNullableFilter<"consumers"> | number | null
    createdAt?: DateTimeFilter<"consumers"> | Date | string
    updatedAt?: DateTimeFilter<"consumers"> | Date | string
    bills?: BillsListRelationFilter
    consumer_documents?: Consumer_documentsListRelationFilter
    locations?: XOR<LocationsRelationFilter, locationsWhereInput>
    notifications?: NotificationsListRelationFilter
    prepaid_accounts?: XOR<Prepaid_accountsNullableRelationFilter, prepaid_accountsWhereInput> | null
  }, "id" | "consumerNumber" | "locationId">

  export type consumersOrderByWithAggregationInput = {
    id?: SortOrder
    consumerNumber?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    primaryPhone?: SortOrder
    alternatePhone?: SortOrderInput | SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    connectionType?: SortOrder
    category?: SortOrder
    sanctionedLoad?: SortOrder
    connectionDate?: SortOrder
    locationId?: SortOrder
    billingCycle?: SortOrder
    billDeliveryMode?: SortOrder
    defaultPaymentMethod?: SortOrderInput | SortOrder
    creditScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: consumersCountOrderByAggregateInput
    _avg?: consumersAvgOrderByAggregateInput
    _max?: consumersMaxOrderByAggregateInput
    _min?: consumersMinOrderByAggregateInput
    _sum?: consumersSumOrderByAggregateInput
  }

  export type consumersScalarWhereWithAggregatesInput = {
    AND?: consumersScalarWhereWithAggregatesInput | consumersScalarWhereWithAggregatesInput[]
    OR?: consumersScalarWhereWithAggregatesInput[]
    NOT?: consumersScalarWhereWithAggregatesInput | consumersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"consumers"> | number
    consumerNumber?: StringWithAggregatesFilter<"consumers"> | string
    name?: StringWithAggregatesFilter<"consumers"> | string
    email?: StringNullableWithAggregatesFilter<"consumers"> | string | null
    primaryPhone?: StringWithAggregatesFilter<"consumers"> | string
    alternatePhone?: StringNullableWithAggregatesFilter<"consumers"> | string | null
    idType?: EnumIdTypeWithAggregatesFilter<"consumers"> | $Enums.IdType
    idNumber?: StringWithAggregatesFilter<"consumers"> | string
    connectionType?: EnumConnectionTypeWithAggregatesFilter<"consumers"> | $Enums.ConnectionType
    category?: EnumConsumerCategoryWithAggregatesFilter<"consumers"> | $Enums.ConsumerCategory
    sanctionedLoad?: FloatWithAggregatesFilter<"consumers"> | number
    connectionDate?: DateTimeWithAggregatesFilter<"consumers"> | Date | string
    locationId?: IntWithAggregatesFilter<"consumers"> | number
    billingCycle?: EnumBillingCycleWithAggregatesFilter<"consumers"> | $Enums.BillingCycle
    billDeliveryMode?: EnumBillDeliveryModeNullableListFilter<"consumers">
    defaultPaymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"consumers"> | $Enums.PaymentMethod | null
    creditScore?: IntNullableWithAggregatesFilter<"consumers"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"consumers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"consumers"> | Date | string
  }

  export type current_transformersWhereInput = {
    AND?: current_transformersWhereInput | current_transformersWhereInput[]
    OR?: current_transformersWhereInput[]
    NOT?: current_transformersWhereInput | current_transformersWhereInput[]
    id?: IntFilter<"current_transformers"> | number
    meterId?: IntFilter<"current_transformers"> | number
    serialNumber?: StringFilter<"current_transformers"> | string
    manufacturer?: StringFilter<"current_transformers"> | string
    model?: StringFilter<"current_transformers"> | string
    ratedPrimary?: FloatFilter<"current_transformers"> | number
    ratedSecondary?: FloatFilter<"current_transformers"> | number
    accuracyClass?: StringFilter<"current_transformers"> | string
    burden?: FloatFilter<"current_transformers"> | number
    installationDate?: DateTimeFilter<"current_transformers"> | Date | string
    lastTestedDate?: DateTimeNullableFilter<"current_transformers"> | Date | string | null
    nextTestDue?: DateTimeNullableFilter<"current_transformers"> | Date | string | null
    createdAt?: DateTimeFilter<"current_transformers"> | Date | string
    updatedAt?: DateTimeFilter<"current_transformers"> | Date | string
    meters?: XOR<MetersRelationFilter, metersWhereInput>
  }

  export type current_transformersOrderByWithRelationInput = {
    id?: SortOrder
    meterId?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    accuracyClass?: SortOrder
    burden?: SortOrder
    installationDate?: SortOrder
    lastTestedDate?: SortOrderInput | SortOrder
    nextTestDue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meters?: metersOrderByWithRelationInput
  }

  export type current_transformersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serialNumber?: string
    AND?: current_transformersWhereInput | current_transformersWhereInput[]
    OR?: current_transformersWhereInput[]
    NOT?: current_transformersWhereInput | current_transformersWhereInput[]
    meterId?: IntFilter<"current_transformers"> | number
    manufacturer?: StringFilter<"current_transformers"> | string
    model?: StringFilter<"current_transformers"> | string
    ratedPrimary?: FloatFilter<"current_transformers"> | number
    ratedSecondary?: FloatFilter<"current_transformers"> | number
    accuracyClass?: StringFilter<"current_transformers"> | string
    burden?: FloatFilter<"current_transformers"> | number
    installationDate?: DateTimeFilter<"current_transformers"> | Date | string
    lastTestedDate?: DateTimeNullableFilter<"current_transformers"> | Date | string | null
    nextTestDue?: DateTimeNullableFilter<"current_transformers"> | Date | string | null
    createdAt?: DateTimeFilter<"current_transformers"> | Date | string
    updatedAt?: DateTimeFilter<"current_transformers"> | Date | string
    meters?: XOR<MetersRelationFilter, metersWhereInput>
  }, "id" | "serialNumber">

  export type current_transformersOrderByWithAggregationInput = {
    id?: SortOrder
    meterId?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    accuracyClass?: SortOrder
    burden?: SortOrder
    installationDate?: SortOrder
    lastTestedDate?: SortOrderInput | SortOrder
    nextTestDue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: current_transformersCountOrderByAggregateInput
    _avg?: current_transformersAvgOrderByAggregateInput
    _max?: current_transformersMaxOrderByAggregateInput
    _min?: current_transformersMinOrderByAggregateInput
    _sum?: current_transformersSumOrderByAggregateInput
  }

  export type current_transformersScalarWhereWithAggregatesInput = {
    AND?: current_transformersScalarWhereWithAggregatesInput | current_transformersScalarWhereWithAggregatesInput[]
    OR?: current_transformersScalarWhereWithAggregatesInput[]
    NOT?: current_transformersScalarWhereWithAggregatesInput | current_transformersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"current_transformers"> | number
    meterId?: IntWithAggregatesFilter<"current_transformers"> | number
    serialNumber?: StringWithAggregatesFilter<"current_transformers"> | string
    manufacturer?: StringWithAggregatesFilter<"current_transformers"> | string
    model?: StringWithAggregatesFilter<"current_transformers"> | string
    ratedPrimary?: FloatWithAggregatesFilter<"current_transformers"> | number
    ratedSecondary?: FloatWithAggregatesFilter<"current_transformers"> | number
    accuracyClass?: StringWithAggregatesFilter<"current_transformers"> | string
    burden?: FloatWithAggregatesFilter<"current_transformers"> | number
    installationDate?: DateTimeWithAggregatesFilter<"current_transformers"> | Date | string
    lastTestedDate?: DateTimeNullableWithAggregatesFilter<"current_transformers"> | Date | string | null
    nextTestDue?: DateTimeNullableWithAggregatesFilter<"current_transformers"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"current_transformers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"current_transformers"> | Date | string
  }

  export type departmentsWhereInput = {
    AND?: departmentsWhereInput | departmentsWhereInput[]
    OR?: departmentsWhereInput[]
    NOT?: departmentsWhereInput | departmentsWhereInput[]
    id?: IntFilter<"departments"> | number
    name?: StringFilter<"departments"> | string
    code?: StringFilter<"departments"> | string
    description?: StringNullableFilter<"departments"> | string | null
    parentId?: IntNullableFilter<"departments"> | number | null
    isActive?: BoolFilter<"departments"> | boolean
    createdAt?: DateTimeFilter<"departments"> | Date | string
    updatedAt?: DateTimeFilter<"departments"> | Date | string
    parent?: XOR<DepartmentsNullableRelationFilter, departmentsWhereInput> | null
    children?: DepartmentsListRelationFilter
    users?: UsersListRelationFilter
  }

  export type departmentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: departmentsOrderByWithRelationInput
    children?: departmentsOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
  }

  export type departmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    code?: string
    AND?: departmentsWhereInput | departmentsWhereInput[]
    OR?: departmentsWhereInput[]
    NOT?: departmentsWhereInput | departmentsWhereInput[]
    description?: StringNullableFilter<"departments"> | string | null
    parentId?: IntNullableFilter<"departments"> | number | null
    isActive?: BoolFilter<"departments"> | boolean
    createdAt?: DateTimeFilter<"departments"> | Date | string
    updatedAt?: DateTimeFilter<"departments"> | Date | string
    parent?: XOR<DepartmentsNullableRelationFilter, departmentsWhereInput> | null
    children?: DepartmentsListRelationFilter
    users?: UsersListRelationFilter
  }, "id" | "name" | "code">

  export type departmentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: departmentsCountOrderByAggregateInput
    _avg?: departmentsAvgOrderByAggregateInput
    _max?: departmentsMaxOrderByAggregateInput
    _min?: departmentsMinOrderByAggregateInput
    _sum?: departmentsSumOrderByAggregateInput
  }

  export type departmentsScalarWhereWithAggregatesInput = {
    AND?: departmentsScalarWhereWithAggregatesInput | departmentsScalarWhereWithAggregatesInput[]
    OR?: departmentsScalarWhereWithAggregatesInput[]
    NOT?: departmentsScalarWhereWithAggregatesInput | departmentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"departments"> | number
    name?: StringWithAggregatesFilter<"departments"> | string
    code?: StringWithAggregatesFilter<"departments"> | string
    description?: StringNullableWithAggregatesFilter<"departments"> | string | null
    parentId?: IntNullableWithAggregatesFilter<"departments"> | number | null
    isActive?: BoolWithAggregatesFilter<"departments"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"departments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"departments"> | Date | string
  }

  export type dtr_faultsWhereInput = {
    AND?: dtr_faultsWhereInput | dtr_faultsWhereInput[]
    OR?: dtr_faultsWhereInput[]
    NOT?: dtr_faultsWhereInput | dtr_faultsWhereInput[]
    id?: IntFilter<"dtr_faults"> | number
    dtrId?: IntFilter<"dtr_faults"> | number
    faultType?: EnumFaultTypeFilter<"dtr_faults"> | $Enums.FaultType
    severity?: EnumFaultSeverityFilter<"dtr_faults"> | $Enums.FaultSeverity
    occuredAt?: DateTimeFilter<"dtr_faults"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"dtr_faults"> | Date | string | null
    description?: StringFilter<"dtr_faults"> | string
    rootCause?: StringNullableFilter<"dtr_faults"> | string | null
    resolution?: StringNullableFilter<"dtr_faults"> | string | null
    affectedMeters?: IntNullableFilter<"dtr_faults"> | number | null
    outageMinutes?: IntNullableFilter<"dtr_faults"> | number | null
    status?: EnumFaultStatusFilter<"dtr_faults"> | $Enums.FaultStatus
    createdAt?: DateTimeFilter<"dtr_faults"> | Date | string
    updatedAt?: DateTimeFilter<"dtr_faults"> | Date | string
    dtrs?: XOR<DtrsRelationFilter, dtrsWhereInput>
  }

  export type dtr_faultsOrderByWithRelationInput = {
    id?: SortOrder
    dtrId?: SortOrder
    faultType?: SortOrder
    severity?: SortOrder
    occuredAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    description?: SortOrder
    rootCause?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    affectedMeters?: SortOrderInput | SortOrder
    outageMinutes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dtrs?: dtrsOrderByWithRelationInput
  }

  export type dtr_faultsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: dtr_faultsWhereInput | dtr_faultsWhereInput[]
    OR?: dtr_faultsWhereInput[]
    NOT?: dtr_faultsWhereInput | dtr_faultsWhereInput[]
    dtrId?: IntFilter<"dtr_faults"> | number
    faultType?: EnumFaultTypeFilter<"dtr_faults"> | $Enums.FaultType
    severity?: EnumFaultSeverityFilter<"dtr_faults"> | $Enums.FaultSeverity
    occuredAt?: DateTimeFilter<"dtr_faults"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"dtr_faults"> | Date | string | null
    description?: StringFilter<"dtr_faults"> | string
    rootCause?: StringNullableFilter<"dtr_faults"> | string | null
    resolution?: StringNullableFilter<"dtr_faults"> | string | null
    affectedMeters?: IntNullableFilter<"dtr_faults"> | number | null
    outageMinutes?: IntNullableFilter<"dtr_faults"> | number | null
    status?: EnumFaultStatusFilter<"dtr_faults"> | $Enums.FaultStatus
    createdAt?: DateTimeFilter<"dtr_faults"> | Date | string
    updatedAt?: DateTimeFilter<"dtr_faults"> | Date | string
    dtrs?: XOR<DtrsRelationFilter, dtrsWhereInput>
  }, "id">

  export type dtr_faultsOrderByWithAggregationInput = {
    id?: SortOrder
    dtrId?: SortOrder
    faultType?: SortOrder
    severity?: SortOrder
    occuredAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    description?: SortOrder
    rootCause?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    affectedMeters?: SortOrderInput | SortOrder
    outageMinutes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: dtr_faultsCountOrderByAggregateInput
    _avg?: dtr_faultsAvgOrderByAggregateInput
    _max?: dtr_faultsMaxOrderByAggregateInput
    _min?: dtr_faultsMinOrderByAggregateInput
    _sum?: dtr_faultsSumOrderByAggregateInput
  }

  export type dtr_faultsScalarWhereWithAggregatesInput = {
    AND?: dtr_faultsScalarWhereWithAggregatesInput | dtr_faultsScalarWhereWithAggregatesInput[]
    OR?: dtr_faultsScalarWhereWithAggregatesInput[]
    NOT?: dtr_faultsScalarWhereWithAggregatesInput | dtr_faultsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"dtr_faults"> | number
    dtrId?: IntWithAggregatesFilter<"dtr_faults"> | number
    faultType?: EnumFaultTypeWithAggregatesFilter<"dtr_faults"> | $Enums.FaultType
    severity?: EnumFaultSeverityWithAggregatesFilter<"dtr_faults"> | $Enums.FaultSeverity
    occuredAt?: DateTimeWithAggregatesFilter<"dtr_faults"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"dtr_faults"> | Date | string | null
    description?: StringWithAggregatesFilter<"dtr_faults"> | string
    rootCause?: StringNullableWithAggregatesFilter<"dtr_faults"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"dtr_faults"> | string | null
    affectedMeters?: IntNullableWithAggregatesFilter<"dtr_faults"> | number | null
    outageMinutes?: IntNullableWithAggregatesFilter<"dtr_faults"> | number | null
    status?: EnumFaultStatusWithAggregatesFilter<"dtr_faults"> | $Enums.FaultStatus
    createdAt?: DateTimeWithAggregatesFilter<"dtr_faults"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"dtr_faults"> | Date | string
  }

  export type dtr_maintenanceWhereInput = {
    AND?: dtr_maintenanceWhereInput | dtr_maintenanceWhereInput[]
    OR?: dtr_maintenanceWhereInput[]
    NOT?: dtr_maintenanceWhereInput | dtr_maintenanceWhereInput[]
    id?: IntFilter<"dtr_maintenance"> | number
    dtrId?: IntFilter<"dtr_maintenance"> | number
    maintenanceType?: EnumMaintenanceTypeFilter<"dtr_maintenance"> | $Enums.MaintenanceType
    scheduledDate?: DateTimeFilter<"dtr_maintenance"> | Date | string
    completedDate?: DateTimeNullableFilter<"dtr_maintenance"> | Date | string | null
    workDone?: StringFilter<"dtr_maintenance"> | string
    findings?: StringNullableFilter<"dtr_maintenance"> | string | null
    recommendations?: StringNullableFilter<"dtr_maintenance"> | string | null
    oilDielectricTest?: FloatNullableFilter<"dtr_maintenance"> | number | null
    oilAcidityTest?: FloatNullableFilter<"dtr_maintenance"> | number | null
    moistureContent?: FloatNullableFilter<"dtr_maintenance"> | number | null
    performedBy?: StringFilter<"dtr_maintenance"> | string
    verifiedBy?: StringNullableFilter<"dtr_maintenance"> | string | null
    status?: EnumMaintenanceStatusFilter<"dtr_maintenance"> | $Enums.MaintenanceStatus
    createdAt?: DateTimeFilter<"dtr_maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"dtr_maintenance"> | Date | string
    dtrs?: XOR<DtrsRelationFilter, dtrsWhereInput>
  }

  export type dtr_maintenanceOrderByWithRelationInput = {
    id?: SortOrder
    dtrId?: SortOrder
    maintenanceType?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    workDone?: SortOrder
    findings?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    oilDielectricTest?: SortOrderInput | SortOrder
    oilAcidityTest?: SortOrderInput | SortOrder
    moistureContent?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dtrs?: dtrsOrderByWithRelationInput
  }

  export type dtr_maintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: dtr_maintenanceWhereInput | dtr_maintenanceWhereInput[]
    OR?: dtr_maintenanceWhereInput[]
    NOT?: dtr_maintenanceWhereInput | dtr_maintenanceWhereInput[]
    dtrId?: IntFilter<"dtr_maintenance"> | number
    maintenanceType?: EnumMaintenanceTypeFilter<"dtr_maintenance"> | $Enums.MaintenanceType
    scheduledDate?: DateTimeFilter<"dtr_maintenance"> | Date | string
    completedDate?: DateTimeNullableFilter<"dtr_maintenance"> | Date | string | null
    workDone?: StringFilter<"dtr_maintenance"> | string
    findings?: StringNullableFilter<"dtr_maintenance"> | string | null
    recommendations?: StringNullableFilter<"dtr_maintenance"> | string | null
    oilDielectricTest?: FloatNullableFilter<"dtr_maintenance"> | number | null
    oilAcidityTest?: FloatNullableFilter<"dtr_maintenance"> | number | null
    moistureContent?: FloatNullableFilter<"dtr_maintenance"> | number | null
    performedBy?: StringFilter<"dtr_maintenance"> | string
    verifiedBy?: StringNullableFilter<"dtr_maintenance"> | string | null
    status?: EnumMaintenanceStatusFilter<"dtr_maintenance"> | $Enums.MaintenanceStatus
    createdAt?: DateTimeFilter<"dtr_maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"dtr_maintenance"> | Date | string
    dtrs?: XOR<DtrsRelationFilter, dtrsWhereInput>
  }, "id">

  export type dtr_maintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    dtrId?: SortOrder
    maintenanceType?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    workDone?: SortOrder
    findings?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    oilDielectricTest?: SortOrderInput | SortOrder
    oilAcidityTest?: SortOrderInput | SortOrder
    moistureContent?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: dtr_maintenanceCountOrderByAggregateInput
    _avg?: dtr_maintenanceAvgOrderByAggregateInput
    _max?: dtr_maintenanceMaxOrderByAggregateInput
    _min?: dtr_maintenanceMinOrderByAggregateInput
    _sum?: dtr_maintenanceSumOrderByAggregateInput
  }

  export type dtr_maintenanceScalarWhereWithAggregatesInput = {
    AND?: dtr_maintenanceScalarWhereWithAggregatesInput | dtr_maintenanceScalarWhereWithAggregatesInput[]
    OR?: dtr_maintenanceScalarWhereWithAggregatesInput[]
    NOT?: dtr_maintenanceScalarWhereWithAggregatesInput | dtr_maintenanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"dtr_maintenance"> | number
    dtrId?: IntWithAggregatesFilter<"dtr_maintenance"> | number
    maintenanceType?: EnumMaintenanceTypeWithAggregatesFilter<"dtr_maintenance"> | $Enums.MaintenanceType
    scheduledDate?: DateTimeWithAggregatesFilter<"dtr_maintenance"> | Date | string
    completedDate?: DateTimeNullableWithAggregatesFilter<"dtr_maintenance"> | Date | string | null
    workDone?: StringWithAggregatesFilter<"dtr_maintenance"> | string
    findings?: StringNullableWithAggregatesFilter<"dtr_maintenance"> | string | null
    recommendations?: StringNullableWithAggregatesFilter<"dtr_maintenance"> | string | null
    oilDielectricTest?: FloatNullableWithAggregatesFilter<"dtr_maintenance"> | number | null
    oilAcidityTest?: FloatNullableWithAggregatesFilter<"dtr_maintenance"> | number | null
    moistureContent?: FloatNullableWithAggregatesFilter<"dtr_maintenance"> | number | null
    performedBy?: StringWithAggregatesFilter<"dtr_maintenance"> | string
    verifiedBy?: StringNullableWithAggregatesFilter<"dtr_maintenance"> | string | null
    status?: EnumMaintenanceStatusWithAggregatesFilter<"dtr_maintenance"> | $Enums.MaintenanceStatus
    createdAt?: DateTimeWithAggregatesFilter<"dtr_maintenance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"dtr_maintenance"> | Date | string
  }

  export type dtr_readingsWhereInput = {
    AND?: dtr_readingsWhereInput | dtr_readingsWhereInput[]
    OR?: dtr_readingsWhereInput[]
    NOT?: dtr_readingsWhereInput | dtr_readingsWhereInput[]
    id?: IntFilter<"dtr_readings"> | number
    dtrId?: IntFilter<"dtr_readings"> | number
    readingDate?: DateTimeFilter<"dtr_readings"> | Date | string
    readingType?: EnumDTRReadingTypeFilter<"dtr_readings"> | $Enums.DTRReadingType
    loadKVA?: FloatFilter<"dtr_readings"> | number
    loadPercentage?: FloatFilter<"dtr_readings"> | number
    primaryVoltage?: JsonFilter<"dtr_readings">
    secondaryVoltage?: JsonFilter<"dtr_readings">
    primaryCurrent?: JsonFilter<"dtr_readings">
    secondaryCurrent?: JsonFilter<"dtr_readings">
    powerFactor?: FloatNullableFilter<"dtr_readings"> | number | null
    oilTemperature?: FloatNullableFilter<"dtr_readings"> | number | null
    windingTemperature?: FloatNullableFilter<"dtr_readings"> | number | null
    ambientTemperature?: FloatNullableFilter<"dtr_readings"> | number | null
    frequency?: FloatNullableFilter<"dtr_readings"> | number | null
    voltageUnbalance?: FloatNullableFilter<"dtr_readings"> | number | null
    currentUnbalance?: FloatNullableFilter<"dtr_readings"> | number | null
    createdAt?: DateTimeFilter<"dtr_readings"> | Date | string
    updatedAt?: DateTimeFilter<"dtr_readings"> | Date | string
    dtrs?: XOR<DtrsRelationFilter, dtrsWhereInput>
  }

  export type dtr_readingsOrderByWithRelationInput = {
    id?: SortOrder
    dtrId?: SortOrder
    readingDate?: SortOrder
    readingType?: SortOrder
    loadKVA?: SortOrder
    loadPercentage?: SortOrder
    primaryVoltage?: SortOrder
    secondaryVoltage?: SortOrder
    primaryCurrent?: SortOrder
    secondaryCurrent?: SortOrder
    powerFactor?: SortOrderInput | SortOrder
    oilTemperature?: SortOrderInput | SortOrder
    windingTemperature?: SortOrderInput | SortOrder
    ambientTemperature?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    voltageUnbalance?: SortOrderInput | SortOrder
    currentUnbalance?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dtrs?: dtrsOrderByWithRelationInput
  }

  export type dtr_readingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: dtr_readingsWhereInput | dtr_readingsWhereInput[]
    OR?: dtr_readingsWhereInput[]
    NOT?: dtr_readingsWhereInput | dtr_readingsWhereInput[]
    dtrId?: IntFilter<"dtr_readings"> | number
    readingDate?: DateTimeFilter<"dtr_readings"> | Date | string
    readingType?: EnumDTRReadingTypeFilter<"dtr_readings"> | $Enums.DTRReadingType
    loadKVA?: FloatFilter<"dtr_readings"> | number
    loadPercentage?: FloatFilter<"dtr_readings"> | number
    primaryVoltage?: JsonFilter<"dtr_readings">
    secondaryVoltage?: JsonFilter<"dtr_readings">
    primaryCurrent?: JsonFilter<"dtr_readings">
    secondaryCurrent?: JsonFilter<"dtr_readings">
    powerFactor?: FloatNullableFilter<"dtr_readings"> | number | null
    oilTemperature?: FloatNullableFilter<"dtr_readings"> | number | null
    windingTemperature?: FloatNullableFilter<"dtr_readings"> | number | null
    ambientTemperature?: FloatNullableFilter<"dtr_readings"> | number | null
    frequency?: FloatNullableFilter<"dtr_readings"> | number | null
    voltageUnbalance?: FloatNullableFilter<"dtr_readings"> | number | null
    currentUnbalance?: FloatNullableFilter<"dtr_readings"> | number | null
    createdAt?: DateTimeFilter<"dtr_readings"> | Date | string
    updatedAt?: DateTimeFilter<"dtr_readings"> | Date | string
    dtrs?: XOR<DtrsRelationFilter, dtrsWhereInput>
  }, "id">

  export type dtr_readingsOrderByWithAggregationInput = {
    id?: SortOrder
    dtrId?: SortOrder
    readingDate?: SortOrder
    readingType?: SortOrder
    loadKVA?: SortOrder
    loadPercentage?: SortOrder
    primaryVoltage?: SortOrder
    secondaryVoltage?: SortOrder
    primaryCurrent?: SortOrder
    secondaryCurrent?: SortOrder
    powerFactor?: SortOrderInput | SortOrder
    oilTemperature?: SortOrderInput | SortOrder
    windingTemperature?: SortOrderInput | SortOrder
    ambientTemperature?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    voltageUnbalance?: SortOrderInput | SortOrder
    currentUnbalance?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: dtr_readingsCountOrderByAggregateInput
    _avg?: dtr_readingsAvgOrderByAggregateInput
    _max?: dtr_readingsMaxOrderByAggregateInput
    _min?: dtr_readingsMinOrderByAggregateInput
    _sum?: dtr_readingsSumOrderByAggregateInput
  }

  export type dtr_readingsScalarWhereWithAggregatesInput = {
    AND?: dtr_readingsScalarWhereWithAggregatesInput | dtr_readingsScalarWhereWithAggregatesInput[]
    OR?: dtr_readingsScalarWhereWithAggregatesInput[]
    NOT?: dtr_readingsScalarWhereWithAggregatesInput | dtr_readingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"dtr_readings"> | number
    dtrId?: IntWithAggregatesFilter<"dtr_readings"> | number
    readingDate?: DateTimeWithAggregatesFilter<"dtr_readings"> | Date | string
    readingType?: EnumDTRReadingTypeWithAggregatesFilter<"dtr_readings"> | $Enums.DTRReadingType
    loadKVA?: FloatWithAggregatesFilter<"dtr_readings"> | number
    loadPercentage?: FloatWithAggregatesFilter<"dtr_readings"> | number
    primaryVoltage?: JsonWithAggregatesFilter<"dtr_readings">
    secondaryVoltage?: JsonWithAggregatesFilter<"dtr_readings">
    primaryCurrent?: JsonWithAggregatesFilter<"dtr_readings">
    secondaryCurrent?: JsonWithAggregatesFilter<"dtr_readings">
    powerFactor?: FloatNullableWithAggregatesFilter<"dtr_readings"> | number | null
    oilTemperature?: FloatNullableWithAggregatesFilter<"dtr_readings"> | number | null
    windingTemperature?: FloatNullableWithAggregatesFilter<"dtr_readings"> | number | null
    ambientTemperature?: FloatNullableWithAggregatesFilter<"dtr_readings"> | number | null
    frequency?: FloatNullableWithAggregatesFilter<"dtr_readings"> | number | null
    voltageUnbalance?: FloatNullableWithAggregatesFilter<"dtr_readings"> | number | null
    currentUnbalance?: FloatNullableWithAggregatesFilter<"dtr_readings"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"dtr_readings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"dtr_readings"> | Date | string
  }

  export type dtrsWhereInput = {
    AND?: dtrsWhereInput | dtrsWhereInput[]
    OR?: dtrsWhereInput[]
    NOT?: dtrsWhereInput | dtrsWhereInput[]
    id?: IntFilter<"dtrs"> | number
    dtrNumber?: StringFilter<"dtrs"> | string
    serialNumber?: StringFilter<"dtrs"> | string
    manufacturer?: StringFilter<"dtrs"> | string
    model?: StringFilter<"dtrs"> | string
    capacity?: FloatFilter<"dtrs"> | number
    type?: EnumDTRTypeFilter<"dtrs"> | $Enums.DTRType
    phase?: IntFilter<"dtrs"> | number
    primaryVoltage?: FloatFilter<"dtrs"> | number
    secondaryVoltage?: FloatFilter<"dtrs"> | number
    frequency?: FloatFilter<"dtrs"> | number
    impedance?: FloatNullableFilter<"dtrs"> | number | null
    coolingType?: EnumCoolingTypeFilter<"dtrs"> | $Enums.CoolingType
    oilType?: EnumOilTypeNullableFilter<"dtrs"> | $Enums.OilType | null
    oilCapacity?: FloatNullableFilter<"dtrs"> | number | null
    locationId?: IntFilter<"dtrs"> | number
    installationDate?: DateTimeFilter<"dtrs"> | Date | string
    commissionDate?: DateTimeNullableFilter<"dtrs"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableFilter<"dtrs"> | Date | string | null
    maxLoadLimit?: FloatNullableFilter<"dtrs"> | number | null
    alarmThreshold?: FloatNullableFilter<"dtrs"> | number | null
    tripThreshold?: FloatNullableFilter<"dtrs"> | number | null
    status?: EnumDTRStatusFilter<"dtrs"> | $Enums.DTRStatus
    healthIndex?: IntNullableFilter<"dtrs"> | number | null
    temperature?: FloatNullableFilter<"dtrs"> | number | null
    loadPercentage?: FloatNullableFilter<"dtrs"> | number | null
    createdAt?: DateTimeFilter<"dtrs"> | Date | string
    updatedAt?: DateTimeFilter<"dtrs"> | Date | string
    dtr_faults?: Dtr_faultsListRelationFilter
    dtr_maintenance?: Dtr_maintenanceListRelationFilter
    dtr_readings?: Dtr_readingsListRelationFilter
    locations?: XOR<LocationsRelationFilter, locationsWhereInput>
    meters?: MetersListRelationFilter
    tickets?: TicketsListRelationFilter
  }

  export type dtrsOrderByWithRelationInput = {
    id?: SortOrder
    dtrNumber?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    capacity?: SortOrder
    type?: SortOrder
    phase?: SortOrder
    primaryVoltage?: SortOrder
    secondaryVoltage?: SortOrder
    frequency?: SortOrder
    impedance?: SortOrderInput | SortOrder
    coolingType?: SortOrder
    oilType?: SortOrderInput | SortOrder
    oilCapacity?: SortOrderInput | SortOrder
    locationId?: SortOrder
    installationDate?: SortOrder
    commissionDate?: SortOrderInput | SortOrder
    lastMaintenanceDate?: SortOrderInput | SortOrder
    maxLoadLimit?: SortOrderInput | SortOrder
    alarmThreshold?: SortOrderInput | SortOrder
    tripThreshold?: SortOrderInput | SortOrder
    status?: SortOrder
    healthIndex?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    loadPercentage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dtr_faults?: dtr_faultsOrderByRelationAggregateInput
    dtr_maintenance?: dtr_maintenanceOrderByRelationAggregateInput
    dtr_readings?: dtr_readingsOrderByRelationAggregateInput
    locations?: locationsOrderByWithRelationInput
    meters?: metersOrderByRelationAggregateInput
    tickets?: ticketsOrderByRelationAggregateInput
  }

  export type dtrsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    dtrNumber?: string
    serialNumber?: string
    AND?: dtrsWhereInput | dtrsWhereInput[]
    OR?: dtrsWhereInput[]
    NOT?: dtrsWhereInput | dtrsWhereInput[]
    manufacturer?: StringFilter<"dtrs"> | string
    model?: StringFilter<"dtrs"> | string
    capacity?: FloatFilter<"dtrs"> | number
    type?: EnumDTRTypeFilter<"dtrs"> | $Enums.DTRType
    phase?: IntFilter<"dtrs"> | number
    primaryVoltage?: FloatFilter<"dtrs"> | number
    secondaryVoltage?: FloatFilter<"dtrs"> | number
    frequency?: FloatFilter<"dtrs"> | number
    impedance?: FloatNullableFilter<"dtrs"> | number | null
    coolingType?: EnumCoolingTypeFilter<"dtrs"> | $Enums.CoolingType
    oilType?: EnumOilTypeNullableFilter<"dtrs"> | $Enums.OilType | null
    oilCapacity?: FloatNullableFilter<"dtrs"> | number | null
    locationId?: IntFilter<"dtrs"> | number
    installationDate?: DateTimeFilter<"dtrs"> | Date | string
    commissionDate?: DateTimeNullableFilter<"dtrs"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableFilter<"dtrs"> | Date | string | null
    maxLoadLimit?: FloatNullableFilter<"dtrs"> | number | null
    alarmThreshold?: FloatNullableFilter<"dtrs"> | number | null
    tripThreshold?: FloatNullableFilter<"dtrs"> | number | null
    status?: EnumDTRStatusFilter<"dtrs"> | $Enums.DTRStatus
    healthIndex?: IntNullableFilter<"dtrs"> | number | null
    temperature?: FloatNullableFilter<"dtrs"> | number | null
    loadPercentage?: FloatNullableFilter<"dtrs"> | number | null
    createdAt?: DateTimeFilter<"dtrs"> | Date | string
    updatedAt?: DateTimeFilter<"dtrs"> | Date | string
    dtr_faults?: Dtr_faultsListRelationFilter
    dtr_maintenance?: Dtr_maintenanceListRelationFilter
    dtr_readings?: Dtr_readingsListRelationFilter
    locations?: XOR<LocationsRelationFilter, locationsWhereInput>
    meters?: MetersListRelationFilter
    tickets?: TicketsListRelationFilter
  }, "id" | "dtrNumber" | "serialNumber">

  export type dtrsOrderByWithAggregationInput = {
    id?: SortOrder
    dtrNumber?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    capacity?: SortOrder
    type?: SortOrder
    phase?: SortOrder
    primaryVoltage?: SortOrder
    secondaryVoltage?: SortOrder
    frequency?: SortOrder
    impedance?: SortOrderInput | SortOrder
    coolingType?: SortOrder
    oilType?: SortOrderInput | SortOrder
    oilCapacity?: SortOrderInput | SortOrder
    locationId?: SortOrder
    installationDate?: SortOrder
    commissionDate?: SortOrderInput | SortOrder
    lastMaintenanceDate?: SortOrderInput | SortOrder
    maxLoadLimit?: SortOrderInput | SortOrder
    alarmThreshold?: SortOrderInput | SortOrder
    tripThreshold?: SortOrderInput | SortOrder
    status?: SortOrder
    healthIndex?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    loadPercentage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: dtrsCountOrderByAggregateInput
    _avg?: dtrsAvgOrderByAggregateInput
    _max?: dtrsMaxOrderByAggregateInput
    _min?: dtrsMinOrderByAggregateInput
    _sum?: dtrsSumOrderByAggregateInput
  }

  export type dtrsScalarWhereWithAggregatesInput = {
    AND?: dtrsScalarWhereWithAggregatesInput | dtrsScalarWhereWithAggregatesInput[]
    OR?: dtrsScalarWhereWithAggregatesInput[]
    NOT?: dtrsScalarWhereWithAggregatesInput | dtrsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"dtrs"> | number
    dtrNumber?: StringWithAggregatesFilter<"dtrs"> | string
    serialNumber?: StringWithAggregatesFilter<"dtrs"> | string
    manufacturer?: StringWithAggregatesFilter<"dtrs"> | string
    model?: StringWithAggregatesFilter<"dtrs"> | string
    capacity?: FloatWithAggregatesFilter<"dtrs"> | number
    type?: EnumDTRTypeWithAggregatesFilter<"dtrs"> | $Enums.DTRType
    phase?: IntWithAggregatesFilter<"dtrs"> | number
    primaryVoltage?: FloatWithAggregatesFilter<"dtrs"> | number
    secondaryVoltage?: FloatWithAggregatesFilter<"dtrs"> | number
    frequency?: FloatWithAggregatesFilter<"dtrs"> | number
    impedance?: FloatNullableWithAggregatesFilter<"dtrs"> | number | null
    coolingType?: EnumCoolingTypeWithAggregatesFilter<"dtrs"> | $Enums.CoolingType
    oilType?: EnumOilTypeNullableWithAggregatesFilter<"dtrs"> | $Enums.OilType | null
    oilCapacity?: FloatNullableWithAggregatesFilter<"dtrs"> | number | null
    locationId?: IntWithAggregatesFilter<"dtrs"> | number
    installationDate?: DateTimeWithAggregatesFilter<"dtrs"> | Date | string
    commissionDate?: DateTimeNullableWithAggregatesFilter<"dtrs"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableWithAggregatesFilter<"dtrs"> | Date | string | null
    maxLoadLimit?: FloatNullableWithAggregatesFilter<"dtrs"> | number | null
    alarmThreshold?: FloatNullableWithAggregatesFilter<"dtrs"> | number | null
    tripThreshold?: FloatNullableWithAggregatesFilter<"dtrs"> | number | null
    status?: EnumDTRStatusWithAggregatesFilter<"dtrs"> | $Enums.DTRStatus
    healthIndex?: IntNullableWithAggregatesFilter<"dtrs"> | number | null
    temperature?: FloatNullableWithAggregatesFilter<"dtrs"> | number | null
    loadPercentage?: FloatNullableWithAggregatesFilter<"dtrs"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"dtrs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"dtrs"> | Date | string
  }

  export type location_typesWhereInput = {
    AND?: location_typesWhereInput | location_typesWhereInput[]
    OR?: location_typesWhereInput[]
    NOT?: location_typesWhereInput | location_typesWhereInput[]
    id?: IntFilter<"location_types"> | number
    name?: StringFilter<"location_types"> | string
    level?: IntFilter<"location_types"> | number
    description?: StringNullableFilter<"location_types"> | string | null
    isActive?: BoolFilter<"location_types"> | boolean
    createdAt?: DateTimeFilter<"location_types"> | Date | string
    updatedAt?: DateTimeFilter<"location_types"> | Date | string
    locations?: LocationsListRelationFilter
  }

  export type location_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locations?: locationsOrderByRelationAggregateInput
  }

  export type location_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: location_typesWhereInput | location_typesWhereInput[]
    OR?: location_typesWhereInput[]
    NOT?: location_typesWhereInput | location_typesWhereInput[]
    level?: IntFilter<"location_types"> | number
    description?: StringNullableFilter<"location_types"> | string | null
    isActive?: BoolFilter<"location_types"> | boolean
    createdAt?: DateTimeFilter<"location_types"> | Date | string
    updatedAt?: DateTimeFilter<"location_types"> | Date | string
    locations?: LocationsListRelationFilter
  }, "id" | "name">

  export type location_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: location_typesCountOrderByAggregateInput
    _avg?: location_typesAvgOrderByAggregateInput
    _max?: location_typesMaxOrderByAggregateInput
    _min?: location_typesMinOrderByAggregateInput
    _sum?: location_typesSumOrderByAggregateInput
  }

  export type location_typesScalarWhereWithAggregatesInput = {
    AND?: location_typesScalarWhereWithAggregatesInput | location_typesScalarWhereWithAggregatesInput[]
    OR?: location_typesScalarWhereWithAggregatesInput[]
    NOT?: location_typesScalarWhereWithAggregatesInput | location_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"location_types"> | number
    name?: StringWithAggregatesFilter<"location_types"> | string
    level?: IntWithAggregatesFilter<"location_types"> | number
    description?: StringNullableWithAggregatesFilter<"location_types"> | string | null
    isActive?: BoolWithAggregatesFilter<"location_types"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"location_types"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"location_types"> | Date | string
  }

  export type locationsWhereInput = {
    AND?: locationsWhereInput | locationsWhereInput[]
    OR?: locationsWhereInput[]
    NOT?: locationsWhereInput | locationsWhereInput[]
    id?: IntFilter<"locations"> | number
    name?: StringFilter<"locations"> | string
    code?: StringFilter<"locations"> | string
    locationTypeId?: IntFilter<"locations"> | number
    parentId?: IntNullableFilter<"locations"> | number | null
    latitude?: FloatNullableFilter<"locations"> | number | null
    longitude?: FloatNullableFilter<"locations"> | number | null
    address?: StringNullableFilter<"locations"> | string | null
    pincode?: StringNullableFilter<"locations"> | string | null
    createdAt?: DateTimeFilter<"locations"> | Date | string
    updatedAt?: DateTimeFilter<"locations"> | Date | string
    consumers?: XOR<ConsumersNullableRelationFilter, consumersWhereInput> | null
    dtrs?: DtrsListRelationFilter
    location_types?: XOR<Location_typesRelationFilter, location_typesWhereInput>
    locations?: XOR<LocationsNullableRelationFilter, locationsWhereInput> | null
    other_locations?: LocationsListRelationFilter
    meters?: MetersListRelationFilter
    users?: UsersListRelationFilter
  }

  export type locationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    locationTypeId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consumers?: consumersOrderByWithRelationInput
    dtrs?: dtrsOrderByRelationAggregateInput
    location_types?: location_typesOrderByWithRelationInput
    locations?: locationsOrderByWithRelationInput
    other_locations?: locationsOrderByRelationAggregateInput
    meters?: metersOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
  }

  export type locationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: locationsWhereInput | locationsWhereInput[]
    OR?: locationsWhereInput[]
    NOT?: locationsWhereInput | locationsWhereInput[]
    name?: StringFilter<"locations"> | string
    locationTypeId?: IntFilter<"locations"> | number
    parentId?: IntNullableFilter<"locations"> | number | null
    latitude?: FloatNullableFilter<"locations"> | number | null
    longitude?: FloatNullableFilter<"locations"> | number | null
    address?: StringNullableFilter<"locations"> | string | null
    pincode?: StringNullableFilter<"locations"> | string | null
    createdAt?: DateTimeFilter<"locations"> | Date | string
    updatedAt?: DateTimeFilter<"locations"> | Date | string
    consumers?: XOR<ConsumersNullableRelationFilter, consumersWhereInput> | null
    dtrs?: DtrsListRelationFilter
    location_types?: XOR<Location_typesRelationFilter, location_typesWhereInput>
    locations?: XOR<LocationsNullableRelationFilter, locationsWhereInput> | null
    other_locations?: LocationsListRelationFilter
    meters?: MetersListRelationFilter
    users?: UsersListRelationFilter
  }, "id" | "code">

  export type locationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    locationTypeId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: locationsCountOrderByAggregateInput
    _avg?: locationsAvgOrderByAggregateInput
    _max?: locationsMaxOrderByAggregateInput
    _min?: locationsMinOrderByAggregateInput
    _sum?: locationsSumOrderByAggregateInput
  }

  export type locationsScalarWhereWithAggregatesInput = {
    AND?: locationsScalarWhereWithAggregatesInput | locationsScalarWhereWithAggregatesInput[]
    OR?: locationsScalarWhereWithAggregatesInput[]
    NOT?: locationsScalarWhereWithAggregatesInput | locationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"locations"> | number
    name?: StringWithAggregatesFilter<"locations"> | string
    code?: StringWithAggregatesFilter<"locations"> | string
    locationTypeId?: IntWithAggregatesFilter<"locations"> | number
    parentId?: IntNullableWithAggregatesFilter<"locations"> | number | null
    latitude?: FloatNullableWithAggregatesFilter<"locations"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"locations"> | number | null
    address?: StringNullableWithAggregatesFilter<"locations"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"locations"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"locations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"locations"> | Date | string
  }

  export type login_historyWhereInput = {
    AND?: login_historyWhereInput | login_historyWhereInput[]
    OR?: login_historyWhereInput[]
    NOT?: login_historyWhereInput | login_historyWhereInput[]
    id?: IntFilter<"login_history"> | number
    userId?: IntFilter<"login_history"> | number
    status?: StringFilter<"login_history"> | string
    ipAddress?: StringNullableFilter<"login_history"> | string | null
    deviceInfo?: JsonNullableFilter<"login_history">
    location?: StringNullableFilter<"login_history"> | string | null
    failureReason?: StringNullableFilter<"login_history"> | string | null
    createdAt?: DateTimeFilter<"login_history"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type login_historyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type login_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: login_historyWhereInput | login_historyWhereInput[]
    OR?: login_historyWhereInput[]
    NOT?: login_historyWhereInput | login_historyWhereInput[]
    userId?: IntFilter<"login_history"> | number
    status?: StringFilter<"login_history"> | string
    ipAddress?: StringNullableFilter<"login_history"> | string | null
    deviceInfo?: JsonNullableFilter<"login_history">
    location?: StringNullableFilter<"login_history"> | string | null
    failureReason?: StringNullableFilter<"login_history"> | string | null
    createdAt?: DateTimeFilter<"login_history"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type login_historyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: login_historyCountOrderByAggregateInput
    _avg?: login_historyAvgOrderByAggregateInput
    _max?: login_historyMaxOrderByAggregateInput
    _min?: login_historyMinOrderByAggregateInput
    _sum?: login_historySumOrderByAggregateInput
  }

  export type login_historyScalarWhereWithAggregatesInput = {
    AND?: login_historyScalarWhereWithAggregatesInput | login_historyScalarWhereWithAggregatesInput[]
    OR?: login_historyScalarWhereWithAggregatesInput[]
    NOT?: login_historyScalarWhereWithAggregatesInput | login_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"login_history"> | number
    userId?: IntWithAggregatesFilter<"login_history"> | number
    status?: StringWithAggregatesFilter<"login_history"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"login_history"> | string | null
    deviceInfo?: JsonNullableWithAggregatesFilter<"login_history">
    location?: StringNullableWithAggregatesFilter<"login_history"> | string | null
    failureReason?: StringNullableWithAggregatesFilter<"login_history"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"login_history"> | Date | string
  }

  export type meter_configurationsWhereInput = {
    AND?: meter_configurationsWhereInput | meter_configurationsWhereInput[]
    OR?: meter_configurationsWhereInput[]
    NOT?: meter_configurationsWhereInput | meter_configurationsWhereInput[]
    id?: IntFilter<"meter_configurations"> | number
    meterId?: IntFilter<"meter_configurations"> | number
    ctRatio?: StringFilter<"meter_configurations"> | string
    ctRatioPrimary?: FloatFilter<"meter_configurations"> | number
    ctRatioSecondary?: FloatFilter<"meter_configurations"> | number
    adoptedCTRatio?: StringNullableFilter<"meter_configurations"> | string | null
    ctAccuracyClass?: StringNullableFilter<"meter_configurations"> | string | null
    ctBurden?: FloatNullableFilter<"meter_configurations"> | number | null
    ptRatio?: StringFilter<"meter_configurations"> | string
    ptRatioPrimary?: FloatFilter<"meter_configurations"> | number
    ptRatioSecondary?: FloatFilter<"meter_configurations"> | number
    adoptedPTRatio?: StringNullableFilter<"meter_configurations"> | string | null
    ptAccuracyClass?: StringNullableFilter<"meter_configurations"> | string | null
    ptBurden?: FloatNullableFilter<"meter_configurations"> | number | null
    mf?: FloatFilter<"meter_configurations"> | number
    vmf?: FloatFilter<"meter_configurations"> | number
    cmf?: FloatFilter<"meter_configurations"> | number
    createdAt?: DateTimeFilter<"meter_configurations"> | Date | string
    updatedAt?: DateTimeFilter<"meter_configurations"> | Date | string
    meters?: XOR<MetersRelationFilter, metersWhereInput>
  }

  export type meter_configurationsOrderByWithRelationInput = {
    id?: SortOrder
    meterId?: SortOrder
    ctRatio?: SortOrder
    ctRatioPrimary?: SortOrder
    ctRatioSecondary?: SortOrder
    adoptedCTRatio?: SortOrderInput | SortOrder
    ctAccuracyClass?: SortOrderInput | SortOrder
    ctBurden?: SortOrderInput | SortOrder
    ptRatio?: SortOrder
    ptRatioPrimary?: SortOrder
    ptRatioSecondary?: SortOrder
    adoptedPTRatio?: SortOrderInput | SortOrder
    ptAccuracyClass?: SortOrderInput | SortOrder
    ptBurden?: SortOrderInput | SortOrder
    mf?: SortOrder
    vmf?: SortOrder
    cmf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meters?: metersOrderByWithRelationInput
  }

  export type meter_configurationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    meterId?: number
    AND?: meter_configurationsWhereInput | meter_configurationsWhereInput[]
    OR?: meter_configurationsWhereInput[]
    NOT?: meter_configurationsWhereInput | meter_configurationsWhereInput[]
    ctRatio?: StringFilter<"meter_configurations"> | string
    ctRatioPrimary?: FloatFilter<"meter_configurations"> | number
    ctRatioSecondary?: FloatFilter<"meter_configurations"> | number
    adoptedCTRatio?: StringNullableFilter<"meter_configurations"> | string | null
    ctAccuracyClass?: StringNullableFilter<"meter_configurations"> | string | null
    ctBurden?: FloatNullableFilter<"meter_configurations"> | number | null
    ptRatio?: StringFilter<"meter_configurations"> | string
    ptRatioPrimary?: FloatFilter<"meter_configurations"> | number
    ptRatioSecondary?: FloatFilter<"meter_configurations"> | number
    adoptedPTRatio?: StringNullableFilter<"meter_configurations"> | string | null
    ptAccuracyClass?: StringNullableFilter<"meter_configurations"> | string | null
    ptBurden?: FloatNullableFilter<"meter_configurations"> | number | null
    mf?: FloatFilter<"meter_configurations"> | number
    vmf?: FloatFilter<"meter_configurations"> | number
    cmf?: FloatFilter<"meter_configurations"> | number
    createdAt?: DateTimeFilter<"meter_configurations"> | Date | string
    updatedAt?: DateTimeFilter<"meter_configurations"> | Date | string
    meters?: XOR<MetersRelationFilter, metersWhereInput>
  }, "id" | "meterId">

  export type meter_configurationsOrderByWithAggregationInput = {
    id?: SortOrder
    meterId?: SortOrder
    ctRatio?: SortOrder
    ctRatioPrimary?: SortOrder
    ctRatioSecondary?: SortOrder
    adoptedCTRatio?: SortOrderInput | SortOrder
    ctAccuracyClass?: SortOrderInput | SortOrder
    ctBurden?: SortOrderInput | SortOrder
    ptRatio?: SortOrder
    ptRatioPrimary?: SortOrder
    ptRatioSecondary?: SortOrder
    adoptedPTRatio?: SortOrderInput | SortOrder
    ptAccuracyClass?: SortOrderInput | SortOrder
    ptBurden?: SortOrderInput | SortOrder
    mf?: SortOrder
    vmf?: SortOrder
    cmf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: meter_configurationsCountOrderByAggregateInput
    _avg?: meter_configurationsAvgOrderByAggregateInput
    _max?: meter_configurationsMaxOrderByAggregateInput
    _min?: meter_configurationsMinOrderByAggregateInput
    _sum?: meter_configurationsSumOrderByAggregateInput
  }

  export type meter_configurationsScalarWhereWithAggregatesInput = {
    AND?: meter_configurationsScalarWhereWithAggregatesInput | meter_configurationsScalarWhereWithAggregatesInput[]
    OR?: meter_configurationsScalarWhereWithAggregatesInput[]
    NOT?: meter_configurationsScalarWhereWithAggregatesInput | meter_configurationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"meter_configurations"> | number
    meterId?: IntWithAggregatesFilter<"meter_configurations"> | number
    ctRatio?: StringWithAggregatesFilter<"meter_configurations"> | string
    ctRatioPrimary?: FloatWithAggregatesFilter<"meter_configurations"> | number
    ctRatioSecondary?: FloatWithAggregatesFilter<"meter_configurations"> | number
    adoptedCTRatio?: StringNullableWithAggregatesFilter<"meter_configurations"> | string | null
    ctAccuracyClass?: StringNullableWithAggregatesFilter<"meter_configurations"> | string | null
    ctBurden?: FloatNullableWithAggregatesFilter<"meter_configurations"> | number | null
    ptRatio?: StringWithAggregatesFilter<"meter_configurations"> | string
    ptRatioPrimary?: FloatWithAggregatesFilter<"meter_configurations"> | number
    ptRatioSecondary?: FloatWithAggregatesFilter<"meter_configurations"> | number
    adoptedPTRatio?: StringNullableWithAggregatesFilter<"meter_configurations"> | string | null
    ptAccuracyClass?: StringNullableWithAggregatesFilter<"meter_configurations"> | string | null
    ptBurden?: FloatNullableWithAggregatesFilter<"meter_configurations"> | number | null
    mf?: FloatWithAggregatesFilter<"meter_configurations"> | number
    vmf?: FloatWithAggregatesFilter<"meter_configurations"> | number
    cmf?: FloatWithAggregatesFilter<"meter_configurations"> | number
    createdAt?: DateTimeWithAggregatesFilter<"meter_configurations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"meter_configurations"> | Date | string
  }

  export type meter_readingsWhereInput = {
    AND?: meter_readingsWhereInput | meter_readingsWhereInput[]
    OR?: meter_readingsWhereInput[]
    NOT?: meter_readingsWhereInput | meter_readingsWhereInput[]
    id?: IntFilter<"meter_readings"> | number
    meterId?: IntFilter<"meter_readings"> | number
    readingDate?: DateTimeFilter<"meter_readings"> | Date | string
    readingType?: EnumReadingTypeFilter<"meter_readings"> | $Enums.ReadingType
    readingSource?: EnumReadingSourceFilter<"meter_readings"> | $Enums.ReadingSource
    currentReading?: FloatFilter<"meter_readings"> | number
    previousReading?: FloatFilter<"meter_readings"> | number
    consumption?: FloatFilter<"meter_readings"> | number
    kWh?: FloatFilter<"meter_readings"> | number
    kVAh?: FloatNullableFilter<"meter_readings"> | number | null
    kVARh?: FloatNullableFilter<"meter_readings"> | number | null
    powerFactor?: FloatNullableFilter<"meter_readings"> | number | null
    averagePF?: FloatNullableFilter<"meter_readings"> | number | null
    minimumPF?: FloatNullableFilter<"meter_readings"> | number | null
    voltageR?: FloatNullableFilter<"meter_readings"> | number | null
    voltageY?: FloatNullableFilter<"meter_readings"> | number | null
    voltageB?: FloatNullableFilter<"meter_readings"> | number | null
    averageVoltage?: FloatNullableFilter<"meter_readings"> | number | null
    currentR?: FloatNullableFilter<"meter_readings"> | number | null
    currentY?: FloatNullableFilter<"meter_readings"> | number | null
    currentB?: FloatNullableFilter<"meter_readings"> | number | null
    averageCurrent?: FloatNullableFilter<"meter_readings"> | number | null
    isValid?: BoolFilter<"meter_readings"> | boolean
    validatedBy?: StringNullableFilter<"meter_readings"> | string | null
    validatedAt?: DateTimeNullableFilter<"meter_readings"> | Date | string | null
    billId?: IntNullableFilter<"meter_readings"> | number | null
    createdAt?: DateTimeFilter<"meter_readings"> | Date | string
    updatedAt?: DateTimeFilter<"meter_readings"> | Date | string
    kVA?: FloatNullableFilter<"meter_readings"> | number | null
    kW?: FloatNullableFilter<"meter_readings"> | number | null
    bphPowerFactor?: FloatNullableFilter<"meter_readings"> | number | null
    frequency?: FloatNullableFilter<"meter_readings"> | number | null
    rphPowerFactor?: FloatNullableFilter<"meter_readings"> | number | null
    yphPowerFactor?: FloatNullableFilter<"meter_readings"> | number | null
    bills?: XOR<BillsNullableRelationFilter, billsWhereInput> | null
    meters?: XOR<MetersRelationFilter, metersWhereInput>
    prepaid_transactions?: Prepaid_transactionsListRelationFilter
  }

  export type meter_readingsOrderByWithRelationInput = {
    id?: SortOrder
    meterId?: SortOrder
    readingDate?: SortOrder
    readingType?: SortOrder
    readingSource?: SortOrder
    currentReading?: SortOrder
    previousReading?: SortOrder
    consumption?: SortOrder
    kWh?: SortOrder
    kVAh?: SortOrderInput | SortOrder
    kVARh?: SortOrderInput | SortOrder
    powerFactor?: SortOrderInput | SortOrder
    averagePF?: SortOrderInput | SortOrder
    minimumPF?: SortOrderInput | SortOrder
    voltageR?: SortOrderInput | SortOrder
    voltageY?: SortOrderInput | SortOrder
    voltageB?: SortOrderInput | SortOrder
    averageVoltage?: SortOrderInput | SortOrder
    currentR?: SortOrderInput | SortOrder
    currentY?: SortOrderInput | SortOrder
    currentB?: SortOrderInput | SortOrder
    averageCurrent?: SortOrderInput | SortOrder
    isValid?: SortOrder
    validatedBy?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    billId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kVA?: SortOrderInput | SortOrder
    kW?: SortOrderInput | SortOrder
    bphPowerFactor?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    rphPowerFactor?: SortOrderInput | SortOrder
    yphPowerFactor?: SortOrderInput | SortOrder
    bills?: billsOrderByWithRelationInput
    meters?: metersOrderByWithRelationInput
    prepaid_transactions?: prepaid_transactionsOrderByRelationAggregateInput
  }

  export type meter_readingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: meter_readingsWhereInput | meter_readingsWhereInput[]
    OR?: meter_readingsWhereInput[]
    NOT?: meter_readingsWhereInput | meter_readingsWhereInput[]
    meterId?: IntFilter<"meter_readings"> | number
    readingDate?: DateTimeFilter<"meter_readings"> | Date | string
    readingType?: EnumReadingTypeFilter<"meter_readings"> | $Enums.ReadingType
    readingSource?: EnumReadingSourceFilter<"meter_readings"> | $Enums.ReadingSource
    currentReading?: FloatFilter<"meter_readings"> | number
    previousReading?: FloatFilter<"meter_readings"> | number
    consumption?: FloatFilter<"meter_readings"> | number
    kWh?: FloatFilter<"meter_readings"> | number
    kVAh?: FloatNullableFilter<"meter_readings"> | number | null
    kVARh?: FloatNullableFilter<"meter_readings"> | number | null
    powerFactor?: FloatNullableFilter<"meter_readings"> | number | null
    averagePF?: FloatNullableFilter<"meter_readings"> | number | null
    minimumPF?: FloatNullableFilter<"meter_readings"> | number | null
    voltageR?: FloatNullableFilter<"meter_readings"> | number | null
    voltageY?: FloatNullableFilter<"meter_readings"> | number | null
    voltageB?: FloatNullableFilter<"meter_readings"> | number | null
    averageVoltage?: FloatNullableFilter<"meter_readings"> | number | null
    currentR?: FloatNullableFilter<"meter_readings"> | number | null
    currentY?: FloatNullableFilter<"meter_readings"> | number | null
    currentB?: FloatNullableFilter<"meter_readings"> | number | null
    averageCurrent?: FloatNullableFilter<"meter_readings"> | number | null
    isValid?: BoolFilter<"meter_readings"> | boolean
    validatedBy?: StringNullableFilter<"meter_readings"> | string | null
    validatedAt?: DateTimeNullableFilter<"meter_readings"> | Date | string | null
    billId?: IntNullableFilter<"meter_readings"> | number | null
    createdAt?: DateTimeFilter<"meter_readings"> | Date | string
    updatedAt?: DateTimeFilter<"meter_readings"> | Date | string
    kVA?: FloatNullableFilter<"meter_readings"> | number | null
    kW?: FloatNullableFilter<"meter_readings"> | number | null
    bphPowerFactor?: FloatNullableFilter<"meter_readings"> | number | null
    frequency?: FloatNullableFilter<"meter_readings"> | number | null
    rphPowerFactor?: FloatNullableFilter<"meter_readings"> | number | null
    yphPowerFactor?: FloatNullableFilter<"meter_readings"> | number | null
    bills?: XOR<BillsNullableRelationFilter, billsWhereInput> | null
    meters?: XOR<MetersRelationFilter, metersWhereInput>
    prepaid_transactions?: Prepaid_transactionsListRelationFilter
  }, "id">

  export type meter_readingsOrderByWithAggregationInput = {
    id?: SortOrder
    meterId?: SortOrder
    readingDate?: SortOrder
    readingType?: SortOrder
    readingSource?: SortOrder
    currentReading?: SortOrder
    previousReading?: SortOrder
    consumption?: SortOrder
    kWh?: SortOrder
    kVAh?: SortOrderInput | SortOrder
    kVARh?: SortOrderInput | SortOrder
    powerFactor?: SortOrderInput | SortOrder
    averagePF?: SortOrderInput | SortOrder
    minimumPF?: SortOrderInput | SortOrder
    voltageR?: SortOrderInput | SortOrder
    voltageY?: SortOrderInput | SortOrder
    voltageB?: SortOrderInput | SortOrder
    averageVoltage?: SortOrderInput | SortOrder
    currentR?: SortOrderInput | SortOrder
    currentY?: SortOrderInput | SortOrder
    currentB?: SortOrderInput | SortOrder
    averageCurrent?: SortOrderInput | SortOrder
    isValid?: SortOrder
    validatedBy?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    billId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kVA?: SortOrderInput | SortOrder
    kW?: SortOrderInput | SortOrder
    bphPowerFactor?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    rphPowerFactor?: SortOrderInput | SortOrder
    yphPowerFactor?: SortOrderInput | SortOrder
    _count?: meter_readingsCountOrderByAggregateInput
    _avg?: meter_readingsAvgOrderByAggregateInput
    _max?: meter_readingsMaxOrderByAggregateInput
    _min?: meter_readingsMinOrderByAggregateInput
    _sum?: meter_readingsSumOrderByAggregateInput
  }

  export type meter_readingsScalarWhereWithAggregatesInput = {
    AND?: meter_readingsScalarWhereWithAggregatesInput | meter_readingsScalarWhereWithAggregatesInput[]
    OR?: meter_readingsScalarWhereWithAggregatesInput[]
    NOT?: meter_readingsScalarWhereWithAggregatesInput | meter_readingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"meter_readings"> | number
    meterId?: IntWithAggregatesFilter<"meter_readings"> | number
    readingDate?: DateTimeWithAggregatesFilter<"meter_readings"> | Date | string
    readingType?: EnumReadingTypeWithAggregatesFilter<"meter_readings"> | $Enums.ReadingType
    readingSource?: EnumReadingSourceWithAggregatesFilter<"meter_readings"> | $Enums.ReadingSource
    currentReading?: FloatWithAggregatesFilter<"meter_readings"> | number
    previousReading?: FloatWithAggregatesFilter<"meter_readings"> | number
    consumption?: FloatWithAggregatesFilter<"meter_readings"> | number
    kWh?: FloatWithAggregatesFilter<"meter_readings"> | number
    kVAh?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    kVARh?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    powerFactor?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    averagePF?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    minimumPF?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    voltageR?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    voltageY?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    voltageB?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    averageVoltage?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    currentR?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    currentY?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    currentB?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    averageCurrent?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    isValid?: BoolWithAggregatesFilter<"meter_readings"> | boolean
    validatedBy?: StringNullableWithAggregatesFilter<"meter_readings"> | string | null
    validatedAt?: DateTimeNullableWithAggregatesFilter<"meter_readings"> | Date | string | null
    billId?: IntNullableWithAggregatesFilter<"meter_readings"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"meter_readings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"meter_readings"> | Date | string
    kVA?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    kW?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    bphPowerFactor?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    frequency?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    rphPowerFactor?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
    yphPowerFactor?: FloatNullableWithAggregatesFilter<"meter_readings"> | number | null
  }

  export type metersWhereInput = {
    AND?: metersWhereInput | metersWhereInput[]
    OR?: metersWhereInput[]
    NOT?: metersWhereInput | metersWhereInput[]
    id?: IntFilter<"meters"> | number
    meterNumber?: StringFilter<"meters"> | string
    serialNumber?: StringFilter<"meters"> | string
    manufacturer?: StringFilter<"meters"> | string
    model?: StringFilter<"meters"> | string
    type?: EnumMeterTypeFilter<"meters"> | $Enums.MeterType
    phase?: IntFilter<"meters"> | number
    status?: EnumMeterStatusFilter<"meters"> | $Enums.MeterStatus
    isInUse?: BoolFilter<"meters"> | boolean
    installationDate?: DateTimeFilter<"meters"> | Date | string
    lastMaintenanceDate?: DateTimeNullableFilter<"meters"> | Date | string | null
    decommissionDate?: DateTimeNullableFilter<"meters"> | Date | string | null
    locationId?: IntFilter<"meters"> | number
    dtrId?: IntNullableFilter<"meters"> | number | null
    createdAt?: DateTimeFilter<"meters"> | Date | string
    updatedAt?: DateTimeFilter<"meters"> | Date | string
    bills?: BillsListRelationFilter
    current_transformers?: Current_transformersListRelationFilter
    meter_configurations?: XOR<Meter_configurationsNullableRelationFilter, meter_configurationsWhereInput> | null
    meter_readings?: Meter_readingsListRelationFilter
    dtrs?: XOR<DtrsNullableRelationFilter, dtrsWhereInput> | null
    locations?: XOR<LocationsRelationFilter, locationsWhereInput>
    potential_transformers?: Potential_transformersListRelationFilter
    tamper_events?: Tamper_eventsListRelationFilter
  }

  export type metersOrderByWithRelationInput = {
    id?: SortOrder
    meterNumber?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    type?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    isInUse?: SortOrder
    installationDate?: SortOrder
    lastMaintenanceDate?: SortOrderInput | SortOrder
    decommissionDate?: SortOrderInput | SortOrder
    locationId?: SortOrder
    dtrId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bills?: billsOrderByRelationAggregateInput
    current_transformers?: current_transformersOrderByRelationAggregateInput
    meter_configurations?: meter_configurationsOrderByWithRelationInput
    meter_readings?: meter_readingsOrderByRelationAggregateInput
    dtrs?: dtrsOrderByWithRelationInput
    locations?: locationsOrderByWithRelationInput
    potential_transformers?: potential_transformersOrderByRelationAggregateInput
    tamper_events?: tamper_eventsOrderByRelationAggregateInput
  }

  export type metersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    meterNumber?: string
    serialNumber?: string
    AND?: metersWhereInput | metersWhereInput[]
    OR?: metersWhereInput[]
    NOT?: metersWhereInput | metersWhereInput[]
    manufacturer?: StringFilter<"meters"> | string
    model?: StringFilter<"meters"> | string
    type?: EnumMeterTypeFilter<"meters"> | $Enums.MeterType
    phase?: IntFilter<"meters"> | number
    status?: EnumMeterStatusFilter<"meters"> | $Enums.MeterStatus
    isInUse?: BoolFilter<"meters"> | boolean
    installationDate?: DateTimeFilter<"meters"> | Date | string
    lastMaintenanceDate?: DateTimeNullableFilter<"meters"> | Date | string | null
    decommissionDate?: DateTimeNullableFilter<"meters"> | Date | string | null
    locationId?: IntFilter<"meters"> | number
    dtrId?: IntNullableFilter<"meters"> | number | null
    createdAt?: DateTimeFilter<"meters"> | Date | string
    updatedAt?: DateTimeFilter<"meters"> | Date | string
    bills?: BillsListRelationFilter
    current_transformers?: Current_transformersListRelationFilter
    meter_configurations?: XOR<Meter_configurationsNullableRelationFilter, meter_configurationsWhereInput> | null
    meter_readings?: Meter_readingsListRelationFilter
    dtrs?: XOR<DtrsNullableRelationFilter, dtrsWhereInput> | null
    locations?: XOR<LocationsRelationFilter, locationsWhereInput>
    potential_transformers?: Potential_transformersListRelationFilter
    tamper_events?: Tamper_eventsListRelationFilter
  }, "id" | "meterNumber" | "serialNumber">

  export type metersOrderByWithAggregationInput = {
    id?: SortOrder
    meterNumber?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    type?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    isInUse?: SortOrder
    installationDate?: SortOrder
    lastMaintenanceDate?: SortOrderInput | SortOrder
    decommissionDate?: SortOrderInput | SortOrder
    locationId?: SortOrder
    dtrId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: metersCountOrderByAggregateInput
    _avg?: metersAvgOrderByAggregateInput
    _max?: metersMaxOrderByAggregateInput
    _min?: metersMinOrderByAggregateInput
    _sum?: metersSumOrderByAggregateInput
  }

  export type metersScalarWhereWithAggregatesInput = {
    AND?: metersScalarWhereWithAggregatesInput | metersScalarWhereWithAggregatesInput[]
    OR?: metersScalarWhereWithAggregatesInput[]
    NOT?: metersScalarWhereWithAggregatesInput | metersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"meters"> | number
    meterNumber?: StringWithAggregatesFilter<"meters"> | string
    serialNumber?: StringWithAggregatesFilter<"meters"> | string
    manufacturer?: StringWithAggregatesFilter<"meters"> | string
    model?: StringWithAggregatesFilter<"meters"> | string
    type?: EnumMeterTypeWithAggregatesFilter<"meters"> | $Enums.MeterType
    phase?: IntWithAggregatesFilter<"meters"> | number
    status?: EnumMeterStatusWithAggregatesFilter<"meters"> | $Enums.MeterStatus
    isInUse?: BoolWithAggregatesFilter<"meters"> | boolean
    installationDate?: DateTimeWithAggregatesFilter<"meters"> | Date | string
    lastMaintenanceDate?: DateTimeNullableWithAggregatesFilter<"meters"> | Date | string | null
    decommissionDate?: DateTimeNullableWithAggregatesFilter<"meters"> | Date | string | null
    locationId?: IntWithAggregatesFilter<"meters"> | number
    dtrId?: IntNullableWithAggregatesFilter<"meters"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"meters"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"meters"> | Date | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: IntFilter<"notifications"> | number
    consumerId?: IntFilter<"notifications"> | number
    type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    priority?: EnumNotificationPriorityFilter<"notifications"> | $Enums.NotificationPriority
    channels?: EnumNotificationChannelNullableListFilter<"notifications">
    status?: EnumNotificationStatusFilter<"notifications"> | $Enums.NotificationStatus
    readAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    updatedAt?: DateTimeFilter<"notifications"> | Date | string
    consumers?: XOR<ConsumersRelationFilter, consumersWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    consumerId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channels?: SortOrder
    status?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consumers?: consumersOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    consumerId?: IntFilter<"notifications"> | number
    type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    priority?: EnumNotificationPriorityFilter<"notifications"> | $Enums.NotificationPriority
    channels?: EnumNotificationChannelNullableListFilter<"notifications">
    status?: EnumNotificationStatusFilter<"notifications"> | $Enums.NotificationStatus
    readAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    updatedAt?: DateTimeFilter<"notifications"> | Date | string
    consumers?: XOR<ConsumersRelationFilter, consumersWhereInput>
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    consumerId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channels?: SortOrder
    status?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _avg?: notificationsAvgOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
    _sum?: notificationsSumOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notifications"> | number
    consumerId?: IntWithAggregatesFilter<"notifications"> | number
    type?: EnumNotificationTypeWithAggregatesFilter<"notifications"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"notifications"> | string
    message?: StringWithAggregatesFilter<"notifications"> | string
    priority?: EnumNotificationPriorityWithAggregatesFilter<"notifications"> | $Enums.NotificationPriority
    channels?: EnumNotificationChannelNullableListFilter<"notifications">
    status?: EnumNotificationStatusWithAggregatesFilter<"notifications"> | $Enums.NotificationStatus
    readAt?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: IntFilter<"payments"> | number
    transactionId?: StringFilter<"payments"> | string
    billId?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    paymentMode?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    gatewayResponse?: JsonNullableFilter<"payments">
    receiptNumber?: StringNullableFilter<"payments"> | string | null
    createdAt?: DateTimeFilter<"payments"> | Date | string
    updatedAt?: DateTimeFilter<"payments"> | Date | string
    bills?: XOR<BillsRelationFilter, billsWhereInput>
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    billId?: SortOrder
    amount?: SortOrder
    paymentMode?: SortOrder
    paymentStatus?: SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bills?: billsOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transactionId?: string
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    billId?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    paymentMode?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    gatewayResponse?: JsonNullableFilter<"payments">
    receiptNumber?: StringNullableFilter<"payments"> | string | null
    createdAt?: DateTimeFilter<"payments"> | Date | string
    updatedAt?: DateTimeFilter<"payments"> | Date | string
    bills?: XOR<BillsRelationFilter, billsWhereInput>
  }, "id" | "transactionId">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    billId?: SortOrder
    amount?: SortOrder
    paymentMode?: SortOrder
    paymentStatus?: SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payments"> | number
    transactionId?: StringWithAggregatesFilter<"payments"> | string
    billId?: IntWithAggregatesFilter<"payments"> | number
    amount?: FloatWithAggregatesFilter<"payments"> | number
    paymentMode?: EnumPaymentMethodWithAggregatesFilter<"payments"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"payments"> | $Enums.PaymentStatus
    gatewayResponse?: JsonNullableWithAggregatesFilter<"payments">
    receiptNumber?: StringNullableWithAggregatesFilter<"payments"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"payments"> | Date | string
  }

  export type permissionsWhereInput = {
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    id?: IntFilter<"permissions"> | number
    code?: StringFilter<"permissions"> | string
    name?: StringFilter<"permissions"> | string
    description?: StringNullableFilter<"permissions"> | string | null
    isActive?: BoolFilter<"permissions"> | boolean
    createdAt?: DateTimeFilter<"permissions"> | Date | string
    updatedAt?: DateTimeFilter<"permissions"> | Date | string
    user_permissions?: User_permissionsListRelationFilter
  }

  export type permissionsOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_permissions?: user_permissionsOrderByRelationAggregateInput
  }

  export type permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    name?: StringFilter<"permissions"> | string
    description?: StringNullableFilter<"permissions"> | string | null
    isActive?: BoolFilter<"permissions"> | boolean
    createdAt?: DateTimeFilter<"permissions"> | Date | string
    updatedAt?: DateTimeFilter<"permissions"> | Date | string
    user_permissions?: User_permissionsListRelationFilter
  }, "id" | "code">

  export type permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: permissionsCountOrderByAggregateInput
    _avg?: permissionsAvgOrderByAggregateInput
    _max?: permissionsMaxOrderByAggregateInput
    _min?: permissionsMinOrderByAggregateInput
    _sum?: permissionsSumOrderByAggregateInput
  }

  export type permissionsScalarWhereWithAggregatesInput = {
    AND?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    OR?: permissionsScalarWhereWithAggregatesInput[]
    NOT?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"permissions"> | number
    code?: StringWithAggregatesFilter<"permissions"> | string
    name?: StringWithAggregatesFilter<"permissions"> | string
    description?: StringNullableWithAggregatesFilter<"permissions"> | string | null
    isActive?: BoolWithAggregatesFilter<"permissions"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"permissions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"permissions"> | Date | string
  }

  export type potential_transformersWhereInput = {
    AND?: potential_transformersWhereInput | potential_transformersWhereInput[]
    OR?: potential_transformersWhereInput[]
    NOT?: potential_transformersWhereInput | potential_transformersWhereInput[]
    id?: IntFilter<"potential_transformers"> | number
    meterId?: IntFilter<"potential_transformers"> | number
    serialNumber?: StringFilter<"potential_transformers"> | string
    manufacturer?: StringFilter<"potential_transformers"> | string
    model?: StringFilter<"potential_transformers"> | string
    ratedPrimary?: FloatFilter<"potential_transformers"> | number
    ratedSecondary?: FloatFilter<"potential_transformers"> | number
    accuracyClass?: StringFilter<"potential_transformers"> | string
    burden?: FloatFilter<"potential_transformers"> | number
    installationDate?: DateTimeFilter<"potential_transformers"> | Date | string
    lastTestedDate?: DateTimeNullableFilter<"potential_transformers"> | Date | string | null
    nextTestDue?: DateTimeNullableFilter<"potential_transformers"> | Date | string | null
    createdAt?: DateTimeFilter<"potential_transformers"> | Date | string
    updatedAt?: DateTimeFilter<"potential_transformers"> | Date | string
    meters?: XOR<MetersRelationFilter, metersWhereInput>
  }

  export type potential_transformersOrderByWithRelationInput = {
    id?: SortOrder
    meterId?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    accuracyClass?: SortOrder
    burden?: SortOrder
    installationDate?: SortOrder
    lastTestedDate?: SortOrderInput | SortOrder
    nextTestDue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meters?: metersOrderByWithRelationInput
  }

  export type potential_transformersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serialNumber?: string
    AND?: potential_transformersWhereInput | potential_transformersWhereInput[]
    OR?: potential_transformersWhereInput[]
    NOT?: potential_transformersWhereInput | potential_transformersWhereInput[]
    meterId?: IntFilter<"potential_transformers"> | number
    manufacturer?: StringFilter<"potential_transformers"> | string
    model?: StringFilter<"potential_transformers"> | string
    ratedPrimary?: FloatFilter<"potential_transformers"> | number
    ratedSecondary?: FloatFilter<"potential_transformers"> | number
    accuracyClass?: StringFilter<"potential_transformers"> | string
    burden?: FloatFilter<"potential_transformers"> | number
    installationDate?: DateTimeFilter<"potential_transformers"> | Date | string
    lastTestedDate?: DateTimeNullableFilter<"potential_transformers"> | Date | string | null
    nextTestDue?: DateTimeNullableFilter<"potential_transformers"> | Date | string | null
    createdAt?: DateTimeFilter<"potential_transformers"> | Date | string
    updatedAt?: DateTimeFilter<"potential_transformers"> | Date | string
    meters?: XOR<MetersRelationFilter, metersWhereInput>
  }, "id" | "serialNumber">

  export type potential_transformersOrderByWithAggregationInput = {
    id?: SortOrder
    meterId?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    accuracyClass?: SortOrder
    burden?: SortOrder
    installationDate?: SortOrder
    lastTestedDate?: SortOrderInput | SortOrder
    nextTestDue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: potential_transformersCountOrderByAggregateInput
    _avg?: potential_transformersAvgOrderByAggregateInput
    _max?: potential_transformersMaxOrderByAggregateInput
    _min?: potential_transformersMinOrderByAggregateInput
    _sum?: potential_transformersSumOrderByAggregateInput
  }

  export type potential_transformersScalarWhereWithAggregatesInput = {
    AND?: potential_transformersScalarWhereWithAggregatesInput | potential_transformersScalarWhereWithAggregatesInput[]
    OR?: potential_transformersScalarWhereWithAggregatesInput[]
    NOT?: potential_transformersScalarWhereWithAggregatesInput | potential_transformersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"potential_transformers"> | number
    meterId?: IntWithAggregatesFilter<"potential_transformers"> | number
    serialNumber?: StringWithAggregatesFilter<"potential_transformers"> | string
    manufacturer?: StringWithAggregatesFilter<"potential_transformers"> | string
    model?: StringWithAggregatesFilter<"potential_transformers"> | string
    ratedPrimary?: FloatWithAggregatesFilter<"potential_transformers"> | number
    ratedSecondary?: FloatWithAggregatesFilter<"potential_transformers"> | number
    accuracyClass?: StringWithAggregatesFilter<"potential_transformers"> | string
    burden?: FloatWithAggregatesFilter<"potential_transformers"> | number
    installationDate?: DateTimeWithAggregatesFilter<"potential_transformers"> | Date | string
    lastTestedDate?: DateTimeNullableWithAggregatesFilter<"potential_transformers"> | Date | string | null
    nextTestDue?: DateTimeNullableWithAggregatesFilter<"potential_transformers"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"potential_transformers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"potential_transformers"> | Date | string
  }

  export type role_permissionsWhereInput = {
    AND?: role_permissionsWhereInput | role_permissionsWhereInput[]
    OR?: role_permissionsWhereInput[]
    NOT?: role_permissionsWhereInput | role_permissionsWhereInput[]
    id?: IntFilter<"role_permissions"> | number
    roleId?: IntFilter<"role_permissions"> | number
    permissionId?: JsonFilter<"role_permissions">
    isGranted?: BoolFilter<"role_permissions"> | boolean
    restrictions?: JsonNullableFilter<"role_permissions">
    createdAt?: DateTimeFilter<"role_permissions"> | Date | string
    updatedAt?: DateTimeFilter<"role_permissions"> | Date | string
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }

  export type role_permissionsOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    isGranted?: SortOrder
    restrictions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: rolesOrderByWithRelationInput
  }

  export type role_permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roleId_permissionId?: role_permissionsRoleIdPermissionIdCompoundUniqueInput
    AND?: role_permissionsWhereInput | role_permissionsWhereInput[]
    OR?: role_permissionsWhereInput[]
    NOT?: role_permissionsWhereInput | role_permissionsWhereInput[]
    roleId?: IntFilter<"role_permissions"> | number
    permissionId?: JsonFilter<"role_permissions">
    isGranted?: BoolFilter<"role_permissions"> | boolean
    restrictions?: JsonNullableFilter<"role_permissions">
    createdAt?: DateTimeFilter<"role_permissions"> | Date | string
    updatedAt?: DateTimeFilter<"role_permissions"> | Date | string
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }, "id" | "roleId_permissionId">

  export type role_permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    isGranted?: SortOrder
    restrictions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: role_permissionsCountOrderByAggregateInput
    _avg?: role_permissionsAvgOrderByAggregateInput
    _max?: role_permissionsMaxOrderByAggregateInput
    _min?: role_permissionsMinOrderByAggregateInput
    _sum?: role_permissionsSumOrderByAggregateInput
  }

  export type role_permissionsScalarWhereWithAggregatesInput = {
    AND?: role_permissionsScalarWhereWithAggregatesInput | role_permissionsScalarWhereWithAggregatesInput[]
    OR?: role_permissionsScalarWhereWithAggregatesInput[]
    NOT?: role_permissionsScalarWhereWithAggregatesInput | role_permissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"role_permissions"> | number
    roleId?: IntWithAggregatesFilter<"role_permissions"> | number
    permissionId?: JsonWithAggregatesFilter<"role_permissions">
    isGranted?: BoolWithAggregatesFilter<"role_permissions"> | boolean
    restrictions?: JsonNullableWithAggregatesFilter<"role_permissions">
    createdAt?: DateTimeWithAggregatesFilter<"role_permissions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"role_permissions"> | Date | string
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: IntFilter<"roles"> | number
    name?: StringFilter<"roles"> | string
    description?: StringNullableFilter<"roles"> | string | null
    level?: IntFilter<"roles"> | number
    isSystem?: BoolFilter<"roles"> | boolean
    isActive?: BoolFilter<"roles"> | boolean
    accessLevel?: EnumAccessLevelFilter<"roles"> | $Enums.AccessLevel
    createdAt?: DateTimeFilter<"roles"> | Date | string
    updatedAt?: DateTimeFilter<"roles"> | Date | string
    role_permissions?: Role_permissionsListRelationFilter
    users?: UsersListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role_permissions?: role_permissionsOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    description?: StringNullableFilter<"roles"> | string | null
    level?: IntFilter<"roles"> | number
    isSystem?: BoolFilter<"roles"> | boolean
    isActive?: BoolFilter<"roles"> | boolean
    accessLevel?: EnumAccessLevelFilter<"roles"> | $Enums.AccessLevel
    createdAt?: DateTimeFilter<"roles"> | Date | string
    updatedAt?: DateTimeFilter<"roles"> | Date | string
    role_permissions?: Role_permissionsListRelationFilter
    users?: UsersListRelationFilter
  }, "id" | "name">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles"> | number
    name?: StringWithAggregatesFilter<"roles"> | string
    description?: StringNullableWithAggregatesFilter<"roles"> | string | null
    level?: IntWithAggregatesFilter<"roles"> | number
    isSystem?: BoolWithAggregatesFilter<"roles"> | boolean
    isActive?: BoolWithAggregatesFilter<"roles"> | boolean
    accessLevel?: EnumAccessLevelWithAggregatesFilter<"roles"> | $Enums.AccessLevel
    createdAt?: DateTimeWithAggregatesFilter<"roles"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"roles"> | Date | string
  }

  export type ticketsWhereInput = {
    AND?: ticketsWhereInput | ticketsWhereInput[]
    OR?: ticketsWhereInput[]
    NOT?: ticketsWhereInput | ticketsWhereInput[]
    id?: IntFilter<"tickets"> | number
    ticketNumber?: StringFilter<"tickets"> | string
    dtrId?: IntNullableFilter<"tickets"> | number | null
    raisedById?: IntFilter<"tickets"> | number
    assignedToId?: IntNullableFilter<"tickets"> | number | null
    type?: EnumTicketTypeFilter<"tickets"> | $Enums.TicketType
    category?: EnumTicketCategoryFilter<"tickets"> | $Enums.TicketCategory
    priority?: EnumTicketPriorityFilter<"tickets"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"tickets"> | $Enums.TicketStatus
    subject?: StringFilter<"tickets"> | string
    description?: StringFilter<"tickets"> | string
    resolution?: StringNullableFilter<"tickets"> | string | null
    createdAt?: DateTimeFilter<"tickets"> | Date | string
    updatedAt?: DateTimeFilter<"tickets"> | Date | string
    users_tickets_assignedToIdTousers?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    dtrs?: XOR<DtrsNullableRelationFilter, dtrsWhereInput> | null
    users_tickets_raisedByIdTousers?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type ticketsOrderByWithRelationInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    dtrId?: SortOrderInput | SortOrder
    raisedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_tickets_assignedToIdTousers?: usersOrderByWithRelationInput
    dtrs?: dtrsOrderByWithRelationInput
    users_tickets_raisedByIdTousers?: usersOrderByWithRelationInput
  }

  export type ticketsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ticketNumber?: string
    AND?: ticketsWhereInput | ticketsWhereInput[]
    OR?: ticketsWhereInput[]
    NOT?: ticketsWhereInput | ticketsWhereInput[]
    dtrId?: IntNullableFilter<"tickets"> | number | null
    raisedById?: IntFilter<"tickets"> | number
    assignedToId?: IntNullableFilter<"tickets"> | number | null
    type?: EnumTicketTypeFilter<"tickets"> | $Enums.TicketType
    category?: EnumTicketCategoryFilter<"tickets"> | $Enums.TicketCategory
    priority?: EnumTicketPriorityFilter<"tickets"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"tickets"> | $Enums.TicketStatus
    subject?: StringFilter<"tickets"> | string
    description?: StringFilter<"tickets"> | string
    resolution?: StringNullableFilter<"tickets"> | string | null
    createdAt?: DateTimeFilter<"tickets"> | Date | string
    updatedAt?: DateTimeFilter<"tickets"> | Date | string
    users_tickets_assignedToIdTousers?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    dtrs?: XOR<DtrsNullableRelationFilter, dtrsWhereInput> | null
    users_tickets_raisedByIdTousers?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "ticketNumber">

  export type ticketsOrderByWithAggregationInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    dtrId?: SortOrderInput | SortOrder
    raisedById?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ticketsCountOrderByAggregateInput
    _avg?: ticketsAvgOrderByAggregateInput
    _max?: ticketsMaxOrderByAggregateInput
    _min?: ticketsMinOrderByAggregateInput
    _sum?: ticketsSumOrderByAggregateInput
  }

  export type ticketsScalarWhereWithAggregatesInput = {
    AND?: ticketsScalarWhereWithAggregatesInput | ticketsScalarWhereWithAggregatesInput[]
    OR?: ticketsScalarWhereWithAggregatesInput[]
    NOT?: ticketsScalarWhereWithAggregatesInput | ticketsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tickets"> | number
    ticketNumber?: StringWithAggregatesFilter<"tickets"> | string
    dtrId?: IntNullableWithAggregatesFilter<"tickets"> | number | null
    raisedById?: IntWithAggregatesFilter<"tickets"> | number
    assignedToId?: IntNullableWithAggregatesFilter<"tickets"> | number | null
    type?: EnumTicketTypeWithAggregatesFilter<"tickets"> | $Enums.TicketType
    category?: EnumTicketCategoryWithAggregatesFilter<"tickets"> | $Enums.TicketCategory
    priority?: EnumTicketPriorityWithAggregatesFilter<"tickets"> | $Enums.TicketPriority
    status?: EnumTicketStatusWithAggregatesFilter<"tickets"> | $Enums.TicketStatus
    subject?: StringWithAggregatesFilter<"tickets"> | string
    description?: StringWithAggregatesFilter<"tickets"> | string
    resolution?: StringNullableWithAggregatesFilter<"tickets"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"tickets"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tickets"> | Date | string
  }

  export type user_activity_logsWhereInput = {
    AND?: user_activity_logsWhereInput | user_activity_logsWhereInput[]
    OR?: user_activity_logsWhereInput[]
    NOT?: user_activity_logsWhereInput | user_activity_logsWhereInput[]
    id?: IntFilter<"user_activity_logs"> | number
    userId?: IntFilter<"user_activity_logs"> | number
    action?: StringFilter<"user_activity_logs"> | string
    details?: JsonNullableFilter<"user_activity_logs">
    ipAddress?: StringNullableFilter<"user_activity_logs"> | string | null
    createdAt?: DateTimeFilter<"user_activity_logs"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_activity_logsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_activity_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: user_activity_logsWhereInput | user_activity_logsWhereInput[]
    OR?: user_activity_logsWhereInput[]
    NOT?: user_activity_logsWhereInput | user_activity_logsWhereInput[]
    userId?: IntFilter<"user_activity_logs"> | number
    action?: StringFilter<"user_activity_logs"> | string
    details?: JsonNullableFilter<"user_activity_logs">
    ipAddress?: StringNullableFilter<"user_activity_logs"> | string | null
    createdAt?: DateTimeFilter<"user_activity_logs"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type user_activity_logsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: user_activity_logsCountOrderByAggregateInput
    _avg?: user_activity_logsAvgOrderByAggregateInput
    _max?: user_activity_logsMaxOrderByAggregateInput
    _min?: user_activity_logsMinOrderByAggregateInput
    _sum?: user_activity_logsSumOrderByAggregateInput
  }

  export type user_activity_logsScalarWhereWithAggregatesInput = {
    AND?: user_activity_logsScalarWhereWithAggregatesInput | user_activity_logsScalarWhereWithAggregatesInput[]
    OR?: user_activity_logsScalarWhereWithAggregatesInput[]
    NOT?: user_activity_logsScalarWhereWithAggregatesInput | user_activity_logsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_activity_logs"> | number
    userId?: IntWithAggregatesFilter<"user_activity_logs"> | number
    action?: StringWithAggregatesFilter<"user_activity_logs"> | string
    details?: JsonNullableWithAggregatesFilter<"user_activity_logs">
    ipAddress?: StringNullableWithAggregatesFilter<"user_activity_logs"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"user_activity_logs"> | Date | string
  }

  export type user_permissionsWhereInput = {
    AND?: user_permissionsWhereInput | user_permissionsWhereInput[]
    OR?: user_permissionsWhereInput[]
    NOT?: user_permissionsWhereInput | user_permissionsWhereInput[]
    id?: IntFilter<"user_permissions"> | number
    userId?: IntFilter<"user_permissions"> | number
    permissionId?: IntFilter<"user_permissions"> | number
    isGranted?: BoolFilter<"user_permissions"> | boolean
    reason?: StringNullableFilter<"user_permissions"> | string | null
    validFrom?: DateTimeFilter<"user_permissions"> | Date | string
    validUntil?: DateTimeNullableFilter<"user_permissions"> | Date | string | null
    createdAt?: DateTimeFilter<"user_permissions"> | Date | string
    updatedAt?: DateTimeFilter<"user_permissions"> | Date | string
    permissions?: XOR<PermissionsRelationFilter, permissionsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_permissionsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionId?: SortOrder
    isGranted?: SortOrder
    reason?: SortOrderInput | SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: permissionsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type user_permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_permissionId?: user_permissionsUserIdPermissionIdCompoundUniqueInput
    AND?: user_permissionsWhereInput | user_permissionsWhereInput[]
    OR?: user_permissionsWhereInput[]
    NOT?: user_permissionsWhereInput | user_permissionsWhereInput[]
    userId?: IntFilter<"user_permissions"> | number
    permissionId?: IntFilter<"user_permissions"> | number
    isGranted?: BoolFilter<"user_permissions"> | boolean
    reason?: StringNullableFilter<"user_permissions"> | string | null
    validFrom?: DateTimeFilter<"user_permissions"> | Date | string
    validUntil?: DateTimeNullableFilter<"user_permissions"> | Date | string | null
    createdAt?: DateTimeFilter<"user_permissions"> | Date | string
    updatedAt?: DateTimeFilter<"user_permissions"> | Date | string
    permissions?: XOR<PermissionsRelationFilter, permissionsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "userId_permissionId">

  export type user_permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionId?: SortOrder
    isGranted?: SortOrder
    reason?: SortOrderInput | SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: user_permissionsCountOrderByAggregateInput
    _avg?: user_permissionsAvgOrderByAggregateInput
    _max?: user_permissionsMaxOrderByAggregateInput
    _min?: user_permissionsMinOrderByAggregateInput
    _sum?: user_permissionsSumOrderByAggregateInput
  }

  export type user_permissionsScalarWhereWithAggregatesInput = {
    AND?: user_permissionsScalarWhereWithAggregatesInput | user_permissionsScalarWhereWithAggregatesInput[]
    OR?: user_permissionsScalarWhereWithAggregatesInput[]
    NOT?: user_permissionsScalarWhereWithAggregatesInput | user_permissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_permissions"> | number
    userId?: IntWithAggregatesFilter<"user_permissions"> | number
    permissionId?: IntWithAggregatesFilter<"user_permissions"> | number
    isGranted?: BoolWithAggregatesFilter<"user_permissions"> | boolean
    reason?: StringNullableWithAggregatesFilter<"user_permissions"> | string | null
    validFrom?: DateTimeWithAggregatesFilter<"user_permissions"> | Date | string
    validUntil?: DateTimeNullableWithAggregatesFilter<"user_permissions"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"user_permissions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user_permissions"> | Date | string
  }

  export type user_sessionsWhereInput = {
    AND?: user_sessionsWhereInput | user_sessionsWhereInput[]
    OR?: user_sessionsWhereInput[]
    NOT?: user_sessionsWhereInput | user_sessionsWhereInput[]
    id?: IntFilter<"user_sessions"> | number
    userId?: IntFilter<"user_sessions"> | number
    sessionToken?: StringFilter<"user_sessions"> | string
    deviceInfo?: JsonNullableFilter<"user_sessions">
    ipAddress?: StringNullableFilter<"user_sessions"> | string | null
    location?: StringNullableFilter<"user_sessions"> | string | null
    isActive?: BoolFilter<"user_sessions"> | boolean
    lastActivityAt?: DateTimeFilter<"user_sessions"> | Date | string
    expiresAt?: DateTimeFilter<"user_sessions"> | Date | string
    createdAt?: DateTimeFilter<"user_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"user_sessions"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastActivityAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionToken?: string
    AND?: user_sessionsWhereInput | user_sessionsWhereInput[]
    OR?: user_sessionsWhereInput[]
    NOT?: user_sessionsWhereInput | user_sessionsWhereInput[]
    userId?: IntFilter<"user_sessions"> | number
    deviceInfo?: JsonNullableFilter<"user_sessions">
    ipAddress?: StringNullableFilter<"user_sessions"> | string | null
    location?: StringNullableFilter<"user_sessions"> | string | null
    isActive?: BoolFilter<"user_sessions"> | boolean
    lastActivityAt?: DateTimeFilter<"user_sessions"> | Date | string
    expiresAt?: DateTimeFilter<"user_sessions"> | Date | string
    createdAt?: DateTimeFilter<"user_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"user_sessions"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "sessionToken">

  export type user_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastActivityAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: user_sessionsCountOrderByAggregateInput
    _avg?: user_sessionsAvgOrderByAggregateInput
    _max?: user_sessionsMaxOrderByAggregateInput
    _min?: user_sessionsMinOrderByAggregateInput
    _sum?: user_sessionsSumOrderByAggregateInput
  }

  export type user_sessionsScalarWhereWithAggregatesInput = {
    AND?: user_sessionsScalarWhereWithAggregatesInput | user_sessionsScalarWhereWithAggregatesInput[]
    OR?: user_sessionsScalarWhereWithAggregatesInput[]
    NOT?: user_sessionsScalarWhereWithAggregatesInput | user_sessionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_sessions"> | number
    userId?: IntWithAggregatesFilter<"user_sessions"> | number
    sessionToken?: StringWithAggregatesFilter<"user_sessions"> | string
    deviceInfo?: JsonNullableWithAggregatesFilter<"user_sessions">
    ipAddress?: StringNullableWithAggregatesFilter<"user_sessions"> | string | null
    location?: StringNullableWithAggregatesFilter<"user_sessions"> | string | null
    isActive?: BoolWithAggregatesFilter<"user_sessions"> | boolean
    lastActivityAt?: DateTimeWithAggregatesFilter<"user_sessions"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"user_sessions"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"user_sessions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user_sessions"> | Date | string
  }

  export type refresh_tokensWhereInput = {
    AND?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    OR?: refresh_tokensWhereInput[]
    NOT?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    id?: IntFilter<"refresh_tokens"> | number
    userId?: IntFilter<"refresh_tokens"> | number
    token?: StringFilter<"refresh_tokens"> | string
    expiresAt?: DateTimeFilter<"refresh_tokens"> | Date | string
    createdAt?: DateTimeFilter<"refresh_tokens"> | Date | string
    updatedAt?: DateTimeFilter<"refresh_tokens"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type refresh_tokensOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type refresh_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    OR?: refresh_tokensWhereInput[]
    NOT?: refresh_tokensWhereInput | refresh_tokensWhereInput[]
    token?: StringFilter<"refresh_tokens"> | string
    expiresAt?: DateTimeFilter<"refresh_tokens"> | Date | string
    createdAt?: DateTimeFilter<"refresh_tokens"> | Date | string
    updatedAt?: DateTimeFilter<"refresh_tokens"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "userId">

  export type refresh_tokensOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: refresh_tokensCountOrderByAggregateInput
    _avg?: refresh_tokensAvgOrderByAggregateInput
    _max?: refresh_tokensMaxOrderByAggregateInput
    _min?: refresh_tokensMinOrderByAggregateInput
    _sum?: refresh_tokensSumOrderByAggregateInput
  }

  export type refresh_tokensScalarWhereWithAggregatesInput = {
    AND?: refresh_tokensScalarWhereWithAggregatesInput | refresh_tokensScalarWhereWithAggregatesInput[]
    OR?: refresh_tokensScalarWhereWithAggregatesInput[]
    NOT?: refresh_tokensScalarWhereWithAggregatesInput | refresh_tokensScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"refresh_tokens"> | number
    userId?: IntWithAggregatesFilter<"refresh_tokens"> | number
    token?: StringWithAggregatesFilter<"refresh_tokens"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"refresh_tokens"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"refresh_tokens"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"refresh_tokens"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    username?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    firstName?: StringFilter<"users"> | string
    lastName?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    profileImage?: StringNullableFilter<"users"> | string | null
    isActive?: BoolFilter<"users"> | boolean
    isLocked?: BoolFilter<"users"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"users"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    failedLoginAttempts?: IntFilter<"users"> | number
    lockoutUntil?: DateTimeNullableFilter<"users"> | Date | string | null
    departmentId?: IntNullableFilter<"users"> | number | null
    roleId?: IntNullableFilter<"users"> | number | null
    locationId?: IntNullableFilter<"users"> | number | null
    accessLevel?: EnumAccessLevelFilter<"users"> | $Enums.AccessLevel
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    createdBy?: IntNullableFilter<"users"> | number | null
    updatedBy?: IntNullableFilter<"users"> | number | null
    login_history?: Login_historyListRelationFilter
    tickets_tickets_assignedToIdTousers?: TicketsListRelationFilter
    tickets_tickets_raisedByIdTousers?: TicketsListRelationFilter
    user_activity_logs?: User_activity_logsListRelationFilter
    user_permissions?: User_permissionsListRelationFilter
    user_sessions?: User_sessionsListRelationFilter
    refresh_tokens?: XOR<Refresh_tokensNullableRelationFilter, refresh_tokensWhereInput> | null
    departments?: XOR<DepartmentsNullableRelationFilter, departmentsWhereInput> | null
    roles?: XOR<RolesNullableRelationFilter, rolesWhereInput> | null
    locations?: XOR<LocationsNullableRelationFilter, locationsWhereInput> | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockoutUntil?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    roleId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    login_history?: login_historyOrderByRelationAggregateInput
    tickets_tickets_assignedToIdTousers?: ticketsOrderByRelationAggregateInput
    tickets_tickets_raisedByIdTousers?: ticketsOrderByRelationAggregateInput
    user_activity_logs?: user_activity_logsOrderByRelationAggregateInput
    user_permissions?: user_permissionsOrderByRelationAggregateInput
    user_sessions?: user_sessionsOrderByRelationAggregateInput
    refresh_tokens?: refresh_tokensOrderByWithRelationInput
    departments?: departmentsOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
    locations?: locationsOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    firstName?: StringFilter<"users"> | string
    lastName?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    profileImage?: StringNullableFilter<"users"> | string | null
    isActive?: BoolFilter<"users"> | boolean
    isLocked?: BoolFilter<"users"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"users"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    failedLoginAttempts?: IntFilter<"users"> | number
    lockoutUntil?: DateTimeNullableFilter<"users"> | Date | string | null
    departmentId?: IntNullableFilter<"users"> | number | null
    roleId?: IntNullableFilter<"users"> | number | null
    locationId?: IntNullableFilter<"users"> | number | null
    accessLevel?: EnumAccessLevelFilter<"users"> | $Enums.AccessLevel
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    createdBy?: IntNullableFilter<"users"> | number | null
    updatedBy?: IntNullableFilter<"users"> | number | null
    login_history?: Login_historyListRelationFilter
    tickets_tickets_assignedToIdTousers?: TicketsListRelationFilter
    tickets_tickets_raisedByIdTousers?: TicketsListRelationFilter
    user_activity_logs?: User_activity_logsListRelationFilter
    user_permissions?: User_permissionsListRelationFilter
    user_sessions?: User_sessionsListRelationFilter
    refresh_tokens?: XOR<Refresh_tokensNullableRelationFilter, refresh_tokensWhereInput> | null
    departments?: XOR<DepartmentsNullableRelationFilter, departmentsWhereInput> | null
    roles?: XOR<RolesNullableRelationFilter, rolesWhereInput> | null
    locations?: XOR<LocationsNullableRelationFilter, locationsWhereInput> | null
  }, "id" | "username" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockoutUntil?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    roleId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    username?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    firstName?: StringWithAggregatesFilter<"users"> | string
    lastName?: StringWithAggregatesFilter<"users"> | string
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"users"> | string | null
    isActive?: BoolWithAggregatesFilter<"users"> | boolean
    isLocked?: BoolWithAggregatesFilter<"users"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    passwordChangedAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    failedLoginAttempts?: IntWithAggregatesFilter<"users"> | number
    lockoutUntil?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    departmentId?: IntNullableWithAggregatesFilter<"users"> | number | null
    roleId?: IntNullableWithAggregatesFilter<"users"> | number | null
    locationId?: IntNullableWithAggregatesFilter<"users"> | number | null
    accessLevel?: EnumAccessLevelWithAggregatesFilter<"users"> | $Enums.AccessLevel
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    createdBy?: IntNullableWithAggregatesFilter<"users"> | number | null
    updatedBy?: IntNullableWithAggregatesFilter<"users"> | number | null
  }

  export type raw_xml_importWhereInput = {
    AND?: raw_xml_importWhereInput | raw_xml_importWhereInput[]
    OR?: raw_xml_importWhereInput[]
    NOT?: raw_xml_importWhereInput | raw_xml_importWhereInput[]
    id?: IntFilter<"raw_xml_import"> | number
    doc?: StringFilter<"raw_xml_import"> | string
    imported_at?: DateTimeNullableFilter<"raw_xml_import"> | Date | string | null
  }

  export type raw_xml_importOrderByWithRelationInput = {
    id?: SortOrder
    doc?: SortOrder
    imported_at?: SortOrderInput | SortOrder
  }

  export type raw_xml_importWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: raw_xml_importWhereInput | raw_xml_importWhereInput[]
    OR?: raw_xml_importWhereInput[]
    NOT?: raw_xml_importWhereInput | raw_xml_importWhereInput[]
    doc?: StringFilter<"raw_xml_import"> | string
    imported_at?: DateTimeNullableFilter<"raw_xml_import"> | Date | string | null
  }, "id">

  export type raw_xml_importOrderByWithAggregationInput = {
    id?: SortOrder
    doc?: SortOrder
    imported_at?: SortOrderInput | SortOrder
    _count?: raw_xml_importCountOrderByAggregateInput
    _avg?: raw_xml_importAvgOrderByAggregateInput
    _max?: raw_xml_importMaxOrderByAggregateInput
    _min?: raw_xml_importMinOrderByAggregateInput
    _sum?: raw_xml_importSumOrderByAggregateInput
  }

  export type raw_xml_importScalarWhereWithAggregatesInput = {
    AND?: raw_xml_importScalarWhereWithAggregatesInput | raw_xml_importScalarWhereWithAggregatesInput[]
    OR?: raw_xml_importScalarWhereWithAggregatesInput[]
    NOT?: raw_xml_importScalarWhereWithAggregatesInput | raw_xml_importScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"raw_xml_import"> | number
    doc?: StringWithAggregatesFilter<"raw_xml_import"> | string
    imported_at?: DateTimeNullableWithAggregatesFilter<"raw_xml_import"> | Date | string | null
  }

  export type prepaid_accountsWhereInput = {
    AND?: prepaid_accountsWhereInput | prepaid_accountsWhereInput[]
    OR?: prepaid_accountsWhereInput[]
    NOT?: prepaid_accountsWhereInput | prepaid_accountsWhereInput[]
    id?: IntFilter<"prepaid_accounts"> | number
    consumerId?: IntFilter<"prepaid_accounts"> | number
    accountNumber?: StringFilter<"prepaid_accounts"> | string
    currentBalance?: FloatFilter<"prepaid_accounts"> | number
    totalRecharged?: FloatFilter<"prepaid_accounts"> | number
    totalConsumed?: FloatFilter<"prepaid_accounts"> | number
    isActive?: BoolFilter<"prepaid_accounts"> | boolean
    isBlocked?: BoolFilter<"prepaid_accounts"> | boolean
    blockReason?: StringNullableFilter<"prepaid_accounts"> | string | null
    blockedAt?: DateTimeNullableFilter<"prepaid_accounts"> | Date | string | null
    blockedBy?: IntNullableFilter<"prepaid_accounts"> | number | null
    lowBalanceThreshold?: FloatFilter<"prepaid_accounts"> | number
    emergencyThreshold?: FloatFilter<"prepaid_accounts"> | number
    autoRechargeEnabled?: BoolFilter<"prepaid_accounts"> | boolean
    autoRechargeAmount?: FloatNullableFilter<"prepaid_accounts"> | number | null
    autoRechargeThreshold?: FloatNullableFilter<"prepaid_accounts"> | number | null
    createdAt?: DateTimeFilter<"prepaid_accounts"> | Date | string
    updatedAt?: DateTimeFilter<"prepaid_accounts"> | Date | string
    consumers?: XOR<ConsumersRelationFilter, consumersWhereInput>
    prepaid_alerts?: Prepaid_alertsListRelationFilter
    prepaid_recharges?: Prepaid_rechargesListRelationFilter
    prepaid_transactions?: Prepaid_transactionsListRelationFilter
  }

  export type prepaid_accountsOrderByWithRelationInput = {
    id?: SortOrder
    consumerId?: SortOrder
    accountNumber?: SortOrder
    currentBalance?: SortOrder
    totalRecharged?: SortOrder
    totalConsumed?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    blockReason?: SortOrderInput | SortOrder
    blockedAt?: SortOrderInput | SortOrder
    blockedBy?: SortOrderInput | SortOrder
    lowBalanceThreshold?: SortOrder
    emergencyThreshold?: SortOrder
    autoRechargeEnabled?: SortOrder
    autoRechargeAmount?: SortOrderInput | SortOrder
    autoRechargeThreshold?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consumers?: consumersOrderByWithRelationInput
    prepaid_alerts?: prepaid_alertsOrderByRelationAggregateInput
    prepaid_recharges?: prepaid_rechargesOrderByRelationAggregateInput
    prepaid_transactions?: prepaid_transactionsOrderByRelationAggregateInput
  }

  export type prepaid_accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    consumerId?: number
    accountNumber?: string
    AND?: prepaid_accountsWhereInput | prepaid_accountsWhereInput[]
    OR?: prepaid_accountsWhereInput[]
    NOT?: prepaid_accountsWhereInput | prepaid_accountsWhereInput[]
    currentBalance?: FloatFilter<"prepaid_accounts"> | number
    totalRecharged?: FloatFilter<"prepaid_accounts"> | number
    totalConsumed?: FloatFilter<"prepaid_accounts"> | number
    isActive?: BoolFilter<"prepaid_accounts"> | boolean
    isBlocked?: BoolFilter<"prepaid_accounts"> | boolean
    blockReason?: StringNullableFilter<"prepaid_accounts"> | string | null
    blockedAt?: DateTimeNullableFilter<"prepaid_accounts"> | Date | string | null
    blockedBy?: IntNullableFilter<"prepaid_accounts"> | number | null
    lowBalanceThreshold?: FloatFilter<"prepaid_accounts"> | number
    emergencyThreshold?: FloatFilter<"prepaid_accounts"> | number
    autoRechargeEnabled?: BoolFilter<"prepaid_accounts"> | boolean
    autoRechargeAmount?: FloatNullableFilter<"prepaid_accounts"> | number | null
    autoRechargeThreshold?: FloatNullableFilter<"prepaid_accounts"> | number | null
    createdAt?: DateTimeFilter<"prepaid_accounts"> | Date | string
    updatedAt?: DateTimeFilter<"prepaid_accounts"> | Date | string
    consumers?: XOR<ConsumersRelationFilter, consumersWhereInput>
    prepaid_alerts?: Prepaid_alertsListRelationFilter
    prepaid_recharges?: Prepaid_rechargesListRelationFilter
    prepaid_transactions?: Prepaid_transactionsListRelationFilter
  }, "id" | "consumerId" | "accountNumber">

  export type prepaid_accountsOrderByWithAggregationInput = {
    id?: SortOrder
    consumerId?: SortOrder
    accountNumber?: SortOrder
    currentBalance?: SortOrder
    totalRecharged?: SortOrder
    totalConsumed?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    blockReason?: SortOrderInput | SortOrder
    blockedAt?: SortOrderInput | SortOrder
    blockedBy?: SortOrderInput | SortOrder
    lowBalanceThreshold?: SortOrder
    emergencyThreshold?: SortOrder
    autoRechargeEnabled?: SortOrder
    autoRechargeAmount?: SortOrderInput | SortOrder
    autoRechargeThreshold?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: prepaid_accountsCountOrderByAggregateInput
    _avg?: prepaid_accountsAvgOrderByAggregateInput
    _max?: prepaid_accountsMaxOrderByAggregateInput
    _min?: prepaid_accountsMinOrderByAggregateInput
    _sum?: prepaid_accountsSumOrderByAggregateInput
  }

  export type prepaid_accountsScalarWhereWithAggregatesInput = {
    AND?: prepaid_accountsScalarWhereWithAggregatesInput | prepaid_accountsScalarWhereWithAggregatesInput[]
    OR?: prepaid_accountsScalarWhereWithAggregatesInput[]
    NOT?: prepaid_accountsScalarWhereWithAggregatesInput | prepaid_accountsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"prepaid_accounts"> | number
    consumerId?: IntWithAggregatesFilter<"prepaid_accounts"> | number
    accountNumber?: StringWithAggregatesFilter<"prepaid_accounts"> | string
    currentBalance?: FloatWithAggregatesFilter<"prepaid_accounts"> | number
    totalRecharged?: FloatWithAggregatesFilter<"prepaid_accounts"> | number
    totalConsumed?: FloatWithAggregatesFilter<"prepaid_accounts"> | number
    isActive?: BoolWithAggregatesFilter<"prepaid_accounts"> | boolean
    isBlocked?: BoolWithAggregatesFilter<"prepaid_accounts"> | boolean
    blockReason?: StringNullableWithAggregatesFilter<"prepaid_accounts"> | string | null
    blockedAt?: DateTimeNullableWithAggregatesFilter<"prepaid_accounts"> | Date | string | null
    blockedBy?: IntNullableWithAggregatesFilter<"prepaid_accounts"> | number | null
    lowBalanceThreshold?: FloatWithAggregatesFilter<"prepaid_accounts"> | number
    emergencyThreshold?: FloatWithAggregatesFilter<"prepaid_accounts"> | number
    autoRechargeEnabled?: BoolWithAggregatesFilter<"prepaid_accounts"> | boolean
    autoRechargeAmount?: FloatNullableWithAggregatesFilter<"prepaid_accounts"> | number | null
    autoRechargeThreshold?: FloatNullableWithAggregatesFilter<"prepaid_accounts"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"prepaid_accounts"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"prepaid_accounts"> | Date | string
  }

  export type prepaid_alertsWhereInput = {
    AND?: prepaid_alertsWhereInput | prepaid_alertsWhereInput[]
    OR?: prepaid_alertsWhereInput[]
    NOT?: prepaid_alertsWhereInput | prepaid_alertsWhereInput[]
    id?: IntFilter<"prepaid_alerts"> | number
    accountId?: IntFilter<"prepaid_alerts"> | number
    alertType?: EnumPrepaidAlertTypeFilter<"prepaid_alerts"> | $Enums.PrepaidAlertType
    alertLevel?: EnumPrepaidAlertLevelFilter<"prepaid_alerts"> | $Enums.PrepaidAlertLevel
    message?: StringFilter<"prepaid_alerts"> | string
    isRead?: BoolFilter<"prepaid_alerts"> | boolean
    readAt?: DateTimeNullableFilter<"prepaid_alerts"> | Date | string | null
    balanceAtAlert?: FloatNullableFilter<"prepaid_alerts"> | number | null
    consumptionAtAlert?: FloatNullableFilter<"prepaid_alerts"> | number | null
    thresholdValue?: FloatNullableFilter<"prepaid_alerts"> | number | null
    createdAt?: DateTimeFilter<"prepaid_alerts"> | Date | string
    prepaid_accounts?: XOR<Prepaid_accountsRelationFilter, prepaid_accountsWhereInput>
  }

  export type prepaid_alertsOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    alertType?: SortOrder
    alertLevel?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    balanceAtAlert?: SortOrderInput | SortOrder
    consumptionAtAlert?: SortOrderInput | SortOrder
    thresholdValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    prepaid_accounts?: prepaid_accountsOrderByWithRelationInput
  }

  export type prepaid_alertsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: prepaid_alertsWhereInput | prepaid_alertsWhereInput[]
    OR?: prepaid_alertsWhereInput[]
    NOT?: prepaid_alertsWhereInput | prepaid_alertsWhereInput[]
    accountId?: IntFilter<"prepaid_alerts"> | number
    alertType?: EnumPrepaidAlertTypeFilter<"prepaid_alerts"> | $Enums.PrepaidAlertType
    alertLevel?: EnumPrepaidAlertLevelFilter<"prepaid_alerts"> | $Enums.PrepaidAlertLevel
    message?: StringFilter<"prepaid_alerts"> | string
    isRead?: BoolFilter<"prepaid_alerts"> | boolean
    readAt?: DateTimeNullableFilter<"prepaid_alerts"> | Date | string | null
    balanceAtAlert?: FloatNullableFilter<"prepaid_alerts"> | number | null
    consumptionAtAlert?: FloatNullableFilter<"prepaid_alerts"> | number | null
    thresholdValue?: FloatNullableFilter<"prepaid_alerts"> | number | null
    createdAt?: DateTimeFilter<"prepaid_alerts"> | Date | string
    prepaid_accounts?: XOR<Prepaid_accountsRelationFilter, prepaid_accountsWhereInput>
  }, "id">

  export type prepaid_alertsOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    alertType?: SortOrder
    alertLevel?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    balanceAtAlert?: SortOrderInput | SortOrder
    consumptionAtAlert?: SortOrderInput | SortOrder
    thresholdValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: prepaid_alertsCountOrderByAggregateInput
    _avg?: prepaid_alertsAvgOrderByAggregateInput
    _max?: prepaid_alertsMaxOrderByAggregateInput
    _min?: prepaid_alertsMinOrderByAggregateInput
    _sum?: prepaid_alertsSumOrderByAggregateInput
  }

  export type prepaid_alertsScalarWhereWithAggregatesInput = {
    AND?: prepaid_alertsScalarWhereWithAggregatesInput | prepaid_alertsScalarWhereWithAggregatesInput[]
    OR?: prepaid_alertsScalarWhereWithAggregatesInput[]
    NOT?: prepaid_alertsScalarWhereWithAggregatesInput | prepaid_alertsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"prepaid_alerts"> | number
    accountId?: IntWithAggregatesFilter<"prepaid_alerts"> | number
    alertType?: EnumPrepaidAlertTypeWithAggregatesFilter<"prepaid_alerts"> | $Enums.PrepaidAlertType
    alertLevel?: EnumPrepaidAlertLevelWithAggregatesFilter<"prepaid_alerts"> | $Enums.PrepaidAlertLevel
    message?: StringWithAggregatesFilter<"prepaid_alerts"> | string
    isRead?: BoolWithAggregatesFilter<"prepaid_alerts"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"prepaid_alerts"> | Date | string | null
    balanceAtAlert?: FloatNullableWithAggregatesFilter<"prepaid_alerts"> | number | null
    consumptionAtAlert?: FloatNullableWithAggregatesFilter<"prepaid_alerts"> | number | null
    thresholdValue?: FloatNullableWithAggregatesFilter<"prepaid_alerts"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"prepaid_alerts"> | Date | string
  }

  export type prepaid_rechargesWhereInput = {
    AND?: prepaid_rechargesWhereInput | prepaid_rechargesWhereInput[]
    OR?: prepaid_rechargesWhereInput[]
    NOT?: prepaid_rechargesWhereInput | prepaid_rechargesWhereInput[]
    id?: IntFilter<"prepaid_recharges"> | number
    accountId?: IntFilter<"prepaid_recharges"> | number
    rechargeId?: StringFilter<"prepaid_recharges"> | string
    amount?: FloatFilter<"prepaid_recharges"> | number
    paymentMethod?: EnumPaymentMethodFilter<"prepaid_recharges"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"prepaid_recharges"> | $Enums.PaymentStatus
    gatewayName?: StringNullableFilter<"prepaid_recharges"> | string | null
    gatewayTransactionId?: StringNullableFilter<"prepaid_recharges"> | string | null
    gatewayResponse?: JsonNullableFilter<"prepaid_recharges">
    rechargeType?: EnumPrepaidRechargeTypeFilter<"prepaid_recharges"> | $Enums.PrepaidRechargeType
    rechargeSource?: EnumPrepaidRechargeSourceFilter<"prepaid_recharges"> | $Enums.PrepaidRechargeSource
    isPromotional?: BoolFilter<"prepaid_recharges"> | boolean
    promotionalCode?: StringNullableFilter<"prepaid_recharges"> | string | null
    discountAmount?: FloatFilter<"prepaid_recharges"> | number
    bonusAmount?: FloatFilter<"prepaid_recharges"> | number
    receiptNumber?: StringNullableFilter<"prepaid_recharges"> | string | null
    receiptUrl?: StringNullableFilter<"prepaid_recharges"> | string | null
    createdAt?: DateTimeFilter<"prepaid_recharges"> | Date | string
    updatedAt?: DateTimeFilter<"prepaid_recharges"> | Date | string
    prepaid_accounts?: XOR<Prepaid_accountsRelationFilter, prepaid_accountsWhereInput>
  }

  export type prepaid_rechargesOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    rechargeId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    gatewayName?: SortOrderInput | SortOrder
    gatewayTransactionId?: SortOrderInput | SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    rechargeType?: SortOrder
    rechargeSource?: SortOrder
    isPromotional?: SortOrder
    promotionalCode?: SortOrderInput | SortOrder
    discountAmount?: SortOrder
    bonusAmount?: SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepaid_accounts?: prepaid_accountsOrderByWithRelationInput
  }

  export type prepaid_rechargesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    rechargeId?: string
    AND?: prepaid_rechargesWhereInput | prepaid_rechargesWhereInput[]
    OR?: prepaid_rechargesWhereInput[]
    NOT?: prepaid_rechargesWhereInput | prepaid_rechargesWhereInput[]
    accountId?: IntFilter<"prepaid_recharges"> | number
    amount?: FloatFilter<"prepaid_recharges"> | number
    paymentMethod?: EnumPaymentMethodFilter<"prepaid_recharges"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"prepaid_recharges"> | $Enums.PaymentStatus
    gatewayName?: StringNullableFilter<"prepaid_recharges"> | string | null
    gatewayTransactionId?: StringNullableFilter<"prepaid_recharges"> | string | null
    gatewayResponse?: JsonNullableFilter<"prepaid_recharges">
    rechargeType?: EnumPrepaidRechargeTypeFilter<"prepaid_recharges"> | $Enums.PrepaidRechargeType
    rechargeSource?: EnumPrepaidRechargeSourceFilter<"prepaid_recharges"> | $Enums.PrepaidRechargeSource
    isPromotional?: BoolFilter<"prepaid_recharges"> | boolean
    promotionalCode?: StringNullableFilter<"prepaid_recharges"> | string | null
    discountAmount?: FloatFilter<"prepaid_recharges"> | number
    bonusAmount?: FloatFilter<"prepaid_recharges"> | number
    receiptNumber?: StringNullableFilter<"prepaid_recharges"> | string | null
    receiptUrl?: StringNullableFilter<"prepaid_recharges"> | string | null
    createdAt?: DateTimeFilter<"prepaid_recharges"> | Date | string
    updatedAt?: DateTimeFilter<"prepaid_recharges"> | Date | string
    prepaid_accounts?: XOR<Prepaid_accountsRelationFilter, prepaid_accountsWhereInput>
  }, "id" | "rechargeId">

  export type prepaid_rechargesOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    rechargeId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    gatewayName?: SortOrderInput | SortOrder
    gatewayTransactionId?: SortOrderInput | SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    rechargeType?: SortOrder
    rechargeSource?: SortOrder
    isPromotional?: SortOrder
    promotionalCode?: SortOrderInput | SortOrder
    discountAmount?: SortOrder
    bonusAmount?: SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: prepaid_rechargesCountOrderByAggregateInput
    _avg?: prepaid_rechargesAvgOrderByAggregateInput
    _max?: prepaid_rechargesMaxOrderByAggregateInput
    _min?: prepaid_rechargesMinOrderByAggregateInput
    _sum?: prepaid_rechargesSumOrderByAggregateInput
  }

  export type prepaid_rechargesScalarWhereWithAggregatesInput = {
    AND?: prepaid_rechargesScalarWhereWithAggregatesInput | prepaid_rechargesScalarWhereWithAggregatesInput[]
    OR?: prepaid_rechargesScalarWhereWithAggregatesInput[]
    NOT?: prepaid_rechargesScalarWhereWithAggregatesInput | prepaid_rechargesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"prepaid_recharges"> | number
    accountId?: IntWithAggregatesFilter<"prepaid_recharges"> | number
    rechargeId?: StringWithAggregatesFilter<"prepaid_recharges"> | string
    amount?: FloatWithAggregatesFilter<"prepaid_recharges"> | number
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"prepaid_recharges"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"prepaid_recharges"> | $Enums.PaymentStatus
    gatewayName?: StringNullableWithAggregatesFilter<"prepaid_recharges"> | string | null
    gatewayTransactionId?: StringNullableWithAggregatesFilter<"prepaid_recharges"> | string | null
    gatewayResponse?: JsonNullableWithAggregatesFilter<"prepaid_recharges">
    rechargeType?: EnumPrepaidRechargeTypeWithAggregatesFilter<"prepaid_recharges"> | $Enums.PrepaidRechargeType
    rechargeSource?: EnumPrepaidRechargeSourceWithAggregatesFilter<"prepaid_recharges"> | $Enums.PrepaidRechargeSource
    isPromotional?: BoolWithAggregatesFilter<"prepaid_recharges"> | boolean
    promotionalCode?: StringNullableWithAggregatesFilter<"prepaid_recharges"> | string | null
    discountAmount?: FloatWithAggregatesFilter<"prepaid_recharges"> | number
    bonusAmount?: FloatWithAggregatesFilter<"prepaid_recharges"> | number
    receiptNumber?: StringNullableWithAggregatesFilter<"prepaid_recharges"> | string | null
    receiptUrl?: StringNullableWithAggregatesFilter<"prepaid_recharges"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"prepaid_recharges"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"prepaid_recharges"> | Date | string
  }

  export type prepaid_transactionsWhereInput = {
    AND?: prepaid_transactionsWhereInput | prepaid_transactionsWhereInput[]
    OR?: prepaid_transactionsWhereInput[]
    NOT?: prepaid_transactionsWhereInput | prepaid_transactionsWhereInput[]
    id?: IntFilter<"prepaid_transactions"> | number
    accountId?: IntFilter<"prepaid_transactions"> | number
    transactionId?: StringFilter<"prepaid_transactions"> | string
    transactionType?: EnumPrepaidTransactionTypeFilter<"prepaid_transactions"> | $Enums.PrepaidTransactionType
    amount?: FloatFilter<"prepaid_transactions"> | number
    balanceBefore?: FloatFilter<"prepaid_transactions"> | number
    balanceAfter?: FloatFilter<"prepaid_transactions"> | number
    consumptionKWh?: FloatNullableFilter<"prepaid_transactions"> | number | null
    ratePerUnit?: FloatNullableFilter<"prepaid_transactions"> | number | null
    fixedCharges?: FloatNullableFilter<"prepaid_transactions"> | number | null
    taxes?: JsonNullableFilter<"prepaid_transactions">
    readingId?: IntNullableFilter<"prepaid_transactions"> | number | null
    status?: EnumPrepaidTransactionStatusFilter<"prepaid_transactions"> | $Enums.PrepaidTransactionStatus
    failureReason?: StringNullableFilter<"prepaid_transactions"> | string | null
    description?: StringNullableFilter<"prepaid_transactions"> | string | null
    metadata?: JsonNullableFilter<"prepaid_transactions">
    createdAt?: DateTimeFilter<"prepaid_transactions"> | Date | string
    updatedAt?: DateTimeFilter<"prepaid_transactions"> | Date | string
    prepaid_accounts?: XOR<Prepaid_accountsRelationFilter, prepaid_accountsWhereInput>
    meter_readings?: XOR<Meter_readingsNullableRelationFilter, meter_readingsWhereInput> | null
  }

  export type prepaid_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    consumptionKWh?: SortOrderInput | SortOrder
    ratePerUnit?: SortOrderInput | SortOrder
    fixedCharges?: SortOrderInput | SortOrder
    taxes?: SortOrderInput | SortOrder
    readingId?: SortOrderInput | SortOrder
    status?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepaid_accounts?: prepaid_accountsOrderByWithRelationInput
    meter_readings?: meter_readingsOrderByWithRelationInput
  }

  export type prepaid_transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transactionId?: string
    AND?: prepaid_transactionsWhereInput | prepaid_transactionsWhereInput[]
    OR?: prepaid_transactionsWhereInput[]
    NOT?: prepaid_transactionsWhereInput | prepaid_transactionsWhereInput[]
    accountId?: IntFilter<"prepaid_transactions"> | number
    transactionType?: EnumPrepaidTransactionTypeFilter<"prepaid_transactions"> | $Enums.PrepaidTransactionType
    amount?: FloatFilter<"prepaid_transactions"> | number
    balanceBefore?: FloatFilter<"prepaid_transactions"> | number
    balanceAfter?: FloatFilter<"prepaid_transactions"> | number
    consumptionKWh?: FloatNullableFilter<"prepaid_transactions"> | number | null
    ratePerUnit?: FloatNullableFilter<"prepaid_transactions"> | number | null
    fixedCharges?: FloatNullableFilter<"prepaid_transactions"> | number | null
    taxes?: JsonNullableFilter<"prepaid_transactions">
    readingId?: IntNullableFilter<"prepaid_transactions"> | number | null
    status?: EnumPrepaidTransactionStatusFilter<"prepaid_transactions"> | $Enums.PrepaidTransactionStatus
    failureReason?: StringNullableFilter<"prepaid_transactions"> | string | null
    description?: StringNullableFilter<"prepaid_transactions"> | string | null
    metadata?: JsonNullableFilter<"prepaid_transactions">
    createdAt?: DateTimeFilter<"prepaid_transactions"> | Date | string
    updatedAt?: DateTimeFilter<"prepaid_transactions"> | Date | string
    prepaid_accounts?: XOR<Prepaid_accountsRelationFilter, prepaid_accountsWhereInput>
    meter_readings?: XOR<Meter_readingsNullableRelationFilter, meter_readingsWhereInput> | null
  }, "id" | "transactionId">

  export type prepaid_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    consumptionKWh?: SortOrderInput | SortOrder
    ratePerUnit?: SortOrderInput | SortOrder
    fixedCharges?: SortOrderInput | SortOrder
    taxes?: SortOrderInput | SortOrder
    readingId?: SortOrderInput | SortOrder
    status?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: prepaid_transactionsCountOrderByAggregateInput
    _avg?: prepaid_transactionsAvgOrderByAggregateInput
    _max?: prepaid_transactionsMaxOrderByAggregateInput
    _min?: prepaid_transactionsMinOrderByAggregateInput
    _sum?: prepaid_transactionsSumOrderByAggregateInput
  }

  export type prepaid_transactionsScalarWhereWithAggregatesInput = {
    AND?: prepaid_transactionsScalarWhereWithAggregatesInput | prepaid_transactionsScalarWhereWithAggregatesInput[]
    OR?: prepaid_transactionsScalarWhereWithAggregatesInput[]
    NOT?: prepaid_transactionsScalarWhereWithAggregatesInput | prepaid_transactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"prepaid_transactions"> | number
    accountId?: IntWithAggregatesFilter<"prepaid_transactions"> | number
    transactionId?: StringWithAggregatesFilter<"prepaid_transactions"> | string
    transactionType?: EnumPrepaidTransactionTypeWithAggregatesFilter<"prepaid_transactions"> | $Enums.PrepaidTransactionType
    amount?: FloatWithAggregatesFilter<"prepaid_transactions"> | number
    balanceBefore?: FloatWithAggregatesFilter<"prepaid_transactions"> | number
    balanceAfter?: FloatWithAggregatesFilter<"prepaid_transactions"> | number
    consumptionKWh?: FloatNullableWithAggregatesFilter<"prepaid_transactions"> | number | null
    ratePerUnit?: FloatNullableWithAggregatesFilter<"prepaid_transactions"> | number | null
    fixedCharges?: FloatNullableWithAggregatesFilter<"prepaid_transactions"> | number | null
    taxes?: JsonNullableWithAggregatesFilter<"prepaid_transactions">
    readingId?: IntNullableWithAggregatesFilter<"prepaid_transactions"> | number | null
    status?: EnumPrepaidTransactionStatusWithAggregatesFilter<"prepaid_transactions"> | $Enums.PrepaidTransactionStatus
    failureReason?: StringNullableWithAggregatesFilter<"prepaid_transactions"> | string | null
    description?: StringNullableWithAggregatesFilter<"prepaid_transactions"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"prepaid_transactions">
    createdAt?: DateTimeWithAggregatesFilter<"prepaid_transactions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"prepaid_transactions"> | Date | string
  }

  export type tamper_code_descWhereInput = {
    AND?: tamper_code_descWhereInput | tamper_code_descWhereInput[]
    OR?: tamper_code_descWhereInput[]
    NOT?: tamper_code_descWhereInput | tamper_code_descWhereInput[]
    id?: IntFilter<"tamper_code_desc"> | number
    tamperCode?: IntFilter<"tamper_code_desc"> | number
    tamperDesc?: StringFilter<"tamper_code_desc"> | string
    createdAt?: DateTimeFilter<"tamper_code_desc"> | Date | string
    updatedAt?: DateTimeFilter<"tamper_code_desc"> | Date | string
  }

  export type tamper_code_descOrderByWithRelationInput = {
    id?: SortOrder
    tamperCode?: SortOrder
    tamperDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tamper_code_descWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tamperCode?: number
    AND?: tamper_code_descWhereInput | tamper_code_descWhereInput[]
    OR?: tamper_code_descWhereInput[]
    NOT?: tamper_code_descWhereInput | tamper_code_descWhereInput[]
    tamperDesc?: StringFilter<"tamper_code_desc"> | string
    createdAt?: DateTimeFilter<"tamper_code_desc"> | Date | string
    updatedAt?: DateTimeFilter<"tamper_code_desc"> | Date | string
  }, "id" | "tamperCode">

  export type tamper_code_descOrderByWithAggregationInput = {
    id?: SortOrder
    tamperCode?: SortOrder
    tamperDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tamper_code_descCountOrderByAggregateInput
    _avg?: tamper_code_descAvgOrderByAggregateInput
    _max?: tamper_code_descMaxOrderByAggregateInput
    _min?: tamper_code_descMinOrderByAggregateInput
    _sum?: tamper_code_descSumOrderByAggregateInput
  }

  export type tamper_code_descScalarWhereWithAggregatesInput = {
    AND?: tamper_code_descScalarWhereWithAggregatesInput | tamper_code_descScalarWhereWithAggregatesInput[]
    OR?: tamper_code_descScalarWhereWithAggregatesInput[]
    NOT?: tamper_code_descScalarWhereWithAggregatesInput | tamper_code_descScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tamper_code_desc"> | number
    tamperCode?: IntWithAggregatesFilter<"tamper_code_desc"> | number
    tamperDesc?: StringWithAggregatesFilter<"tamper_code_desc"> | string
    createdAt?: DateTimeWithAggregatesFilter<"tamper_code_desc"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tamper_code_desc"> | Date | string
  }

  export type tamper_eventsWhereInput = {
    AND?: tamper_eventsWhereInput | tamper_eventsWhereInput[]
    OR?: tamper_eventsWhereInput[]
    NOT?: tamper_eventsWhereInput | tamper_eventsWhereInput[]
    id?: IntFilter<"tamper_events"> | number
    meterId?: IntFilter<"tamper_events"> | number
    tamperDatetime?: DateTimeFilter<"tamper_events"> | Date | string
    tamperType?: EnumTamperTypeFilter<"tamper_events"> | $Enums.TamperType
    tamperStatus?: EnumTamperStatusFilter<"tamper_events"> | $Enums.TamperStatus
    avgCurrent?: FloatNullableFilter<"tamper_events"> | number | null
    avgVoltage?: FloatNullableFilter<"tamper_events"> | number | null
    avgPowerFactor?: FloatNullableFilter<"tamper_events"> | number | null
    frequency?: FloatNullableFilter<"tamper_events"> | number | null
    kwh?: FloatNullableFilter<"tamper_events"> | number | null
    kwhExport?: FloatNullableFilter<"tamper_events"> | number | null
    kwhImport?: FloatNullableFilter<"tamper_events"> | number | null
    kwhNet?: FloatNullableFilter<"tamper_events"> | number | null
    kwhTotal?: FloatNullableFilter<"tamper_events"> | number | null
    kwExport?: FloatNullableFilter<"tamper_events"> | number | null
    kwImport?: FloatNullableFilter<"tamper_events"> | number | null
    kvaExport?: FloatNullableFilter<"tamper_events"> | number | null
    kvaImport?: FloatNullableFilter<"tamper_events"> | number | null
    voltageR?: FloatNullableFilter<"tamper_events"> | number | null
    voltageY?: FloatNullableFilter<"tamper_events"> | number | null
    voltageB?: FloatNullableFilter<"tamper_events"> | number | null
    currentR?: FloatNullableFilter<"tamper_events"> | number | null
    currentY?: FloatNullableFilter<"tamper_events"> | number | null
    currentB?: FloatNullableFilter<"tamper_events"> | number | null
    powerFactorR?: FloatNullableFilter<"tamper_events"> | number | null
    powerFactorY?: FloatNullableFilter<"tamper_events"> | number | null
    powerFactorB?: FloatNullableFilter<"tamper_events"> | number | null
    tamperCount?: IntNullableFilter<"tamper_events"> | number | null
    param1?: FloatNullableFilter<"tamper_events"> | number | null
    param2?: FloatNullableFilter<"tamper_events"> | number | null
    param3?: FloatNullableFilter<"tamper_events"> | number | null
    param4?: FloatNullableFilter<"tamper_events"> | number | null
    param5?: FloatNullableFilter<"tamper_events"> | number | null
    isProcessed?: BoolFilter<"tamper_events"> | boolean
    createdAt?: DateTimeFilter<"tamper_events"> | Date | string
    updatedAt?: DateTimeFilter<"tamper_events"> | Date | string
    meters?: XOR<MetersRelationFilter, metersWhereInput>
  }

  export type tamper_eventsOrderByWithRelationInput = {
    id?: SortOrder
    meterId?: SortOrder
    tamperDatetime?: SortOrder
    tamperType?: SortOrder
    tamperStatus?: SortOrder
    avgCurrent?: SortOrderInput | SortOrder
    avgVoltage?: SortOrderInput | SortOrder
    avgPowerFactor?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    kwh?: SortOrderInput | SortOrder
    kwhExport?: SortOrderInput | SortOrder
    kwhImport?: SortOrderInput | SortOrder
    kwhNet?: SortOrderInput | SortOrder
    kwhTotal?: SortOrderInput | SortOrder
    kwExport?: SortOrderInput | SortOrder
    kwImport?: SortOrderInput | SortOrder
    kvaExport?: SortOrderInput | SortOrder
    kvaImport?: SortOrderInput | SortOrder
    voltageR?: SortOrderInput | SortOrder
    voltageY?: SortOrderInput | SortOrder
    voltageB?: SortOrderInput | SortOrder
    currentR?: SortOrderInput | SortOrder
    currentY?: SortOrderInput | SortOrder
    currentB?: SortOrderInput | SortOrder
    powerFactorR?: SortOrderInput | SortOrder
    powerFactorY?: SortOrderInput | SortOrder
    powerFactorB?: SortOrderInput | SortOrder
    tamperCount?: SortOrderInput | SortOrder
    param1?: SortOrderInput | SortOrder
    param2?: SortOrderInput | SortOrder
    param3?: SortOrderInput | SortOrder
    param4?: SortOrderInput | SortOrder
    param5?: SortOrderInput | SortOrder
    isProcessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meters?: metersOrderByWithRelationInput
  }

  export type tamper_eventsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    meterId_tamperDatetime_tamperType_tamperStatus?: tamper_eventsMeterIdTamperDatetimeTamperTypeTamperStatusCompoundUniqueInput
    AND?: tamper_eventsWhereInput | tamper_eventsWhereInput[]
    OR?: tamper_eventsWhereInput[]
    NOT?: tamper_eventsWhereInput | tamper_eventsWhereInput[]
    meterId?: IntFilter<"tamper_events"> | number
    tamperDatetime?: DateTimeFilter<"tamper_events"> | Date | string
    tamperType?: EnumTamperTypeFilter<"tamper_events"> | $Enums.TamperType
    tamperStatus?: EnumTamperStatusFilter<"tamper_events"> | $Enums.TamperStatus
    avgCurrent?: FloatNullableFilter<"tamper_events"> | number | null
    avgVoltage?: FloatNullableFilter<"tamper_events"> | number | null
    avgPowerFactor?: FloatNullableFilter<"tamper_events"> | number | null
    frequency?: FloatNullableFilter<"tamper_events"> | number | null
    kwh?: FloatNullableFilter<"tamper_events"> | number | null
    kwhExport?: FloatNullableFilter<"tamper_events"> | number | null
    kwhImport?: FloatNullableFilter<"tamper_events"> | number | null
    kwhNet?: FloatNullableFilter<"tamper_events"> | number | null
    kwhTotal?: FloatNullableFilter<"tamper_events"> | number | null
    kwExport?: FloatNullableFilter<"tamper_events"> | number | null
    kwImport?: FloatNullableFilter<"tamper_events"> | number | null
    kvaExport?: FloatNullableFilter<"tamper_events"> | number | null
    kvaImport?: FloatNullableFilter<"tamper_events"> | number | null
    voltageR?: FloatNullableFilter<"tamper_events"> | number | null
    voltageY?: FloatNullableFilter<"tamper_events"> | number | null
    voltageB?: FloatNullableFilter<"tamper_events"> | number | null
    currentR?: FloatNullableFilter<"tamper_events"> | number | null
    currentY?: FloatNullableFilter<"tamper_events"> | number | null
    currentB?: FloatNullableFilter<"tamper_events"> | number | null
    powerFactorR?: FloatNullableFilter<"tamper_events"> | number | null
    powerFactorY?: FloatNullableFilter<"tamper_events"> | number | null
    powerFactorB?: FloatNullableFilter<"tamper_events"> | number | null
    tamperCount?: IntNullableFilter<"tamper_events"> | number | null
    param1?: FloatNullableFilter<"tamper_events"> | number | null
    param2?: FloatNullableFilter<"tamper_events"> | number | null
    param3?: FloatNullableFilter<"tamper_events"> | number | null
    param4?: FloatNullableFilter<"tamper_events"> | number | null
    param5?: FloatNullableFilter<"tamper_events"> | number | null
    isProcessed?: BoolFilter<"tamper_events"> | boolean
    createdAt?: DateTimeFilter<"tamper_events"> | Date | string
    updatedAt?: DateTimeFilter<"tamper_events"> | Date | string
    meters?: XOR<MetersRelationFilter, metersWhereInput>
  }, "id" | "meterId_tamperDatetime_tamperType_tamperStatus">

  export type tamper_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    meterId?: SortOrder
    tamperDatetime?: SortOrder
    tamperType?: SortOrder
    tamperStatus?: SortOrder
    avgCurrent?: SortOrderInput | SortOrder
    avgVoltage?: SortOrderInput | SortOrder
    avgPowerFactor?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    kwh?: SortOrderInput | SortOrder
    kwhExport?: SortOrderInput | SortOrder
    kwhImport?: SortOrderInput | SortOrder
    kwhNet?: SortOrderInput | SortOrder
    kwhTotal?: SortOrderInput | SortOrder
    kwExport?: SortOrderInput | SortOrder
    kwImport?: SortOrderInput | SortOrder
    kvaExport?: SortOrderInput | SortOrder
    kvaImport?: SortOrderInput | SortOrder
    voltageR?: SortOrderInput | SortOrder
    voltageY?: SortOrderInput | SortOrder
    voltageB?: SortOrderInput | SortOrder
    currentR?: SortOrderInput | SortOrder
    currentY?: SortOrderInput | SortOrder
    currentB?: SortOrderInput | SortOrder
    powerFactorR?: SortOrderInput | SortOrder
    powerFactorY?: SortOrderInput | SortOrder
    powerFactorB?: SortOrderInput | SortOrder
    tamperCount?: SortOrderInput | SortOrder
    param1?: SortOrderInput | SortOrder
    param2?: SortOrderInput | SortOrder
    param3?: SortOrderInput | SortOrder
    param4?: SortOrderInput | SortOrder
    param5?: SortOrderInput | SortOrder
    isProcessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tamper_eventsCountOrderByAggregateInput
    _avg?: tamper_eventsAvgOrderByAggregateInput
    _max?: tamper_eventsMaxOrderByAggregateInput
    _min?: tamper_eventsMinOrderByAggregateInput
    _sum?: tamper_eventsSumOrderByAggregateInput
  }

  export type tamper_eventsScalarWhereWithAggregatesInput = {
    AND?: tamper_eventsScalarWhereWithAggregatesInput | tamper_eventsScalarWhereWithAggregatesInput[]
    OR?: tamper_eventsScalarWhereWithAggregatesInput[]
    NOT?: tamper_eventsScalarWhereWithAggregatesInput | tamper_eventsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tamper_events"> | number
    meterId?: IntWithAggregatesFilter<"tamper_events"> | number
    tamperDatetime?: DateTimeWithAggregatesFilter<"tamper_events"> | Date | string
    tamperType?: EnumTamperTypeWithAggregatesFilter<"tamper_events"> | $Enums.TamperType
    tamperStatus?: EnumTamperStatusWithAggregatesFilter<"tamper_events"> | $Enums.TamperStatus
    avgCurrent?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    avgVoltage?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    avgPowerFactor?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    frequency?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    kwh?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    kwhExport?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    kwhImport?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    kwhNet?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    kwhTotal?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    kwExport?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    kwImport?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    kvaExport?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    kvaImport?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    voltageR?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    voltageY?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    voltageB?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    currentR?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    currentY?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    currentB?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    powerFactorR?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    powerFactorY?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    powerFactorB?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    tamperCount?: IntNullableWithAggregatesFilter<"tamper_events"> | number | null
    param1?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    param2?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    param3?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    param4?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    param5?: FloatNullableWithAggregatesFilter<"tamper_events"> | number | null
    isProcessed?: BoolWithAggregatesFilter<"tamper_events"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"tamper_events"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tamper_events"> | Date | string
  }

  export type tariffWhereInput = {
    AND?: tariffWhereInput | tariffWhereInput[]
    OR?: tariffWhereInput[]
    NOT?: tariffWhereInput | tariffWhereInput[]
    id?: IntFilter<"tariff"> | number
    client_id?: IntFilter<"tariff"> | number
    category?: IntFilter<"tariff"> | number
    tariff_name?: StringFilter<"tariff"> | string
    type?: StringFilter<"tariff"> | string
    device?: StringFilter<"tariff"> | string
    min_demand?: IntNullableFilter<"tariff"> | number | null
    min_demand_unit_rate?: FloatNullableFilter<"tariff"> | number | null
    min_demand_excess_unit_rate?: FloatNullableFilter<"tariff"> | number | null
    base_unit_rate?: FloatFilter<"tariff"> | number
    elec_duty_unit_rate?: FloatNullableFilter<"tariff"> | number | null
    ims?: FloatNullableFilter<"tariff"> | number | null
    gst?: FloatNullableFilter<"tariff"> | number | null
    valid_from?: DateTimeFilter<"tariff"> | Date | string
    valid_to?: DateTimeNullableFilter<"tariff"> | Date | string | null
    created_at?: DateTimeFilter<"tariff"> | Date | string
    updated_at?: DateTimeFilter<"tariff"> | Date | string
    tariff_slabs?: Tariff_slabsListRelationFilter
  }

  export type tariffOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrder
    category?: SortOrder
    tariff_name?: SortOrder
    type?: SortOrder
    device?: SortOrder
    min_demand?: SortOrderInput | SortOrder
    min_demand_unit_rate?: SortOrderInput | SortOrder
    min_demand_excess_unit_rate?: SortOrderInput | SortOrder
    base_unit_rate?: SortOrder
    elec_duty_unit_rate?: SortOrderInput | SortOrder
    ims?: SortOrderInput | SortOrder
    gst?: SortOrderInput | SortOrder
    valid_from?: SortOrder
    valid_to?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tariff_slabs?: tariff_slabsOrderByRelationAggregateInput
  }

  export type tariffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tariffWhereInput | tariffWhereInput[]
    OR?: tariffWhereInput[]
    NOT?: tariffWhereInput | tariffWhereInput[]
    client_id?: IntFilter<"tariff"> | number
    category?: IntFilter<"tariff"> | number
    tariff_name?: StringFilter<"tariff"> | string
    type?: StringFilter<"tariff"> | string
    device?: StringFilter<"tariff"> | string
    min_demand?: IntNullableFilter<"tariff"> | number | null
    min_demand_unit_rate?: FloatNullableFilter<"tariff"> | number | null
    min_demand_excess_unit_rate?: FloatNullableFilter<"tariff"> | number | null
    base_unit_rate?: FloatFilter<"tariff"> | number
    elec_duty_unit_rate?: FloatNullableFilter<"tariff"> | number | null
    ims?: FloatNullableFilter<"tariff"> | number | null
    gst?: FloatNullableFilter<"tariff"> | number | null
    valid_from?: DateTimeFilter<"tariff"> | Date | string
    valid_to?: DateTimeNullableFilter<"tariff"> | Date | string | null
    created_at?: DateTimeFilter<"tariff"> | Date | string
    updated_at?: DateTimeFilter<"tariff"> | Date | string
    tariff_slabs?: Tariff_slabsListRelationFilter
  }, "id">

  export type tariffOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrder
    category?: SortOrder
    tariff_name?: SortOrder
    type?: SortOrder
    device?: SortOrder
    min_demand?: SortOrderInput | SortOrder
    min_demand_unit_rate?: SortOrderInput | SortOrder
    min_demand_excess_unit_rate?: SortOrderInput | SortOrder
    base_unit_rate?: SortOrder
    elec_duty_unit_rate?: SortOrderInput | SortOrder
    ims?: SortOrderInput | SortOrder
    gst?: SortOrderInput | SortOrder
    valid_from?: SortOrder
    valid_to?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tariffCountOrderByAggregateInput
    _avg?: tariffAvgOrderByAggregateInput
    _max?: tariffMaxOrderByAggregateInput
    _min?: tariffMinOrderByAggregateInput
    _sum?: tariffSumOrderByAggregateInput
  }

  export type tariffScalarWhereWithAggregatesInput = {
    AND?: tariffScalarWhereWithAggregatesInput | tariffScalarWhereWithAggregatesInput[]
    OR?: tariffScalarWhereWithAggregatesInput[]
    NOT?: tariffScalarWhereWithAggregatesInput | tariffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tariff"> | number
    client_id?: IntWithAggregatesFilter<"tariff"> | number
    category?: IntWithAggregatesFilter<"tariff"> | number
    tariff_name?: StringWithAggregatesFilter<"tariff"> | string
    type?: StringWithAggregatesFilter<"tariff"> | string
    device?: StringWithAggregatesFilter<"tariff"> | string
    min_demand?: IntNullableWithAggregatesFilter<"tariff"> | number | null
    min_demand_unit_rate?: FloatNullableWithAggregatesFilter<"tariff"> | number | null
    min_demand_excess_unit_rate?: FloatNullableWithAggregatesFilter<"tariff"> | number | null
    base_unit_rate?: FloatWithAggregatesFilter<"tariff"> | number
    elec_duty_unit_rate?: FloatNullableWithAggregatesFilter<"tariff"> | number | null
    ims?: FloatNullableWithAggregatesFilter<"tariff"> | number | null
    gst?: FloatNullableWithAggregatesFilter<"tariff"> | number | null
    valid_from?: DateTimeWithAggregatesFilter<"tariff"> | Date | string
    valid_to?: DateTimeNullableWithAggregatesFilter<"tariff"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"tariff"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tariff"> | Date | string
  }

  export type tariff_slabsWhereInput = {
    AND?: tariff_slabsWhereInput | tariff_slabsWhereInput[]
    OR?: tariff_slabsWhereInput[]
    NOT?: tariff_slabsWhereInput | tariff_slabsWhereInput[]
    id?: IntFilter<"tariff_slabs"> | number
    tariff_id?: IntFilter<"tariff_slabs"> | number
    slab_order?: IntFilter<"tariff_slabs"> | number
    unit_limit?: IntFilter<"tariff_slabs"> | number
    unit_rate?: FloatFilter<"tariff_slabs"> | number
    created_at?: DateTimeFilter<"tariff_slabs"> | Date | string
    updated_at?: DateTimeFilter<"tariff_slabs"> | Date | string
    tariff?: XOR<TariffRelationFilter, tariffWhereInput>
  }

  export type tariff_slabsOrderByWithRelationInput = {
    id?: SortOrder
    tariff_id?: SortOrder
    slab_order?: SortOrder
    unit_limit?: SortOrder
    unit_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tariff?: tariffOrderByWithRelationInput
  }

  export type tariff_slabsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tariff_slabsWhereInput | tariff_slabsWhereInput[]
    OR?: tariff_slabsWhereInput[]
    NOT?: tariff_slabsWhereInput | tariff_slabsWhereInput[]
    tariff_id?: IntFilter<"tariff_slabs"> | number
    slab_order?: IntFilter<"tariff_slabs"> | number
    unit_limit?: IntFilter<"tariff_slabs"> | number
    unit_rate?: FloatFilter<"tariff_slabs"> | number
    created_at?: DateTimeFilter<"tariff_slabs"> | Date | string
    updated_at?: DateTimeFilter<"tariff_slabs"> | Date | string
    tariff?: XOR<TariffRelationFilter, tariffWhereInput>
  }, "id">

  export type tariff_slabsOrderByWithAggregationInput = {
    id?: SortOrder
    tariff_id?: SortOrder
    slab_order?: SortOrder
    unit_limit?: SortOrder
    unit_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tariff_slabsCountOrderByAggregateInput
    _avg?: tariff_slabsAvgOrderByAggregateInput
    _max?: tariff_slabsMaxOrderByAggregateInput
    _min?: tariff_slabsMinOrderByAggregateInput
    _sum?: tariff_slabsSumOrderByAggregateInput
  }

  export type tariff_slabsScalarWhereWithAggregatesInput = {
    AND?: tariff_slabsScalarWhereWithAggregatesInput | tariff_slabsScalarWhereWithAggregatesInput[]
    OR?: tariff_slabsScalarWhereWithAggregatesInput[]
    NOT?: tariff_slabsScalarWhereWithAggregatesInput | tariff_slabsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tariff_slabs"> | number
    tariff_id?: IntWithAggregatesFilter<"tariff_slabs"> | number
    slab_order?: IntWithAggregatesFilter<"tariff_slabs"> | number
    unit_limit?: IntWithAggregatesFilter<"tariff_slabs"> | number
    unit_rate?: FloatWithAggregatesFilter<"tariff_slabs"> | number
    created_at?: DateTimeWithAggregatesFilter<"tariff_slabs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tariff_slabs"> | Date | string
  }

  export type billsCreateInput = {
    billNumber: string
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
    consumers: consumersCreateNestedOneWithoutBillsInput
    meters: metersCreateNestedOneWithoutBillsInput
    meter_readings?: meter_readingsCreateNestedManyWithoutBillsInput
    payments?: paymentsCreateNestedManyWithoutBillsInput
  }

  export type billsUncheckedCreateInput = {
    id?: number
    billNumber: string
    meterId: number
    consumerId: number
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutBillsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBillsInput
  }

  export type billsUpdateInput = {
    billNumber?: StringFieldUpdateOperationsInput | string
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneRequiredWithoutBillsNestedInput
    meters?: metersUpdateOneRequiredWithoutBillsNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutBillsNestedInput
    payments?: paymentsUpdateManyWithoutBillsNestedInput
  }

  export type billsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNumber?: StringFieldUpdateOperationsInput | string
    meterId?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutBillsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBillsNestedInput
  }

  export type billsCreateManyInput = {
    id?: number
    billNumber: string
    meterId: number
    consumerId: number
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type billsUpdateManyMutationInput = {
    billNumber?: StringFieldUpdateOperationsInput | string
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNumber?: StringFieldUpdateOperationsInput | string
    meterId?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consumer_documentsCreateInput = {
    type: $Enums.DocumentType
    number: string
    fileUrl: string
    verificationStatus?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt: Date | string
    consumers: consumersCreateNestedOneWithoutConsumer_documentsInput
  }

  export type consumer_documentsUncheckedCreateInput = {
    id?: number
    consumerId: number
    type: $Enums.DocumentType
    number: string
    fileUrl: string
    verificationStatus?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type consumer_documentsUpdateInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneRequiredWithoutConsumer_documentsNestedInput
  }

  export type consumer_documentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consumer_documentsCreateManyInput = {
    id?: number
    consumerId: number
    type: $Enums.DocumentType
    number: string
    fileUrl: string
    verificationStatus?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type consumer_documentsUpdateManyMutationInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consumer_documentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consumersCreateInput = {
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutConsumersInput
    consumer_documents?: consumer_documentsCreateNestedManyWithoutConsumersInput
    locations: locationsCreateNestedOneWithoutConsumersInput
    notifications?: notificationsCreateNestedManyWithoutConsumersInput
    prepaid_accounts?: prepaid_accountsCreateNestedOneWithoutConsumersInput
  }

  export type consumersUncheckedCreateInput = {
    id?: number
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    locationId: number
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutConsumersInput
    consumer_documents?: consumer_documentsUncheckedCreateNestedManyWithoutConsumersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutConsumersInput
    prepaid_accounts?: prepaid_accountsUncheckedCreateNestedOneWithoutConsumersInput
  }

  export type consumersUpdateInput = {
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutConsumersNestedInput
    consumer_documents?: consumer_documentsUpdateManyWithoutConsumersNestedInput
    locations?: locationsUpdateOneRequiredWithoutConsumersNestedInput
    notifications?: notificationsUpdateManyWithoutConsumersNestedInput
    prepaid_accounts?: prepaid_accountsUpdateOneWithoutConsumersNestedInput
  }

  export type consumersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutConsumersNestedInput
    consumer_documents?: consumer_documentsUncheckedUpdateManyWithoutConsumersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutConsumersNestedInput
    prepaid_accounts?: prepaid_accountsUncheckedUpdateOneWithoutConsumersNestedInput
  }

  export type consumersCreateManyInput = {
    id?: number
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    locationId: number
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type consumersUpdateManyMutationInput = {
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consumersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type current_transformersCreateInput = {
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    meters: metersCreateNestedOneWithoutCurrent_transformersInput
  }

  export type current_transformersUncheckedCreateInput = {
    id?: number
    meterId: number
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type current_transformersUpdateInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: metersUpdateOneRequiredWithoutCurrent_transformersNestedInput
  }

  export type current_transformersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type current_transformersCreateManyInput = {
    id?: number
    meterId: number
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type current_transformersUpdateManyMutationInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type current_transformersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentsCreateInput = {
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    parent?: departmentsCreateNestedOneWithoutChildrenInput
    children?: departmentsCreateNestedManyWithoutParentInput
    users?: usersCreateNestedManyWithoutDepartmentsInput
  }

  export type departmentsUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    children?: departmentsUncheckedCreateNestedManyWithoutParentInput
    users?: usersUncheckedCreateNestedManyWithoutDepartmentsInput
  }

  export type departmentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: departmentsUpdateOneWithoutChildrenNestedInput
    children?: departmentsUpdateManyWithoutParentNestedInput
    users?: usersUpdateManyWithoutDepartmentsNestedInput
  }

  export type departmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: departmentsUncheckedUpdateManyWithoutParentNestedInput
    users?: usersUncheckedUpdateManyWithoutDepartmentsNestedInput
  }

  export type departmentsCreateManyInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type departmentsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_faultsCreateInput = {
    faultType: $Enums.FaultType
    severity: $Enums.FaultSeverity
    occuredAt: Date | string
    resolvedAt?: Date | string | null
    description: string
    rootCause?: string | null
    resolution?: string | null
    affectedMeters?: number | null
    outageMinutes?: number | null
    status?: $Enums.FaultStatus
    createdAt?: Date | string
    updatedAt: Date | string
    dtrs: dtrsCreateNestedOneWithoutDtr_faultsInput
  }

  export type dtr_faultsUncheckedCreateInput = {
    id?: number
    dtrId: number
    faultType: $Enums.FaultType
    severity: $Enums.FaultSeverity
    occuredAt: Date | string
    resolvedAt?: Date | string | null
    description: string
    rootCause?: string | null
    resolution?: string | null
    affectedMeters?: number | null
    outageMinutes?: number | null
    status?: $Enums.FaultStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_faultsUpdateInput = {
    faultType?: EnumFaultTypeFieldUpdateOperationsInput | $Enums.FaultType
    severity?: EnumFaultSeverityFieldUpdateOperationsInput | $Enums.FaultSeverity
    occuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedMeters?: NullableIntFieldUpdateOperationsInput | number | null
    outageMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFaultStatusFieldUpdateOperationsInput | $Enums.FaultStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtrs?: dtrsUpdateOneRequiredWithoutDtr_faultsNestedInput
  }

  export type dtr_faultsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrId?: IntFieldUpdateOperationsInput | number
    faultType?: EnumFaultTypeFieldUpdateOperationsInput | $Enums.FaultType
    severity?: EnumFaultSeverityFieldUpdateOperationsInput | $Enums.FaultSeverity
    occuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedMeters?: NullableIntFieldUpdateOperationsInput | number | null
    outageMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFaultStatusFieldUpdateOperationsInput | $Enums.FaultStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_faultsCreateManyInput = {
    id?: number
    dtrId: number
    faultType: $Enums.FaultType
    severity: $Enums.FaultSeverity
    occuredAt: Date | string
    resolvedAt?: Date | string | null
    description: string
    rootCause?: string | null
    resolution?: string | null
    affectedMeters?: number | null
    outageMinutes?: number | null
    status?: $Enums.FaultStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_faultsUpdateManyMutationInput = {
    faultType?: EnumFaultTypeFieldUpdateOperationsInput | $Enums.FaultType
    severity?: EnumFaultSeverityFieldUpdateOperationsInput | $Enums.FaultSeverity
    occuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedMeters?: NullableIntFieldUpdateOperationsInput | number | null
    outageMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFaultStatusFieldUpdateOperationsInput | $Enums.FaultStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_faultsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrId?: IntFieldUpdateOperationsInput | number
    faultType?: EnumFaultTypeFieldUpdateOperationsInput | $Enums.FaultType
    severity?: EnumFaultSeverityFieldUpdateOperationsInput | $Enums.FaultSeverity
    occuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedMeters?: NullableIntFieldUpdateOperationsInput | number | null
    outageMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFaultStatusFieldUpdateOperationsInput | $Enums.FaultStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_maintenanceCreateInput = {
    maintenanceType: $Enums.MaintenanceType
    scheduledDate: Date | string
    completedDate?: Date | string | null
    workDone: string
    findings?: string | null
    recommendations?: string | null
    oilDielectricTest?: number | null
    oilAcidityTest?: number | null
    moistureContent?: number | null
    performedBy: string
    verifiedBy?: string | null
    status?: $Enums.MaintenanceStatus
    createdAt?: Date | string
    updatedAt: Date | string
    dtrs: dtrsCreateNestedOneWithoutDtr_maintenanceInput
  }

  export type dtr_maintenanceUncheckedCreateInput = {
    id?: number
    dtrId: number
    maintenanceType: $Enums.MaintenanceType
    scheduledDate: Date | string
    completedDate?: Date | string | null
    workDone: string
    findings?: string | null
    recommendations?: string | null
    oilDielectricTest?: number | null
    oilAcidityTest?: number | null
    moistureContent?: number | null
    performedBy: string
    verifiedBy?: string | null
    status?: $Enums.MaintenanceStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_maintenanceUpdateInput = {
    maintenanceType?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workDone?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    oilDielectricTest?: NullableFloatFieldUpdateOperationsInput | number | null
    oilAcidityTest?: NullableFloatFieldUpdateOperationsInput | number | null
    moistureContent?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtrs?: dtrsUpdateOneRequiredWithoutDtr_maintenanceNestedInput
  }

  export type dtr_maintenanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrId?: IntFieldUpdateOperationsInput | number
    maintenanceType?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workDone?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    oilDielectricTest?: NullableFloatFieldUpdateOperationsInput | number | null
    oilAcidityTest?: NullableFloatFieldUpdateOperationsInput | number | null
    moistureContent?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_maintenanceCreateManyInput = {
    id?: number
    dtrId: number
    maintenanceType: $Enums.MaintenanceType
    scheduledDate: Date | string
    completedDate?: Date | string | null
    workDone: string
    findings?: string | null
    recommendations?: string | null
    oilDielectricTest?: number | null
    oilAcidityTest?: number | null
    moistureContent?: number | null
    performedBy: string
    verifiedBy?: string | null
    status?: $Enums.MaintenanceStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_maintenanceUpdateManyMutationInput = {
    maintenanceType?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workDone?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    oilDielectricTest?: NullableFloatFieldUpdateOperationsInput | number | null
    oilAcidityTest?: NullableFloatFieldUpdateOperationsInput | number | null
    moistureContent?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_maintenanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrId?: IntFieldUpdateOperationsInput | number
    maintenanceType?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workDone?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    oilDielectricTest?: NullableFloatFieldUpdateOperationsInput | number | null
    oilAcidityTest?: NullableFloatFieldUpdateOperationsInput | number | null
    moistureContent?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_readingsCreateInput = {
    readingDate: Date | string
    readingType: $Enums.DTRReadingType
    loadKVA: number
    loadPercentage: number
    primaryVoltage: JsonNullValueInput | InputJsonValue
    secondaryVoltage: JsonNullValueInput | InputJsonValue
    primaryCurrent: JsonNullValueInput | InputJsonValue
    secondaryCurrent: JsonNullValueInput | InputJsonValue
    powerFactor?: number | null
    oilTemperature?: number | null
    windingTemperature?: number | null
    ambientTemperature?: number | null
    frequency?: number | null
    voltageUnbalance?: number | null
    currentUnbalance?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtrs: dtrsCreateNestedOneWithoutDtr_readingsInput
  }

  export type dtr_readingsUncheckedCreateInput = {
    id?: number
    dtrId: number
    readingDate: Date | string
    readingType: $Enums.DTRReadingType
    loadKVA: number
    loadPercentage: number
    primaryVoltage: JsonNullValueInput | InputJsonValue
    secondaryVoltage: JsonNullValueInput | InputJsonValue
    primaryCurrent: JsonNullValueInput | InputJsonValue
    secondaryCurrent: JsonNullValueInput | InputJsonValue
    powerFactor?: number | null
    oilTemperature?: number | null
    windingTemperature?: number | null
    ambientTemperature?: number | null
    frequency?: number | null
    voltageUnbalance?: number | null
    currentUnbalance?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_readingsUpdateInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumDTRReadingTypeFieldUpdateOperationsInput | $Enums.DTRReadingType
    loadKVA?: FloatFieldUpdateOperationsInput | number
    loadPercentage?: FloatFieldUpdateOperationsInput | number
    primaryVoltage?: JsonNullValueInput | InputJsonValue
    secondaryVoltage?: JsonNullValueInput | InputJsonValue
    primaryCurrent?: JsonNullValueInput | InputJsonValue
    secondaryCurrent?: JsonNullValueInput | InputJsonValue
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    windingTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    currentUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtrs?: dtrsUpdateOneRequiredWithoutDtr_readingsNestedInput
  }

  export type dtr_readingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrId?: IntFieldUpdateOperationsInput | number
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumDTRReadingTypeFieldUpdateOperationsInput | $Enums.DTRReadingType
    loadKVA?: FloatFieldUpdateOperationsInput | number
    loadPercentage?: FloatFieldUpdateOperationsInput | number
    primaryVoltage?: JsonNullValueInput | InputJsonValue
    secondaryVoltage?: JsonNullValueInput | InputJsonValue
    primaryCurrent?: JsonNullValueInput | InputJsonValue
    secondaryCurrent?: JsonNullValueInput | InputJsonValue
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    windingTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    currentUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_readingsCreateManyInput = {
    id?: number
    dtrId: number
    readingDate: Date | string
    readingType: $Enums.DTRReadingType
    loadKVA: number
    loadPercentage: number
    primaryVoltage: JsonNullValueInput | InputJsonValue
    secondaryVoltage: JsonNullValueInput | InputJsonValue
    primaryCurrent: JsonNullValueInput | InputJsonValue
    secondaryCurrent: JsonNullValueInput | InputJsonValue
    powerFactor?: number | null
    oilTemperature?: number | null
    windingTemperature?: number | null
    ambientTemperature?: number | null
    frequency?: number | null
    voltageUnbalance?: number | null
    currentUnbalance?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_readingsUpdateManyMutationInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumDTRReadingTypeFieldUpdateOperationsInput | $Enums.DTRReadingType
    loadKVA?: FloatFieldUpdateOperationsInput | number
    loadPercentage?: FloatFieldUpdateOperationsInput | number
    primaryVoltage?: JsonNullValueInput | InputJsonValue
    secondaryVoltage?: JsonNullValueInput | InputJsonValue
    primaryCurrent?: JsonNullValueInput | InputJsonValue
    secondaryCurrent?: JsonNullValueInput | InputJsonValue
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    windingTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    currentUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_readingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrId?: IntFieldUpdateOperationsInput | number
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumDTRReadingTypeFieldUpdateOperationsInput | $Enums.DTRReadingType
    loadKVA?: FloatFieldUpdateOperationsInput | number
    loadPercentage?: FloatFieldUpdateOperationsInput | number
    primaryVoltage?: JsonNullValueInput | InputJsonValue
    secondaryVoltage?: JsonNullValueInput | InputJsonValue
    primaryCurrent?: JsonNullValueInput | InputJsonValue
    secondaryCurrent?: JsonNullValueInput | InputJsonValue
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    windingTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    currentUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtrsCreateInput = {
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsCreateNestedManyWithoutDtrsInput
    dtr_maintenance?: dtr_maintenanceCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsCreateNestedManyWithoutDtrsInput
    locations: locationsCreateNestedOneWithoutDtrsInput
    meters?: metersCreateNestedManyWithoutDtrsInput
    tickets?: ticketsCreateNestedManyWithoutDtrsInput
  }

  export type dtrsUncheckedCreateInput = {
    id?: number
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    locationId: number
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsUncheckedCreateNestedManyWithoutDtrsInput
    dtr_maintenance?: dtr_maintenanceUncheckedCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsUncheckedCreateNestedManyWithoutDtrsInput
    meters?: metersUncheckedCreateNestedManyWithoutDtrsInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutDtrsInput
  }

  export type dtrsUpdateInput = {
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUpdateManyWithoutDtrsNestedInput
    dtr_maintenance?: dtr_maintenanceUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUpdateManyWithoutDtrsNestedInput
    locations?: locationsUpdateOneRequiredWithoutDtrsNestedInput
    meters?: metersUpdateManyWithoutDtrsNestedInput
    tickets?: ticketsUpdateManyWithoutDtrsNestedInput
  }

  export type dtrsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    locationId?: IntFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUncheckedUpdateManyWithoutDtrsNestedInput
    dtr_maintenance?: dtr_maintenanceUncheckedUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUncheckedUpdateManyWithoutDtrsNestedInput
    meters?: metersUncheckedUpdateManyWithoutDtrsNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutDtrsNestedInput
  }

  export type dtrsCreateManyInput = {
    id?: number
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    locationId: number
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtrsUpdateManyMutationInput = {
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtrsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    locationId?: IntFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type location_typesCreateInput = {
    name: string
    level: number
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    locations?: locationsCreateNestedManyWithoutLocation_typesInput
  }

  export type location_typesUncheckedCreateInput = {
    id?: number
    name: string
    level: number
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    locations?: locationsUncheckedCreateNestedManyWithoutLocation_typesInput
  }

  export type location_typesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: locationsUpdateManyWithoutLocation_typesNestedInput
  }

  export type location_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: locationsUncheckedUpdateManyWithoutLocation_typesNestedInput
  }

  export type location_typesCreateManyInput = {
    id?: number
    name: string
    level: number
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type location_typesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type location_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationsCreateInput = {
    name: string
    code: string
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsCreateNestedManyWithoutLocationsInput
    location_types: location_typesCreateNestedOneWithoutLocationsInput
    locations?: locationsCreateNestedOneWithoutOther_locationsInput
    other_locations?: locationsCreateNestedManyWithoutLocationsInput
    meters?: metersCreateNestedManyWithoutLocationsInput
    users?: usersCreateNestedManyWithoutLocationsInput
  }

  export type locationsUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    locationTypeId: number
    parentId?: number | null
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersUncheckedCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsUncheckedCreateNestedManyWithoutLocationsInput
    other_locations?: locationsUncheckedCreateNestedManyWithoutLocationsInput
    meters?: metersUncheckedCreateNestedManyWithoutLocationsInput
    users?: usersUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type locationsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUpdateManyWithoutLocationsNestedInput
    location_types?: location_typesUpdateOneRequiredWithoutLocationsNestedInput
    locations?: locationsUpdateOneWithoutOther_locationsNestedInput
    other_locations?: locationsUpdateManyWithoutLocationsNestedInput
    meters?: metersUpdateManyWithoutLocationsNestedInput
    users?: usersUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationTypeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUncheckedUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUncheckedUpdateManyWithoutLocationsNestedInput
    other_locations?: locationsUncheckedUpdateManyWithoutLocationsNestedInput
    meters?: metersUncheckedUpdateManyWithoutLocationsNestedInput
    users?: usersUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type locationsCreateManyInput = {
    id?: number
    name: string
    code: string
    locationTypeId: number
    parentId?: number | null
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type locationsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationTypeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type login_historyCreateInput = {
    status: string
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutLogin_historyInput
  }

  export type login_historyUncheckedCreateInput = {
    id?: number
    userId: number
    status: string
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type login_historyUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutLogin_historyNestedInput
  }

  export type login_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type login_historyCreateManyInput = {
    id?: number
    userId: number
    status: string
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type login_historyUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type login_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_configurationsCreateInput = {
    ctRatio: string
    ctRatioPrimary: number
    ctRatioSecondary: number
    adoptedCTRatio?: string | null
    ctAccuracyClass?: string | null
    ctBurden?: number | null
    ptRatio: string
    ptRatioPrimary: number
    ptRatioSecondary: number
    adoptedPTRatio?: string | null
    ptAccuracyClass?: string | null
    ptBurden?: number | null
    mf: number
    vmf: number
    cmf: number
    createdAt?: Date | string
    updatedAt: Date | string
    meters: metersCreateNestedOneWithoutMeter_configurationsInput
  }

  export type meter_configurationsUncheckedCreateInput = {
    id?: number
    meterId: number
    ctRatio: string
    ctRatioPrimary: number
    ctRatioSecondary: number
    adoptedCTRatio?: string | null
    ctAccuracyClass?: string | null
    ctBurden?: number | null
    ptRatio: string
    ptRatioPrimary: number
    ptRatioSecondary: number
    adoptedPTRatio?: string | null
    ptAccuracyClass?: string | null
    ptBurden?: number | null
    mf: number
    vmf: number
    cmf: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type meter_configurationsUpdateInput = {
    ctRatio?: StringFieldUpdateOperationsInput | string
    ctRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ctRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedCTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ctAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ctBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    ptRatio?: StringFieldUpdateOperationsInput | string
    ptRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ptRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedPTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ptAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ptBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    mf?: FloatFieldUpdateOperationsInput | number
    vmf?: FloatFieldUpdateOperationsInput | number
    cmf?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: metersUpdateOneRequiredWithoutMeter_configurationsNestedInput
  }

  export type meter_configurationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    ctRatio?: StringFieldUpdateOperationsInput | string
    ctRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ctRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedCTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ctAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ctBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    ptRatio?: StringFieldUpdateOperationsInput | string
    ptRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ptRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedPTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ptAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ptBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    mf?: FloatFieldUpdateOperationsInput | number
    vmf?: FloatFieldUpdateOperationsInput | number
    cmf?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_configurationsCreateManyInput = {
    id?: number
    meterId: number
    ctRatio: string
    ctRatioPrimary: number
    ctRatioSecondary: number
    adoptedCTRatio?: string | null
    ctAccuracyClass?: string | null
    ctBurden?: number | null
    ptRatio: string
    ptRatioPrimary: number
    ptRatioSecondary: number
    adoptedPTRatio?: string | null
    ptAccuracyClass?: string | null
    ptBurden?: number | null
    mf: number
    vmf: number
    cmf: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type meter_configurationsUpdateManyMutationInput = {
    ctRatio?: StringFieldUpdateOperationsInput | string
    ctRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ctRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedCTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ctAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ctBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    ptRatio?: StringFieldUpdateOperationsInput | string
    ptRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ptRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedPTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ptAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ptBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    mf?: FloatFieldUpdateOperationsInput | number
    vmf?: FloatFieldUpdateOperationsInput | number
    cmf?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_configurationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    ctRatio?: StringFieldUpdateOperationsInput | string
    ctRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ctRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedCTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ctAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ctBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    ptRatio?: StringFieldUpdateOperationsInput | string
    ptRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ptRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedPTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ptAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ptBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    mf?: FloatFieldUpdateOperationsInput | number
    vmf?: FloatFieldUpdateOperationsInput | number
    cmf?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_readingsCreateInput = {
    readingDate: Date | string
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh?: number | null
    kVARh?: number | null
    powerFactor?: number | null
    averagePF?: number | null
    minimumPF?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    averageVoltage?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    averageCurrent?: number | null
    isValid?: boolean
    validatedBy?: string | null
    validatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    kVA?: number | null
    kW?: number | null
    bphPowerFactor?: number | null
    frequency?: number | null
    rphPowerFactor?: number | null
    yphPowerFactor?: number | null
    bills?: billsCreateNestedOneWithoutMeter_readingsInput
    meters: metersCreateNestedOneWithoutMeter_readingsInput
    prepaid_transactions?: prepaid_transactionsCreateNestedManyWithoutMeter_readingsInput
  }

  export type meter_readingsUncheckedCreateInput = {
    id?: number
    meterId: number
    readingDate: Date | string
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh?: number | null
    kVARh?: number | null
    powerFactor?: number | null
    averagePF?: number | null
    minimumPF?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    averageVoltage?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    averageCurrent?: number | null
    isValid?: boolean
    validatedBy?: string | null
    validatedAt?: Date | string | null
    billId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    kVA?: number | null
    kW?: number | null
    bphPowerFactor?: number | null
    frequency?: number | null
    rphPowerFactor?: number | null
    yphPowerFactor?: number | null
    prepaid_transactions?: prepaid_transactionsUncheckedCreateNestedManyWithoutMeter_readingsInput
  }

  export type meter_readingsUpdateInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    bills?: billsUpdateOneWithoutMeter_readingsNestedInput
    meters?: metersUpdateOneRequiredWithoutMeter_readingsNestedInput
    prepaid_transactions?: prepaid_transactionsUpdateManyWithoutMeter_readingsNestedInput
  }

  export type meter_readingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    prepaid_transactions?: prepaid_transactionsUncheckedUpdateManyWithoutMeter_readingsNestedInput
  }

  export type meter_readingsCreateManyInput = {
    id?: number
    meterId: number
    readingDate: Date | string
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh?: number | null
    kVARh?: number | null
    powerFactor?: number | null
    averagePF?: number | null
    minimumPF?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    averageVoltage?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    averageCurrent?: number | null
    isValid?: boolean
    validatedBy?: string | null
    validatedAt?: Date | string | null
    billId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    kVA?: number | null
    kW?: number | null
    bphPowerFactor?: number | null
    frequency?: number | null
    rphPowerFactor?: number | null
    yphPowerFactor?: number | null
  }

  export type meter_readingsUpdateManyMutationInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type meter_readingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type metersCreateInput = {
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsCreateNestedManyWithoutMetersInput
    dtrs?: dtrsCreateNestedOneWithoutMetersInput
    locations: locationsCreateNestedOneWithoutMetersInput
    potential_transformers?: potential_transformersCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsCreateNestedManyWithoutMetersInput
  }

  export type metersUncheckedCreateInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    locationId: number
    dtrId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersUncheckedCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsUncheckedCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutMetersInput
    potential_transformers?: potential_transformersUncheckedCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsUncheckedCreateNestedManyWithoutMetersInput
  }

  export type metersUpdateInput = {
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutMetersNestedInput
    dtrs?: dtrsUpdateOneWithoutMetersNestedInput
    locations?: locationsUpdateOneRequiredWithoutMetersNestedInput
    potential_transformers?: potential_transformersUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUpdateManyWithoutMetersNestedInput
  }

  export type metersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUncheckedUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUncheckedUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutMetersNestedInput
    potential_transformers?: potential_transformersUncheckedUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUncheckedUpdateManyWithoutMetersNestedInput
  }

  export type metersCreateManyInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    locationId: number
    dtrId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type metersUpdateManyMutationInput = {
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type metersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateInput = {
    type: $Enums.NotificationType
    title: string
    message: string
    priority: $Enums.NotificationPriority
    channels?: notificationsCreatechannelsInput | $Enums.NotificationChannel[]
    status?: $Enums.NotificationStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers: consumersCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    id?: number
    consumerId: number
    type: $Enums.NotificationType
    title: string
    message: string
    priority: $Enums.NotificationPriority
    channels?: notificationsCreatechannelsInput | $Enums.NotificationChannel[]
    status?: $Enums.NotificationStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notificationsUpdateInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    channels?: notificationsUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    channels?: notificationsUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateManyInput = {
    id?: number
    consumerId: number
    type: $Enums.NotificationType
    title: string
    message: string
    priority: $Enums.NotificationPriority
    channels?: notificationsCreatechannelsInput | $Enums.NotificationChannel[]
    status?: $Enums.NotificationStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notificationsUpdateManyMutationInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    channels?: notificationsUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    channels?: notificationsUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsCreateInput = {
    transactionId: string
    amount: number
    paymentMode: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills: billsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: number
    transactionId: string
    billId: number
    amount: number
    paymentMode: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type paymentsUpdateInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    billId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsCreateManyInput = {
    id?: number
    transactionId: string
    billId: number
    amount: number
    paymentMode: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type paymentsUpdateManyMutationInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    billId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionsCreateInput = {
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    user_permissions?: user_permissionsCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_permissions?: user_permissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsCreateManyInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type permissionsUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type potential_transformersCreateInput = {
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    meters: metersCreateNestedOneWithoutPotential_transformersInput
  }

  export type potential_transformersUncheckedCreateInput = {
    id?: number
    meterId: number
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type potential_transformersUpdateInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: metersUpdateOneRequiredWithoutPotential_transformersNestedInput
  }

  export type potential_transformersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type potential_transformersCreateManyInput = {
    id?: number
    meterId: number
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type potential_transformersUpdateManyMutationInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type potential_transformersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type role_permissionsCreateInput = {
    permissionId: JsonNullValueInput | InputJsonValue
    isGranted?: boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    roles: rolesCreateNestedOneWithoutRole_permissionsInput
  }

  export type role_permissionsUncheckedCreateInput = {
    id?: number
    roleId: number
    permissionId: JsonNullValueInput | InputJsonValue
    isGranted?: boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type role_permissionsUpdateInput = {
    permissionId?: JsonNullValueInput | InputJsonValue
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: rolesUpdateOneRequiredWithoutRole_permissionsNestedInput
  }

  export type role_permissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: JsonNullValueInput | InputJsonValue
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type role_permissionsCreateManyInput = {
    id?: number
    roleId: number
    permissionId: JsonNullValueInput | InputJsonValue
    isGranted?: boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type role_permissionsUpdateManyMutationInput = {
    permissionId?: JsonNullValueInput | InputJsonValue
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type role_permissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: JsonNullValueInput | InputJsonValue
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesCreateInput = {
    name: string
    description?: string | null
    level: number
    isSystem?: boolean
    isActive?: boolean
    accessLevel: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    role_permissions?: role_permissionsCreateNestedManyWithoutRolesInput
    users?: usersCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    level: number
    isSystem?: boolean
    isActive?: boolean
    accessLevel: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutRolesInput
    users?: usersUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role_permissions?: role_permissionsUpdateManyWithoutRolesNestedInput
    users?: usersUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutRolesNestedInput
    users?: usersUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    level: number
    isSystem?: boolean
    isActive?: boolean
    accessLevel: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type rolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsCreateInput = {
    ticketNumber: string
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_tickets_assignedToIdTousers?: usersCreateNestedOneWithoutTickets_tickets_assignedToIdTousersInput
    dtrs?: dtrsCreateNestedOneWithoutTicketsInput
    users_tickets_raisedByIdTousers: usersCreateNestedOneWithoutTickets_tickets_raisedByIdTousersInput
  }

  export type ticketsUncheckedCreateInput = {
    id?: number
    ticketNumber: string
    dtrId?: number | null
    raisedById: number
    assignedToId?: number | null
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ticketsUpdateInput = {
    ticketNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_tickets_assignedToIdTousers?: usersUpdateOneWithoutTickets_tickets_assignedToIdTousersNestedInput
    dtrs?: dtrsUpdateOneWithoutTicketsNestedInput
    users_tickets_raisedByIdTousers?: usersUpdateOneRequiredWithoutTickets_tickets_raisedByIdTousersNestedInput
  }

  export type ticketsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketNumber?: StringFieldUpdateOperationsInput | string
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    raisedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsCreateManyInput = {
    id?: number
    ticketNumber: string
    dtrId?: number | null
    raisedById: number
    assignedToId?: number | null
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ticketsUpdateManyMutationInput = {
    ticketNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketNumber?: StringFieldUpdateOperationsInput | string
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    raisedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_activity_logsCreateInput = {
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutUser_activity_logsInput
  }

  export type user_activity_logsUncheckedCreateInput = {
    id?: number
    userId: number
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type user_activity_logsUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_activity_logsNestedInput
  }

  export type user_activity_logsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_activity_logsCreateManyInput = {
    id?: number
    userId: number
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type user_activity_logsUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_activity_logsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_permissionsCreateInput = {
    isGranted?: boolean
    reason?: string | null
    validFrom?: Date | string
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    permissions: permissionsCreateNestedOneWithoutUser_permissionsInput
    users: usersCreateNestedOneWithoutUser_permissionsInput
  }

  export type user_permissionsUncheckedCreateInput = {
    id?: number
    userId: number
    permissionId: number
    isGranted?: boolean
    reason?: string | null
    validFrom?: Date | string
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_permissionsUpdateInput = {
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: permissionsUpdateOneRequiredWithoutUser_permissionsNestedInput
    users?: usersUpdateOneRequiredWithoutUser_permissionsNestedInput
  }

  export type user_permissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_permissionsCreateManyInput = {
    id?: number
    userId: number
    permissionId: number
    isGranted?: boolean
    reason?: string | null
    validFrom?: Date | string
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_permissionsUpdateManyMutationInput = {
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_permissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_sessionsCreateInput = {
    sessionToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    location?: string | null
    isActive?: boolean
    lastActivityAt?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutUser_sessionsInput
  }

  export type user_sessionsUncheckedCreateInput = {
    id?: number
    userId: number
    sessionToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    location?: string | null
    isActive?: boolean
    lastActivityAt?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_sessionsUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_sessionsNestedInput
  }

  export type user_sessionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_sessionsCreateManyInput = {
    id?: number
    userId: number
    sessionToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    location?: string | null
    isActive?: boolean
    lastActivityAt?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_sessionsUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_sessionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokensCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutRefresh_tokensInput
  }

  export type refresh_tokensUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type refresh_tokensUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutRefresh_tokensNestedInput
  }

  export type refresh_tokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokensCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type refresh_tokensUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedOneWithoutUsersInput
    departments?: departmentsCreateNestedOneWithoutUsersInput
    roles?: rolesCreateNestedOneWithoutUsersInput
    locations?: locationsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    roleId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyUncheckedCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsUncheckedCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsUncheckedCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateOneWithoutUsersNestedInput
    departments?: departmentsUpdateOneWithoutUsersNestedInput
    roles?: rolesUpdateOneWithoutUsersNestedInput
    locations?: locationsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUncheckedUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    roleId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
  }

  export type usersUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type raw_xml_importCreateInput = {
    doc: string
    imported_at?: Date | string | null
  }

  export type raw_xml_importUncheckedCreateInput = {
    id?: number
    doc: string
    imported_at?: Date | string | null
  }

  export type raw_xml_importUpdateInput = {
    doc?: StringFieldUpdateOperationsInput | string
    imported_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type raw_xml_importUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc?: StringFieldUpdateOperationsInput | string
    imported_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type raw_xml_importCreateManyInput = {
    id?: number
    doc: string
    imported_at?: Date | string | null
  }

  export type raw_xml_importUpdateManyMutationInput = {
    doc?: StringFieldUpdateOperationsInput | string
    imported_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type raw_xml_importUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc?: StringFieldUpdateOperationsInput | string
    imported_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prepaid_accountsCreateInput = {
    accountNumber: string
    currentBalance?: number
    totalRecharged?: number
    totalConsumed?: number
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: string | null
    blockedAt?: Date | string | null
    blockedBy?: number | null
    lowBalanceThreshold?: number
    emergencyThreshold?: number
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: number | null
    autoRechargeThreshold?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers: consumersCreateNestedOneWithoutPrepaid_accountsInput
    prepaid_alerts?: prepaid_alertsCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_recharges?: prepaid_rechargesCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_transactions?: prepaid_transactionsCreateNestedManyWithoutPrepaid_accountsInput
  }

  export type prepaid_accountsUncheckedCreateInput = {
    id?: number
    consumerId: number
    accountNumber: string
    currentBalance?: number
    totalRecharged?: number
    totalConsumed?: number
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: string | null
    blockedAt?: Date | string | null
    blockedBy?: number | null
    lowBalanceThreshold?: number
    emergencyThreshold?: number
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: number | null
    autoRechargeThreshold?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    prepaid_alerts?: prepaid_alertsUncheckedCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_recharges?: prepaid_rechargesUncheckedCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_transactions?: prepaid_transactionsUncheckedCreateNestedManyWithoutPrepaid_accountsInput
  }

  export type prepaid_accountsUpdateInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneRequiredWithoutPrepaid_accountsNestedInput
    prepaid_alerts?: prepaid_alertsUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_recharges?: prepaid_rechargesUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_transactions?: prepaid_transactionsUpdateManyWithoutPrepaid_accountsNestedInput
  }

  export type prepaid_accountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepaid_alerts?: prepaid_alertsUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_recharges?: prepaid_rechargesUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_transactions?: prepaid_transactionsUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
  }

  export type prepaid_accountsCreateManyInput = {
    id?: number
    consumerId: number
    accountNumber: string
    currentBalance?: number
    totalRecharged?: number
    totalConsumed?: number
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: string | null
    blockedAt?: Date | string | null
    blockedBy?: number | null
    lowBalanceThreshold?: number
    emergencyThreshold?: number
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: number | null
    autoRechargeThreshold?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_accountsUpdateManyMutationInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_accountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_alertsCreateInput = {
    alertType: $Enums.PrepaidAlertType
    alertLevel: $Enums.PrepaidAlertLevel
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    balanceAtAlert?: number | null
    consumptionAtAlert?: number | null
    thresholdValue?: number | null
    createdAt?: Date | string
    prepaid_accounts: prepaid_accountsCreateNestedOneWithoutPrepaid_alertsInput
  }

  export type prepaid_alertsUncheckedCreateInput = {
    id?: number
    accountId: number
    alertType: $Enums.PrepaidAlertType
    alertLevel: $Enums.PrepaidAlertLevel
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    balanceAtAlert?: number | null
    consumptionAtAlert?: number | null
    thresholdValue?: number | null
    createdAt?: Date | string
  }

  export type prepaid_alertsUpdateInput = {
    alertType?: EnumPrepaidAlertTypeFieldUpdateOperationsInput | $Enums.PrepaidAlertType
    alertLevel?: EnumPrepaidAlertLevelFieldUpdateOperationsInput | $Enums.PrepaidAlertLevel
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balanceAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    consumptionAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepaid_accounts?: prepaid_accountsUpdateOneRequiredWithoutPrepaid_alertsNestedInput
  }

  export type prepaid_alertsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    alertType?: EnumPrepaidAlertTypeFieldUpdateOperationsInput | $Enums.PrepaidAlertType
    alertLevel?: EnumPrepaidAlertLevelFieldUpdateOperationsInput | $Enums.PrepaidAlertLevel
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balanceAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    consumptionAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_alertsCreateManyInput = {
    id?: number
    accountId: number
    alertType: $Enums.PrepaidAlertType
    alertLevel: $Enums.PrepaidAlertLevel
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    balanceAtAlert?: number | null
    consumptionAtAlert?: number | null
    thresholdValue?: number | null
    createdAt?: Date | string
  }

  export type prepaid_alertsUpdateManyMutationInput = {
    alertType?: EnumPrepaidAlertTypeFieldUpdateOperationsInput | $Enums.PrepaidAlertType
    alertLevel?: EnumPrepaidAlertLevelFieldUpdateOperationsInput | $Enums.PrepaidAlertLevel
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balanceAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    consumptionAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_alertsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    alertType?: EnumPrepaidAlertTypeFieldUpdateOperationsInput | $Enums.PrepaidAlertType
    alertLevel?: EnumPrepaidAlertLevelFieldUpdateOperationsInput | $Enums.PrepaidAlertLevel
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balanceAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    consumptionAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_rechargesCreateInput = {
    rechargeId: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayName?: string | null
    gatewayTransactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: $Enums.PrepaidRechargeType
    rechargeSource?: $Enums.PrepaidRechargeSource
    isPromotional?: boolean
    promotionalCode?: string | null
    discountAmount?: number
    bonusAmount?: number
    receiptNumber?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    prepaid_accounts: prepaid_accountsCreateNestedOneWithoutPrepaid_rechargesInput
  }

  export type prepaid_rechargesUncheckedCreateInput = {
    id?: number
    accountId: number
    rechargeId: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayName?: string | null
    gatewayTransactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: $Enums.PrepaidRechargeType
    rechargeSource?: $Enums.PrepaidRechargeSource
    isPromotional?: boolean
    promotionalCode?: string | null
    discountAmount?: number
    bonusAmount?: number
    receiptNumber?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_rechargesUpdateInput = {
    rechargeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayName?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: EnumPrepaidRechargeTypeFieldUpdateOperationsInput | $Enums.PrepaidRechargeType
    rechargeSource?: EnumPrepaidRechargeSourceFieldUpdateOperationsInput | $Enums.PrepaidRechargeSource
    isPromotional?: BoolFieldUpdateOperationsInput | boolean
    promotionalCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: FloatFieldUpdateOperationsInput | number
    bonusAmount?: FloatFieldUpdateOperationsInput | number
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepaid_accounts?: prepaid_accountsUpdateOneRequiredWithoutPrepaid_rechargesNestedInput
  }

  export type prepaid_rechargesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    rechargeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayName?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: EnumPrepaidRechargeTypeFieldUpdateOperationsInput | $Enums.PrepaidRechargeType
    rechargeSource?: EnumPrepaidRechargeSourceFieldUpdateOperationsInput | $Enums.PrepaidRechargeSource
    isPromotional?: BoolFieldUpdateOperationsInput | boolean
    promotionalCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: FloatFieldUpdateOperationsInput | number
    bonusAmount?: FloatFieldUpdateOperationsInput | number
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_rechargesCreateManyInput = {
    id?: number
    accountId: number
    rechargeId: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayName?: string | null
    gatewayTransactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: $Enums.PrepaidRechargeType
    rechargeSource?: $Enums.PrepaidRechargeSource
    isPromotional?: boolean
    promotionalCode?: string | null
    discountAmount?: number
    bonusAmount?: number
    receiptNumber?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_rechargesUpdateManyMutationInput = {
    rechargeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayName?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: EnumPrepaidRechargeTypeFieldUpdateOperationsInput | $Enums.PrepaidRechargeType
    rechargeSource?: EnumPrepaidRechargeSourceFieldUpdateOperationsInput | $Enums.PrepaidRechargeSource
    isPromotional?: BoolFieldUpdateOperationsInput | boolean
    promotionalCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: FloatFieldUpdateOperationsInput | number
    bonusAmount?: FloatFieldUpdateOperationsInput | number
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_rechargesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    rechargeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayName?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: EnumPrepaidRechargeTypeFieldUpdateOperationsInput | $Enums.PrepaidRechargeType
    rechargeSource?: EnumPrepaidRechargeSourceFieldUpdateOperationsInput | $Enums.PrepaidRechargeSource
    isPromotional?: BoolFieldUpdateOperationsInput | boolean
    promotionalCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: FloatFieldUpdateOperationsInput | number
    bonusAmount?: FloatFieldUpdateOperationsInput | number
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_transactionsCreateInput = {
    transactionId: string
    transactionType: $Enums.PrepaidTransactionType
    amount: number
    balanceBefore: number
    balanceAfter: number
    consumptionKWh?: number | null
    ratePerUnit?: number | null
    fixedCharges?: number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.PrepaidTransactionStatus
    failureReason?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    prepaid_accounts: prepaid_accountsCreateNestedOneWithoutPrepaid_transactionsInput
    meter_readings?: meter_readingsCreateNestedOneWithoutPrepaid_transactionsInput
  }

  export type prepaid_transactionsUncheckedCreateInput = {
    id?: number
    accountId: number
    transactionId: string
    transactionType: $Enums.PrepaidTransactionType
    amount: number
    balanceBefore: number
    balanceAfter: number
    consumptionKWh?: number | null
    ratePerUnit?: number | null
    fixedCharges?: number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    readingId?: number | null
    status?: $Enums.PrepaidTransactionStatus
    failureReason?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_transactionsUpdateInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumPrepaidTransactionTypeFieldUpdateOperationsInput | $Enums.PrepaidTransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    consumptionKWh?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerUnit?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedCharges?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPrepaidTransactionStatusFieldUpdateOperationsInput | $Enums.PrepaidTransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepaid_accounts?: prepaid_accountsUpdateOneRequiredWithoutPrepaid_transactionsNestedInput
    meter_readings?: meter_readingsUpdateOneWithoutPrepaid_transactionsNestedInput
  }

  export type prepaid_transactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumPrepaidTransactionTypeFieldUpdateOperationsInput | $Enums.PrepaidTransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    consumptionKWh?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerUnit?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedCharges?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    readingId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPrepaidTransactionStatusFieldUpdateOperationsInput | $Enums.PrepaidTransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_transactionsCreateManyInput = {
    id?: number
    accountId: number
    transactionId: string
    transactionType: $Enums.PrepaidTransactionType
    amount: number
    balanceBefore: number
    balanceAfter: number
    consumptionKWh?: number | null
    ratePerUnit?: number | null
    fixedCharges?: number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    readingId?: number | null
    status?: $Enums.PrepaidTransactionStatus
    failureReason?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_transactionsUpdateManyMutationInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumPrepaidTransactionTypeFieldUpdateOperationsInput | $Enums.PrepaidTransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    consumptionKWh?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerUnit?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedCharges?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPrepaidTransactionStatusFieldUpdateOperationsInput | $Enums.PrepaidTransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_transactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumPrepaidTransactionTypeFieldUpdateOperationsInput | $Enums.PrepaidTransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    consumptionKWh?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerUnit?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedCharges?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    readingId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPrepaidTransactionStatusFieldUpdateOperationsInput | $Enums.PrepaidTransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tamper_code_descCreateInput = {
    tamperCode: number
    tamperDesc: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type tamper_code_descUncheckedCreateInput = {
    id?: number
    tamperCode: number
    tamperDesc: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type tamper_code_descUpdateInput = {
    tamperCode?: IntFieldUpdateOperationsInput | number
    tamperDesc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tamper_code_descUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tamperCode?: IntFieldUpdateOperationsInput | number
    tamperDesc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tamper_code_descCreateManyInput = {
    id?: number
    tamperCode: number
    tamperDesc: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type tamper_code_descUpdateManyMutationInput = {
    tamperCode?: IntFieldUpdateOperationsInput | number
    tamperDesc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tamper_code_descUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tamperCode?: IntFieldUpdateOperationsInput | number
    tamperDesc?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tamper_eventsCreateInput = {
    tamperDatetime?: Date | string
    tamperType: $Enums.TamperType
    tamperStatus: $Enums.TamperStatus
    avgCurrent?: number | null
    avgVoltage?: number | null
    avgPowerFactor?: number | null
    frequency?: number | null
    kwh?: number | null
    kwhExport?: number | null
    kwhImport?: number | null
    kwhNet?: number | null
    kwhTotal?: number | null
    kwExport?: number | null
    kwImport?: number | null
    kvaExport?: number | null
    kvaImport?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    powerFactorR?: number | null
    powerFactorY?: number | null
    powerFactorB?: number | null
    tamperCount?: number | null
    param1?: number | null
    param2?: number | null
    param3?: number | null
    param4?: number | null
    param5?: number | null
    isProcessed?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    meters: metersCreateNestedOneWithoutTamper_eventsInput
  }

  export type tamper_eventsUncheckedCreateInput = {
    id?: number
    meterId: number
    tamperDatetime?: Date | string
    tamperType: $Enums.TamperType
    tamperStatus: $Enums.TamperStatus
    avgCurrent?: number | null
    avgVoltage?: number | null
    avgPowerFactor?: number | null
    frequency?: number | null
    kwh?: number | null
    kwhExport?: number | null
    kwhImport?: number | null
    kwhNet?: number | null
    kwhTotal?: number | null
    kwExport?: number | null
    kwImport?: number | null
    kvaExport?: number | null
    kvaImport?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    powerFactorR?: number | null
    powerFactorY?: number | null
    powerFactorB?: number | null
    tamperCount?: number | null
    param1?: number | null
    param2?: number | null
    param3?: number | null
    param4?: number | null
    param5?: number | null
    isProcessed?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type tamper_eventsUpdateInput = {
    tamperDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    tamperType?: EnumTamperTypeFieldUpdateOperationsInput | $Enums.TamperType
    tamperStatus?: EnumTamperStatusFieldUpdateOperationsInput | $Enums.TamperStatus
    avgCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    avgVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    avgPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    kwh?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhNet?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    kwExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaImport?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorR?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorY?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorB?: NullableFloatFieldUpdateOperationsInput | number | null
    tamperCount?: NullableIntFieldUpdateOperationsInput | number | null
    param1?: NullableFloatFieldUpdateOperationsInput | number | null
    param2?: NullableFloatFieldUpdateOperationsInput | number | null
    param3?: NullableFloatFieldUpdateOperationsInput | number | null
    param4?: NullableFloatFieldUpdateOperationsInput | number | null
    param5?: NullableFloatFieldUpdateOperationsInput | number | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: metersUpdateOneRequiredWithoutTamper_eventsNestedInput
  }

  export type tamper_eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    tamperDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    tamperType?: EnumTamperTypeFieldUpdateOperationsInput | $Enums.TamperType
    tamperStatus?: EnumTamperStatusFieldUpdateOperationsInput | $Enums.TamperStatus
    avgCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    avgVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    avgPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    kwh?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhNet?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    kwExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaImport?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorR?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorY?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorB?: NullableFloatFieldUpdateOperationsInput | number | null
    tamperCount?: NullableIntFieldUpdateOperationsInput | number | null
    param1?: NullableFloatFieldUpdateOperationsInput | number | null
    param2?: NullableFloatFieldUpdateOperationsInput | number | null
    param3?: NullableFloatFieldUpdateOperationsInput | number | null
    param4?: NullableFloatFieldUpdateOperationsInput | number | null
    param5?: NullableFloatFieldUpdateOperationsInput | number | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tamper_eventsCreateManyInput = {
    id?: number
    meterId: number
    tamperDatetime?: Date | string
    tamperType: $Enums.TamperType
    tamperStatus: $Enums.TamperStatus
    avgCurrent?: number | null
    avgVoltage?: number | null
    avgPowerFactor?: number | null
    frequency?: number | null
    kwh?: number | null
    kwhExport?: number | null
    kwhImport?: number | null
    kwhNet?: number | null
    kwhTotal?: number | null
    kwExport?: number | null
    kwImport?: number | null
    kvaExport?: number | null
    kvaImport?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    powerFactorR?: number | null
    powerFactorY?: number | null
    powerFactorB?: number | null
    tamperCount?: number | null
    param1?: number | null
    param2?: number | null
    param3?: number | null
    param4?: number | null
    param5?: number | null
    isProcessed?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type tamper_eventsUpdateManyMutationInput = {
    tamperDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    tamperType?: EnumTamperTypeFieldUpdateOperationsInput | $Enums.TamperType
    tamperStatus?: EnumTamperStatusFieldUpdateOperationsInput | $Enums.TamperStatus
    avgCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    avgVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    avgPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    kwh?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhNet?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    kwExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaImport?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorR?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorY?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorB?: NullableFloatFieldUpdateOperationsInput | number | null
    tamperCount?: NullableIntFieldUpdateOperationsInput | number | null
    param1?: NullableFloatFieldUpdateOperationsInput | number | null
    param2?: NullableFloatFieldUpdateOperationsInput | number | null
    param3?: NullableFloatFieldUpdateOperationsInput | number | null
    param4?: NullableFloatFieldUpdateOperationsInput | number | null
    param5?: NullableFloatFieldUpdateOperationsInput | number | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tamper_eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    tamperDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    tamperType?: EnumTamperTypeFieldUpdateOperationsInput | $Enums.TamperType
    tamperStatus?: EnumTamperStatusFieldUpdateOperationsInput | $Enums.TamperStatus
    avgCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    avgVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    avgPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    kwh?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhNet?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    kwExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaImport?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorR?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorY?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorB?: NullableFloatFieldUpdateOperationsInput | number | null
    tamperCount?: NullableIntFieldUpdateOperationsInput | number | null
    param1?: NullableFloatFieldUpdateOperationsInput | number | null
    param2?: NullableFloatFieldUpdateOperationsInput | number | null
    param3?: NullableFloatFieldUpdateOperationsInput | number | null
    param4?: NullableFloatFieldUpdateOperationsInput | number | null
    param5?: NullableFloatFieldUpdateOperationsInput | number | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tariffCreateInput = {
    client_id: number
    category: number
    tariff_name: string
    type: string
    device: string
    min_demand?: number | null
    min_demand_unit_rate?: number | null
    min_demand_excess_unit_rate?: number | null
    base_unit_rate: number
    elec_duty_unit_rate?: number | null
    ims?: number | null
    gst?: number | null
    valid_from: Date | string
    valid_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    tariff_slabs?: tariff_slabsCreateNestedManyWithoutTariffInput
  }

  export type tariffUncheckedCreateInput = {
    id?: number
    client_id: number
    category: number
    tariff_name: string
    type: string
    device: string
    min_demand?: number | null
    min_demand_unit_rate?: number | null
    min_demand_excess_unit_rate?: number | null
    base_unit_rate: number
    elec_duty_unit_rate?: number | null
    ims?: number | null
    gst?: number | null
    valid_from: Date | string
    valid_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    tariff_slabs?: tariff_slabsUncheckedCreateNestedManyWithoutTariffInput
  }

  export type tariffUpdateInput = {
    client_id?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    tariff_name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    min_demand?: NullableIntFieldUpdateOperationsInput | number | null
    min_demand_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    min_demand_excess_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    base_unit_rate?: FloatFieldUpdateOperationsInput | number
    elec_duty_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    ims?: NullableFloatFieldUpdateOperationsInput | number | null
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tariff_slabs?: tariff_slabsUpdateManyWithoutTariffNestedInput
  }

  export type tariffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    tariff_name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    min_demand?: NullableIntFieldUpdateOperationsInput | number | null
    min_demand_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    min_demand_excess_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    base_unit_rate?: FloatFieldUpdateOperationsInput | number
    elec_duty_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    ims?: NullableFloatFieldUpdateOperationsInput | number | null
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tariff_slabs?: tariff_slabsUncheckedUpdateManyWithoutTariffNestedInput
  }

  export type tariffCreateManyInput = {
    id?: number
    client_id: number
    category: number
    tariff_name: string
    type: string
    device: string
    min_demand?: number | null
    min_demand_unit_rate?: number | null
    min_demand_excess_unit_rate?: number | null
    base_unit_rate: number
    elec_duty_unit_rate?: number | null
    ims?: number | null
    gst?: number | null
    valid_from: Date | string
    valid_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tariffUpdateManyMutationInput = {
    client_id?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    tariff_name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    min_demand?: NullableIntFieldUpdateOperationsInput | number | null
    min_demand_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    min_demand_excess_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    base_unit_rate?: FloatFieldUpdateOperationsInput | number
    elec_duty_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    ims?: NullableFloatFieldUpdateOperationsInput | number | null
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tariffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    tariff_name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    min_demand?: NullableIntFieldUpdateOperationsInput | number | null
    min_demand_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    min_demand_excess_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    base_unit_rate?: FloatFieldUpdateOperationsInput | number
    elec_duty_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    ims?: NullableFloatFieldUpdateOperationsInput | number | null
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tariff_slabsCreateInput = {
    slab_order: number
    unit_limit: number
    unit_rate: number
    created_at?: Date | string
    updated_at?: Date | string
    tariff: tariffCreateNestedOneWithoutTariff_slabsInput
  }

  export type tariff_slabsUncheckedCreateInput = {
    id?: number
    tariff_id: number
    slab_order: number
    unit_limit: number
    unit_rate: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tariff_slabsUpdateInput = {
    slab_order?: IntFieldUpdateOperationsInput | number
    unit_limit?: IntFieldUpdateOperationsInput | number
    unit_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tariff?: tariffUpdateOneRequiredWithoutTariff_slabsNestedInput
  }

  export type tariff_slabsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tariff_id?: IntFieldUpdateOperationsInput | number
    slab_order?: IntFieldUpdateOperationsInput | number
    unit_limit?: IntFieldUpdateOperationsInput | number
    unit_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tariff_slabsCreateManyInput = {
    id?: number
    tariff_id: number
    slab_order: number
    unit_limit: number
    unit_rate: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tariff_slabsUpdateManyMutationInput = {
    slab_order?: IntFieldUpdateOperationsInput | number
    unit_limit?: IntFieldUpdateOperationsInput | number
    unit_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tariff_slabsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tariff_id?: IntFieldUpdateOperationsInput | number
    slab_order?: IntFieldUpdateOperationsInput | number
    unit_limit?: IntFieldUpdateOperationsInput | number
    unit_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumBillStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusFilter<$PrismaModel> | $Enums.BillStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ConsumersRelationFilter = {
    is?: consumersWhereInput
    isNot?: consumersWhereInput
  }

  export type MetersRelationFilter = {
    is?: metersWhereInput
    isNot?: metersWhereInput
  }

  export type Meter_readingsListRelationFilter = {
    every?: meter_readingsWhereInput
    some?: meter_readingsWhereInput
    none?: meter_readingsWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type meter_readingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type billsCountOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    meterId?: SortOrder
    consumerId?: SortOrder
    billMonth?: SortOrder
    billYear?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    dueDate?: SortOrder
    previousReading?: SortOrder
    currentReading?: SortOrder
    unitsConsumed?: SortOrder
    fixedCharge?: SortOrder
    energyCharge?: SortOrder
    powerFactorCharge?: SortOrder
    otherCharges?: SortOrder
    subTotal?: SortOrder
    taxes?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    isPaid?: SortOrder
    paidAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type billsAvgOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    consumerId?: SortOrder
    billMonth?: SortOrder
    billYear?: SortOrder
    previousReading?: SortOrder
    currentReading?: SortOrder
    unitsConsumed?: SortOrder
    fixedCharge?: SortOrder
    energyCharge?: SortOrder
    powerFactorCharge?: SortOrder
    subTotal?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type billsMaxOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    meterId?: SortOrder
    consumerId?: SortOrder
    billMonth?: SortOrder
    billYear?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    dueDate?: SortOrder
    previousReading?: SortOrder
    currentReading?: SortOrder
    unitsConsumed?: SortOrder
    fixedCharge?: SortOrder
    energyCharge?: SortOrder
    powerFactorCharge?: SortOrder
    subTotal?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    isPaid?: SortOrder
    paidAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type billsMinOrderByAggregateInput = {
    id?: SortOrder
    billNumber?: SortOrder
    meterId?: SortOrder
    consumerId?: SortOrder
    billMonth?: SortOrder
    billYear?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    dueDate?: SortOrder
    previousReading?: SortOrder
    currentReading?: SortOrder
    unitsConsumed?: SortOrder
    fixedCharge?: SortOrder
    energyCharge?: SortOrder
    powerFactorCharge?: SortOrder
    subTotal?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    isPaid?: SortOrder
    paidAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type billsSumOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    consumerId?: SortOrder
    billMonth?: SortOrder
    billYear?: SortOrder
    previousReading?: SortOrder
    currentReading?: SortOrder
    unitsConsumed?: SortOrder
    fixedCharge?: SortOrder
    energyCharge?: SortOrder
    powerFactorCharge?: SortOrder
    subTotal?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumBillStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillStatusFilter<$PrismaModel>
    _max?: NestedEnumBillStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type consumer_documentsCountOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
    type?: SortOrder
    number?: SortOrder
    fileUrl?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consumer_documentsAvgOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
  }

  export type consumer_documentsMaxOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
    type?: SortOrder
    number?: SortOrder
    fileUrl?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consumer_documentsMinOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
    type?: SortOrder
    number?: SortOrder
    fileUrl?: SortOrder
    verificationStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consumer_documentsSumOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumIdTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IdType | EnumIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdType[] | ListEnumIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdType[] | ListEnumIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdTypeFilter<$PrismaModel> | $Enums.IdType
  }

  export type EnumConnectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionTypeFilter<$PrismaModel> | $Enums.ConnectionType
  }

  export type EnumConsumerCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsumerCategory | EnumConsumerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ConsumerCategory[] | ListEnumConsumerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsumerCategory[] | ListEnumConsumerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumConsumerCategoryFilter<$PrismaModel> | $Enums.ConsumerCategory
  }

  export type EnumBillingCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleFilter<$PrismaModel> | $Enums.BillingCycle
  }

  export type EnumBillDeliveryModeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.BillDeliveryMode[] | ListEnumBillDeliveryModeFieldRefInput<$PrismaModel> | null
    has?: $Enums.BillDeliveryMode | EnumBillDeliveryModeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.BillDeliveryMode[] | ListEnumBillDeliveryModeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.BillDeliveryMode[] | ListEnumBillDeliveryModeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BillsListRelationFilter = {
    every?: billsWhereInput
    some?: billsWhereInput
    none?: billsWhereInput
  }

  export type Consumer_documentsListRelationFilter = {
    every?: consumer_documentsWhereInput
    some?: consumer_documentsWhereInput
    none?: consumer_documentsWhereInput
  }

  export type LocationsRelationFilter = {
    is?: locationsWhereInput
    isNot?: locationsWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type Prepaid_accountsNullableRelationFilter = {
    is?: prepaid_accountsWhereInput | null
    isNot?: prepaid_accountsWhereInput | null
  }

  export type billsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type consumer_documentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type consumersCountOrderByAggregateInput = {
    id?: SortOrder
    consumerNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    primaryPhone?: SortOrder
    alternatePhone?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    connectionType?: SortOrder
    category?: SortOrder
    sanctionedLoad?: SortOrder
    connectionDate?: SortOrder
    locationId?: SortOrder
    billingCycle?: SortOrder
    billDeliveryMode?: SortOrder
    defaultPaymentMethod?: SortOrder
    creditScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consumersAvgOrderByAggregateInput = {
    id?: SortOrder
    sanctionedLoad?: SortOrder
    locationId?: SortOrder
    creditScore?: SortOrder
  }

  export type consumersMaxOrderByAggregateInput = {
    id?: SortOrder
    consumerNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    primaryPhone?: SortOrder
    alternatePhone?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    connectionType?: SortOrder
    category?: SortOrder
    sanctionedLoad?: SortOrder
    connectionDate?: SortOrder
    locationId?: SortOrder
    billingCycle?: SortOrder
    defaultPaymentMethod?: SortOrder
    creditScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consumersMinOrderByAggregateInput = {
    id?: SortOrder
    consumerNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    primaryPhone?: SortOrder
    alternatePhone?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    connectionType?: SortOrder
    category?: SortOrder
    sanctionedLoad?: SortOrder
    connectionDate?: SortOrder
    locationId?: SortOrder
    billingCycle?: SortOrder
    defaultPaymentMethod?: SortOrder
    creditScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consumersSumOrderByAggregateInput = {
    id?: SortOrder
    sanctionedLoad?: SortOrder
    locationId?: SortOrder
    creditScore?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumIdTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdType | EnumIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdType[] | ListEnumIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdType[] | ListEnumIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdTypeWithAggregatesFilter<$PrismaModel> | $Enums.IdType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdTypeFilter<$PrismaModel>
    _max?: NestedEnumIdTypeFilter<$PrismaModel>
  }

  export type EnumConnectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConnectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConnectionTypeFilter<$PrismaModel>
    _max?: NestedEnumConnectionTypeFilter<$PrismaModel>
  }

  export type EnumConsumerCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsumerCategory | EnumConsumerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ConsumerCategory[] | ListEnumConsumerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsumerCategory[] | ListEnumConsumerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumConsumerCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ConsumerCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsumerCategoryFilter<$PrismaModel>
    _max?: NestedEnumConsumerCategoryFilter<$PrismaModel>
  }

  export type EnumBillingCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel> | $Enums.BillingCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingCycleFilter<$PrismaModel>
    _max?: NestedEnumBillingCycleFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type current_transformersCountOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    accuracyClass?: SortOrder
    burden?: SortOrder
    installationDate?: SortOrder
    lastTestedDate?: SortOrder
    nextTestDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type current_transformersAvgOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    burden?: SortOrder
  }

  export type current_transformersMaxOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    accuracyClass?: SortOrder
    burden?: SortOrder
    installationDate?: SortOrder
    lastTestedDate?: SortOrder
    nextTestDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type current_transformersMinOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    accuracyClass?: SortOrder
    burden?: SortOrder
    installationDate?: SortOrder
    lastTestedDate?: SortOrder
    nextTestDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type current_transformersSumOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    burden?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DepartmentsNullableRelationFilter = {
    is?: departmentsWhereInput | null
    isNot?: departmentsWhereInput | null
  }

  export type DepartmentsListRelationFilter = {
    every?: departmentsWhereInput
    some?: departmentsWhereInput
    none?: departmentsWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type departmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type departmentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type departmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type departmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type departmentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type departmentsSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type EnumFaultTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultType | EnumFaultTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FaultType[] | ListEnumFaultTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultType[] | ListEnumFaultTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultTypeFilter<$PrismaModel> | $Enums.FaultType
  }

  export type EnumFaultSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultSeverity | EnumFaultSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.FaultSeverity[] | ListEnumFaultSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultSeverity[] | ListEnumFaultSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultSeverityFilter<$PrismaModel> | $Enums.FaultSeverity
  }

  export type EnumFaultStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultStatus | EnumFaultStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FaultStatus[] | ListEnumFaultStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultStatus[] | ListEnumFaultStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultStatusFilter<$PrismaModel> | $Enums.FaultStatus
  }

  export type DtrsRelationFilter = {
    is?: dtrsWhereInput
    isNot?: dtrsWhereInput
  }

  export type dtr_faultsCountOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    faultType?: SortOrder
    severity?: SortOrder
    occuredAt?: SortOrder
    resolvedAt?: SortOrder
    description?: SortOrder
    rootCause?: SortOrder
    resolution?: SortOrder
    affectedMeters?: SortOrder
    outageMinutes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtr_faultsAvgOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    affectedMeters?: SortOrder
    outageMinutes?: SortOrder
  }

  export type dtr_faultsMaxOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    faultType?: SortOrder
    severity?: SortOrder
    occuredAt?: SortOrder
    resolvedAt?: SortOrder
    description?: SortOrder
    rootCause?: SortOrder
    resolution?: SortOrder
    affectedMeters?: SortOrder
    outageMinutes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtr_faultsMinOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    faultType?: SortOrder
    severity?: SortOrder
    occuredAt?: SortOrder
    resolvedAt?: SortOrder
    description?: SortOrder
    rootCause?: SortOrder
    resolution?: SortOrder
    affectedMeters?: SortOrder
    outageMinutes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtr_faultsSumOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    affectedMeters?: SortOrder
    outageMinutes?: SortOrder
  }

  export type EnumFaultTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultType | EnumFaultTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FaultType[] | ListEnumFaultTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultType[] | ListEnumFaultTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultTypeWithAggregatesFilter<$PrismaModel> | $Enums.FaultType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFaultTypeFilter<$PrismaModel>
    _max?: NestedEnumFaultTypeFilter<$PrismaModel>
  }

  export type EnumFaultSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultSeverity | EnumFaultSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.FaultSeverity[] | ListEnumFaultSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultSeverity[] | ListEnumFaultSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultSeverityWithAggregatesFilter<$PrismaModel> | $Enums.FaultSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFaultSeverityFilter<$PrismaModel>
    _max?: NestedEnumFaultSeverityFilter<$PrismaModel>
  }

  export type EnumFaultStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultStatus | EnumFaultStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FaultStatus[] | ListEnumFaultStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultStatus[] | ListEnumFaultStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultStatusWithAggregatesFilter<$PrismaModel> | $Enums.FaultStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFaultStatusFilter<$PrismaModel>
    _max?: NestedEnumFaultStatusFilter<$PrismaModel>
  }

  export type EnumMaintenanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeFilter<$PrismaModel> | $Enums.MaintenanceType
  }

  export type EnumMaintenanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusFilter<$PrismaModel> | $Enums.MaintenanceStatus
  }

  export type dtr_maintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    maintenanceType?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    workDone?: SortOrder
    findings?: SortOrder
    recommendations?: SortOrder
    oilDielectricTest?: SortOrder
    oilAcidityTest?: SortOrder
    moistureContent?: SortOrder
    performedBy?: SortOrder
    verifiedBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtr_maintenanceAvgOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    oilDielectricTest?: SortOrder
    oilAcidityTest?: SortOrder
    moistureContent?: SortOrder
  }

  export type dtr_maintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    maintenanceType?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    workDone?: SortOrder
    findings?: SortOrder
    recommendations?: SortOrder
    oilDielectricTest?: SortOrder
    oilAcidityTest?: SortOrder
    moistureContent?: SortOrder
    performedBy?: SortOrder
    verifiedBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtr_maintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    maintenanceType?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    workDone?: SortOrder
    findings?: SortOrder
    recommendations?: SortOrder
    oilDielectricTest?: SortOrder
    oilAcidityTest?: SortOrder
    moistureContent?: SortOrder
    performedBy?: SortOrder
    verifiedBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtr_maintenanceSumOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    oilDielectricTest?: SortOrder
    oilAcidityTest?: SortOrder
    moistureContent?: SortOrder
  }

  export type EnumMaintenanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
  }

  export type EnumMaintenanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
  }

  export type EnumDTRReadingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRReadingType | EnumDTRReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DTRReadingType[] | ListEnumDTRReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRReadingType[] | ListEnumDTRReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRReadingTypeFilter<$PrismaModel> | $Enums.DTRReadingType
  }

  export type dtr_readingsCountOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    readingDate?: SortOrder
    readingType?: SortOrder
    loadKVA?: SortOrder
    loadPercentage?: SortOrder
    primaryVoltage?: SortOrder
    secondaryVoltage?: SortOrder
    primaryCurrent?: SortOrder
    secondaryCurrent?: SortOrder
    powerFactor?: SortOrder
    oilTemperature?: SortOrder
    windingTemperature?: SortOrder
    ambientTemperature?: SortOrder
    frequency?: SortOrder
    voltageUnbalance?: SortOrder
    currentUnbalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtr_readingsAvgOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    loadKVA?: SortOrder
    loadPercentage?: SortOrder
    powerFactor?: SortOrder
    oilTemperature?: SortOrder
    windingTemperature?: SortOrder
    ambientTemperature?: SortOrder
    frequency?: SortOrder
    voltageUnbalance?: SortOrder
    currentUnbalance?: SortOrder
  }

  export type dtr_readingsMaxOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    readingDate?: SortOrder
    readingType?: SortOrder
    loadKVA?: SortOrder
    loadPercentage?: SortOrder
    powerFactor?: SortOrder
    oilTemperature?: SortOrder
    windingTemperature?: SortOrder
    ambientTemperature?: SortOrder
    frequency?: SortOrder
    voltageUnbalance?: SortOrder
    currentUnbalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtr_readingsMinOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    readingDate?: SortOrder
    readingType?: SortOrder
    loadKVA?: SortOrder
    loadPercentage?: SortOrder
    powerFactor?: SortOrder
    oilTemperature?: SortOrder
    windingTemperature?: SortOrder
    ambientTemperature?: SortOrder
    frequency?: SortOrder
    voltageUnbalance?: SortOrder
    currentUnbalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtr_readingsSumOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    loadKVA?: SortOrder
    loadPercentage?: SortOrder
    powerFactor?: SortOrder
    oilTemperature?: SortOrder
    windingTemperature?: SortOrder
    ambientTemperature?: SortOrder
    frequency?: SortOrder
    voltageUnbalance?: SortOrder
    currentUnbalance?: SortOrder
  }

  export type EnumDTRReadingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRReadingType | EnumDTRReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DTRReadingType[] | ListEnumDTRReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRReadingType[] | ListEnumDTRReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRReadingTypeWithAggregatesFilter<$PrismaModel> | $Enums.DTRReadingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDTRReadingTypeFilter<$PrismaModel>
    _max?: NestedEnumDTRReadingTypeFilter<$PrismaModel>
  }

  export type EnumDTRTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRType | EnumDTRTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DTRType[] | ListEnumDTRTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRType[] | ListEnumDTRTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRTypeFilter<$PrismaModel> | $Enums.DTRType
  }

  export type EnumCoolingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CoolingType | EnumCoolingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CoolingType[] | ListEnumCoolingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoolingType[] | ListEnumCoolingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCoolingTypeFilter<$PrismaModel> | $Enums.CoolingType
  }

  export type EnumOilTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OilType | EnumOilTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OilType[] | ListEnumOilTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OilType[] | ListEnumOilTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOilTypeNullableFilter<$PrismaModel> | $Enums.OilType | null
  }

  export type EnumDTRStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRStatus | EnumDTRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DTRStatus[] | ListEnumDTRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRStatus[] | ListEnumDTRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRStatusFilter<$PrismaModel> | $Enums.DTRStatus
  }

  export type Dtr_faultsListRelationFilter = {
    every?: dtr_faultsWhereInput
    some?: dtr_faultsWhereInput
    none?: dtr_faultsWhereInput
  }

  export type Dtr_maintenanceListRelationFilter = {
    every?: dtr_maintenanceWhereInput
    some?: dtr_maintenanceWhereInput
    none?: dtr_maintenanceWhereInput
  }

  export type Dtr_readingsListRelationFilter = {
    every?: dtr_readingsWhereInput
    some?: dtr_readingsWhereInput
    none?: dtr_readingsWhereInput
  }

  export type MetersListRelationFilter = {
    every?: metersWhereInput
    some?: metersWhereInput
    none?: metersWhereInput
  }

  export type TicketsListRelationFilter = {
    every?: ticketsWhereInput
    some?: ticketsWhereInput
    none?: ticketsWhereInput
  }

  export type dtr_faultsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type dtr_maintenanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type dtr_readingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type metersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ticketsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type dtrsCountOrderByAggregateInput = {
    id?: SortOrder
    dtrNumber?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    capacity?: SortOrder
    type?: SortOrder
    phase?: SortOrder
    primaryVoltage?: SortOrder
    secondaryVoltage?: SortOrder
    frequency?: SortOrder
    impedance?: SortOrder
    coolingType?: SortOrder
    oilType?: SortOrder
    oilCapacity?: SortOrder
    locationId?: SortOrder
    installationDate?: SortOrder
    commissionDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    maxLoadLimit?: SortOrder
    alarmThreshold?: SortOrder
    tripThreshold?: SortOrder
    status?: SortOrder
    healthIndex?: SortOrder
    temperature?: SortOrder
    loadPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtrsAvgOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    phase?: SortOrder
    primaryVoltage?: SortOrder
    secondaryVoltage?: SortOrder
    frequency?: SortOrder
    impedance?: SortOrder
    oilCapacity?: SortOrder
    locationId?: SortOrder
    maxLoadLimit?: SortOrder
    alarmThreshold?: SortOrder
    tripThreshold?: SortOrder
    healthIndex?: SortOrder
    temperature?: SortOrder
    loadPercentage?: SortOrder
  }

  export type dtrsMaxOrderByAggregateInput = {
    id?: SortOrder
    dtrNumber?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    capacity?: SortOrder
    type?: SortOrder
    phase?: SortOrder
    primaryVoltage?: SortOrder
    secondaryVoltage?: SortOrder
    frequency?: SortOrder
    impedance?: SortOrder
    coolingType?: SortOrder
    oilType?: SortOrder
    oilCapacity?: SortOrder
    locationId?: SortOrder
    installationDate?: SortOrder
    commissionDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    maxLoadLimit?: SortOrder
    alarmThreshold?: SortOrder
    tripThreshold?: SortOrder
    status?: SortOrder
    healthIndex?: SortOrder
    temperature?: SortOrder
    loadPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtrsMinOrderByAggregateInput = {
    id?: SortOrder
    dtrNumber?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    capacity?: SortOrder
    type?: SortOrder
    phase?: SortOrder
    primaryVoltage?: SortOrder
    secondaryVoltage?: SortOrder
    frequency?: SortOrder
    impedance?: SortOrder
    coolingType?: SortOrder
    oilType?: SortOrder
    oilCapacity?: SortOrder
    locationId?: SortOrder
    installationDate?: SortOrder
    commissionDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    maxLoadLimit?: SortOrder
    alarmThreshold?: SortOrder
    tripThreshold?: SortOrder
    status?: SortOrder
    healthIndex?: SortOrder
    temperature?: SortOrder
    loadPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dtrsSumOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
    phase?: SortOrder
    primaryVoltage?: SortOrder
    secondaryVoltage?: SortOrder
    frequency?: SortOrder
    impedance?: SortOrder
    oilCapacity?: SortOrder
    locationId?: SortOrder
    maxLoadLimit?: SortOrder
    alarmThreshold?: SortOrder
    tripThreshold?: SortOrder
    healthIndex?: SortOrder
    temperature?: SortOrder
    loadPercentage?: SortOrder
  }

  export type EnumDTRTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRType | EnumDTRTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DTRType[] | ListEnumDTRTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRType[] | ListEnumDTRTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRTypeWithAggregatesFilter<$PrismaModel> | $Enums.DTRType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDTRTypeFilter<$PrismaModel>
    _max?: NestedEnumDTRTypeFilter<$PrismaModel>
  }

  export type EnumCoolingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoolingType | EnumCoolingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CoolingType[] | ListEnumCoolingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoolingType[] | ListEnumCoolingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCoolingTypeWithAggregatesFilter<$PrismaModel> | $Enums.CoolingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoolingTypeFilter<$PrismaModel>
    _max?: NestedEnumCoolingTypeFilter<$PrismaModel>
  }

  export type EnumOilTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OilType | EnumOilTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OilType[] | ListEnumOilTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OilType[] | ListEnumOilTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOilTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OilType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOilTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOilTypeNullableFilter<$PrismaModel>
  }

  export type EnumDTRStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRStatus | EnumDTRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DTRStatus[] | ListEnumDTRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRStatus[] | ListEnumDTRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRStatusWithAggregatesFilter<$PrismaModel> | $Enums.DTRStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDTRStatusFilter<$PrismaModel>
    _max?: NestedEnumDTRStatusFilter<$PrismaModel>
  }

  export type LocationsListRelationFilter = {
    every?: locationsWhereInput
    some?: locationsWhereInput
    none?: locationsWhereInput
  }

  export type locationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type location_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type location_typesAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type location_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type location_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type location_typesSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type ConsumersNullableRelationFilter = {
    is?: consumersWhereInput | null
    isNot?: consumersWhereInput | null
  }

  export type DtrsListRelationFilter = {
    every?: dtrsWhereInput
    some?: dtrsWhereInput
    none?: dtrsWhereInput
  }

  export type Location_typesRelationFilter = {
    is?: location_typesWhereInput
    isNot?: location_typesWhereInput
  }

  export type LocationsNullableRelationFilter = {
    is?: locationsWhereInput | null
    isNot?: locationsWhereInput | null
  }

  export type dtrsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type locationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    locationTypeId?: SortOrder
    parentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    pincode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type locationsAvgOrderByAggregateInput = {
    id?: SortOrder
    locationTypeId?: SortOrder
    parentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type locationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    locationTypeId?: SortOrder
    parentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    pincode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type locationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    locationTypeId?: SortOrder
    parentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    pincode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type locationsSumOrderByAggregateInput = {
    id?: SortOrder
    locationTypeId?: SortOrder
    parentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type login_historyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    deviceInfo?: SortOrder
    location?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
  }

  export type login_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type login_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    location?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
  }

  export type login_historyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    location?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
  }

  export type login_historySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type meter_configurationsCountOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    ctRatio?: SortOrder
    ctRatioPrimary?: SortOrder
    ctRatioSecondary?: SortOrder
    adoptedCTRatio?: SortOrder
    ctAccuracyClass?: SortOrder
    ctBurden?: SortOrder
    ptRatio?: SortOrder
    ptRatioPrimary?: SortOrder
    ptRatioSecondary?: SortOrder
    adoptedPTRatio?: SortOrder
    ptAccuracyClass?: SortOrder
    ptBurden?: SortOrder
    mf?: SortOrder
    vmf?: SortOrder
    cmf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type meter_configurationsAvgOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    ctRatioPrimary?: SortOrder
    ctRatioSecondary?: SortOrder
    ctBurden?: SortOrder
    ptRatioPrimary?: SortOrder
    ptRatioSecondary?: SortOrder
    ptBurden?: SortOrder
    mf?: SortOrder
    vmf?: SortOrder
    cmf?: SortOrder
  }

  export type meter_configurationsMaxOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    ctRatio?: SortOrder
    ctRatioPrimary?: SortOrder
    ctRatioSecondary?: SortOrder
    adoptedCTRatio?: SortOrder
    ctAccuracyClass?: SortOrder
    ctBurden?: SortOrder
    ptRatio?: SortOrder
    ptRatioPrimary?: SortOrder
    ptRatioSecondary?: SortOrder
    adoptedPTRatio?: SortOrder
    ptAccuracyClass?: SortOrder
    ptBurden?: SortOrder
    mf?: SortOrder
    vmf?: SortOrder
    cmf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type meter_configurationsMinOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    ctRatio?: SortOrder
    ctRatioPrimary?: SortOrder
    ctRatioSecondary?: SortOrder
    adoptedCTRatio?: SortOrder
    ctAccuracyClass?: SortOrder
    ctBurden?: SortOrder
    ptRatio?: SortOrder
    ptRatioPrimary?: SortOrder
    ptRatioSecondary?: SortOrder
    adoptedPTRatio?: SortOrder
    ptAccuracyClass?: SortOrder
    ptBurden?: SortOrder
    mf?: SortOrder
    vmf?: SortOrder
    cmf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type meter_configurationsSumOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    ctRatioPrimary?: SortOrder
    ctRatioSecondary?: SortOrder
    ctBurden?: SortOrder
    ptRatioPrimary?: SortOrder
    ptRatioSecondary?: SortOrder
    ptBurden?: SortOrder
    mf?: SortOrder
    vmf?: SortOrder
    cmf?: SortOrder
  }

  export type EnumReadingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingType | EnumReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingTypeFilter<$PrismaModel> | $Enums.ReadingType
  }

  export type EnumReadingSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingSource | EnumReadingSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingSource[] | ListEnumReadingSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingSource[] | ListEnumReadingSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingSourceFilter<$PrismaModel> | $Enums.ReadingSource
  }

  export type BillsNullableRelationFilter = {
    is?: billsWhereInput | null
    isNot?: billsWhereInput | null
  }

  export type Prepaid_transactionsListRelationFilter = {
    every?: prepaid_transactionsWhereInput
    some?: prepaid_transactionsWhereInput
    none?: prepaid_transactionsWhereInput
  }

  export type prepaid_transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type meter_readingsCountOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    readingDate?: SortOrder
    readingType?: SortOrder
    readingSource?: SortOrder
    currentReading?: SortOrder
    previousReading?: SortOrder
    consumption?: SortOrder
    kWh?: SortOrder
    kVAh?: SortOrder
    kVARh?: SortOrder
    powerFactor?: SortOrder
    averagePF?: SortOrder
    minimumPF?: SortOrder
    voltageR?: SortOrder
    voltageY?: SortOrder
    voltageB?: SortOrder
    averageVoltage?: SortOrder
    currentR?: SortOrder
    currentY?: SortOrder
    currentB?: SortOrder
    averageCurrent?: SortOrder
    isValid?: SortOrder
    validatedBy?: SortOrder
    validatedAt?: SortOrder
    billId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kVA?: SortOrder
    kW?: SortOrder
    bphPowerFactor?: SortOrder
    frequency?: SortOrder
    rphPowerFactor?: SortOrder
    yphPowerFactor?: SortOrder
  }

  export type meter_readingsAvgOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    currentReading?: SortOrder
    previousReading?: SortOrder
    consumption?: SortOrder
    kWh?: SortOrder
    kVAh?: SortOrder
    kVARh?: SortOrder
    powerFactor?: SortOrder
    averagePF?: SortOrder
    minimumPF?: SortOrder
    voltageR?: SortOrder
    voltageY?: SortOrder
    voltageB?: SortOrder
    averageVoltage?: SortOrder
    currentR?: SortOrder
    currentY?: SortOrder
    currentB?: SortOrder
    averageCurrent?: SortOrder
    billId?: SortOrder
    kVA?: SortOrder
    kW?: SortOrder
    bphPowerFactor?: SortOrder
    frequency?: SortOrder
    rphPowerFactor?: SortOrder
    yphPowerFactor?: SortOrder
  }

  export type meter_readingsMaxOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    readingDate?: SortOrder
    readingType?: SortOrder
    readingSource?: SortOrder
    currentReading?: SortOrder
    previousReading?: SortOrder
    consumption?: SortOrder
    kWh?: SortOrder
    kVAh?: SortOrder
    kVARh?: SortOrder
    powerFactor?: SortOrder
    averagePF?: SortOrder
    minimumPF?: SortOrder
    voltageR?: SortOrder
    voltageY?: SortOrder
    voltageB?: SortOrder
    averageVoltage?: SortOrder
    currentR?: SortOrder
    currentY?: SortOrder
    currentB?: SortOrder
    averageCurrent?: SortOrder
    isValid?: SortOrder
    validatedBy?: SortOrder
    validatedAt?: SortOrder
    billId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kVA?: SortOrder
    kW?: SortOrder
    bphPowerFactor?: SortOrder
    frequency?: SortOrder
    rphPowerFactor?: SortOrder
    yphPowerFactor?: SortOrder
  }

  export type meter_readingsMinOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    readingDate?: SortOrder
    readingType?: SortOrder
    readingSource?: SortOrder
    currentReading?: SortOrder
    previousReading?: SortOrder
    consumption?: SortOrder
    kWh?: SortOrder
    kVAh?: SortOrder
    kVARh?: SortOrder
    powerFactor?: SortOrder
    averagePF?: SortOrder
    minimumPF?: SortOrder
    voltageR?: SortOrder
    voltageY?: SortOrder
    voltageB?: SortOrder
    averageVoltage?: SortOrder
    currentR?: SortOrder
    currentY?: SortOrder
    currentB?: SortOrder
    averageCurrent?: SortOrder
    isValid?: SortOrder
    validatedBy?: SortOrder
    validatedAt?: SortOrder
    billId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kVA?: SortOrder
    kW?: SortOrder
    bphPowerFactor?: SortOrder
    frequency?: SortOrder
    rphPowerFactor?: SortOrder
    yphPowerFactor?: SortOrder
  }

  export type meter_readingsSumOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    currentReading?: SortOrder
    previousReading?: SortOrder
    consumption?: SortOrder
    kWh?: SortOrder
    kVAh?: SortOrder
    kVARh?: SortOrder
    powerFactor?: SortOrder
    averagePF?: SortOrder
    minimumPF?: SortOrder
    voltageR?: SortOrder
    voltageY?: SortOrder
    voltageB?: SortOrder
    averageVoltage?: SortOrder
    currentR?: SortOrder
    currentY?: SortOrder
    currentB?: SortOrder
    averageCurrent?: SortOrder
    billId?: SortOrder
    kVA?: SortOrder
    kW?: SortOrder
    bphPowerFactor?: SortOrder
    frequency?: SortOrder
    rphPowerFactor?: SortOrder
    yphPowerFactor?: SortOrder
  }

  export type EnumReadingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingType | EnumReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReadingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReadingTypeFilter<$PrismaModel>
    _max?: NestedEnumReadingTypeFilter<$PrismaModel>
  }

  export type EnumReadingSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingSource | EnumReadingSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingSource[] | ListEnumReadingSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingSource[] | ListEnumReadingSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingSourceWithAggregatesFilter<$PrismaModel> | $Enums.ReadingSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReadingSourceFilter<$PrismaModel>
    _max?: NestedEnumReadingSourceFilter<$PrismaModel>
  }

  export type EnumMeterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MeterType | EnumMeterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MeterType[] | ListEnumMeterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeterType[] | ListEnumMeterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMeterTypeFilter<$PrismaModel> | $Enums.MeterType
  }

  export type EnumMeterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MeterStatus | EnumMeterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeterStatus[] | ListEnumMeterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeterStatus[] | ListEnumMeterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeterStatusFilter<$PrismaModel> | $Enums.MeterStatus
  }

  export type Current_transformersListRelationFilter = {
    every?: current_transformersWhereInput
    some?: current_transformersWhereInput
    none?: current_transformersWhereInput
  }

  export type Meter_configurationsNullableRelationFilter = {
    is?: meter_configurationsWhereInput | null
    isNot?: meter_configurationsWhereInput | null
  }

  export type DtrsNullableRelationFilter = {
    is?: dtrsWhereInput | null
    isNot?: dtrsWhereInput | null
  }

  export type Potential_transformersListRelationFilter = {
    every?: potential_transformersWhereInput
    some?: potential_transformersWhereInput
    none?: potential_transformersWhereInput
  }

  export type Tamper_eventsListRelationFilter = {
    every?: tamper_eventsWhereInput
    some?: tamper_eventsWhereInput
    none?: tamper_eventsWhereInput
  }

  export type current_transformersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type potential_transformersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tamper_eventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type metersCountOrderByAggregateInput = {
    id?: SortOrder
    meterNumber?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    type?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    isInUse?: SortOrder
    installationDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    decommissionDate?: SortOrder
    locationId?: SortOrder
    dtrId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type metersAvgOrderByAggregateInput = {
    id?: SortOrder
    phase?: SortOrder
    locationId?: SortOrder
    dtrId?: SortOrder
  }

  export type metersMaxOrderByAggregateInput = {
    id?: SortOrder
    meterNumber?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    type?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    isInUse?: SortOrder
    installationDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    decommissionDate?: SortOrder
    locationId?: SortOrder
    dtrId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type metersMinOrderByAggregateInput = {
    id?: SortOrder
    meterNumber?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    type?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    isInUse?: SortOrder
    installationDate?: SortOrder
    lastMaintenanceDate?: SortOrder
    decommissionDate?: SortOrder
    locationId?: SortOrder
    dtrId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type metersSumOrderByAggregateInput = {
    id?: SortOrder
    phase?: SortOrder
    locationId?: SortOrder
    dtrId?: SortOrder
  }

  export type EnumMeterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeterType | EnumMeterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MeterType[] | ListEnumMeterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeterType[] | ListEnumMeterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMeterTypeWithAggregatesFilter<$PrismaModel> | $Enums.MeterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeterTypeFilter<$PrismaModel>
    _max?: NestedEnumMeterTypeFilter<$PrismaModel>
  }

  export type EnumMeterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeterStatus | EnumMeterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeterStatus[] | ListEnumMeterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeterStatus[] | ListEnumMeterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeterStatusWithAggregatesFilter<$PrismaModel> | $Enums.MeterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeterStatusFilter<$PrismaModel>
    _max?: NestedEnumMeterStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type EnumNotificationChannelNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel> | null
    has?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    hasSome?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    channels?: SortOrder
    status?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notificationsSumOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type BillsRelationFilter = {
    is?: billsWhereInput
    isNot?: billsWhereInput
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    billId?: SortOrder
    amount?: SortOrder
    paymentMode?: SortOrder
    paymentStatus?: SortOrder
    gatewayResponse?: SortOrder
    receiptNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    amount?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    billId?: SortOrder
    amount?: SortOrder
    paymentMode?: SortOrder
    paymentStatus?: SortOrder
    receiptNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    billId?: SortOrder
    amount?: SortOrder
    paymentMode?: SortOrder
    paymentStatus?: SortOrder
    receiptNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type User_permissionsListRelationFilter = {
    every?: user_permissionsWhereInput
    some?: user_permissionsWhereInput
    none?: user_permissionsWhereInput
  }

  export type user_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type permissionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type potential_transformersCountOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    accuracyClass?: SortOrder
    burden?: SortOrder
    installationDate?: SortOrder
    lastTestedDate?: SortOrder
    nextTestDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type potential_transformersAvgOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    burden?: SortOrder
  }

  export type potential_transformersMaxOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    accuracyClass?: SortOrder
    burden?: SortOrder
    installationDate?: SortOrder
    lastTestedDate?: SortOrder
    nextTestDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type potential_transformersMinOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    accuracyClass?: SortOrder
    burden?: SortOrder
    installationDate?: SortOrder
    lastTestedDate?: SortOrder
    nextTestDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type potential_transformersSumOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    ratedPrimary?: SortOrder
    ratedSecondary?: SortOrder
    burden?: SortOrder
  }

  export type RolesRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type role_permissionsRoleIdPermissionIdCompoundUniqueInput = {
    roleId: number
    permissionId: InputJsonValue
  }

  export type role_permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    isGranted?: SortOrder
    restrictions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type role_permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type role_permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    isGranted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type role_permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    isGranted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type role_permissionsSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type EnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type Role_permissionsListRelationFilter = {
    every?: role_permissionsWhereInput
    some?: role_permissionsWhereInput
    none?: role_permissionsWhereInput
  }

  export type role_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    level?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
  }

  export type EnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type EnumTicketTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeFilter<$PrismaModel> | $Enums.TicketType
  }

  export type EnumTicketCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryFilter<$PrismaModel> | $Enums.TicketCategory
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type ticketsCountOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    dtrId?: SortOrder
    raisedById?: SortOrder
    assignedToId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ticketsAvgOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    raisedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type ticketsMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    dtrId?: SortOrder
    raisedById?: SortOrder
    assignedToId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ticketsMinOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    dtrId?: SortOrder
    raisedById?: SortOrder
    assignedToId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ticketsSumOrderByAggregateInput = {
    id?: SortOrder
    dtrId?: SortOrder
    raisedById?: SortOrder
    assignedToId?: SortOrder
  }

  export type EnumTicketTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel> | $Enums.TicketType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketTypeFilter<$PrismaModel>
    _max?: NestedEnumTicketTypeFilter<$PrismaModel>
  }

  export type EnumTicketCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TicketCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketCategoryFilter<$PrismaModel>
    _max?: NestedEnumTicketCategoryFilter<$PrismaModel>
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type user_activity_logsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type user_activity_logsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type user_activity_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type user_activity_logsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type user_activity_logsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PermissionsRelationFilter = {
    is?: permissionsWhereInput
    isNot?: permissionsWhereInput
  }

  export type user_permissionsUserIdPermissionIdCompoundUniqueInput = {
    userId: number
    permissionId: number
  }

  export type user_permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionId?: SortOrder
    isGranted?: SortOrder
    reason?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionId?: SortOrder
  }

  export type user_permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionId?: SortOrder
    isGranted?: SortOrder
    reason?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionId?: SortOrder
    isGranted?: SortOrder
    reason?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_permissionsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionId?: SortOrder
  }

  export type user_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    lastActivityAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_sessionsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type user_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    ipAddress?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    lastActivityAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    ipAddress?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    lastActivityAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_sessionsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type refresh_tokensCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type refresh_tokensAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type refresh_tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type refresh_tokensMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type refresh_tokensSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type Login_historyListRelationFilter = {
    every?: login_historyWhereInput
    some?: login_historyWhereInput
    none?: login_historyWhereInput
  }

  export type User_activity_logsListRelationFilter = {
    every?: user_activity_logsWhereInput
    some?: user_activity_logsWhereInput
    none?: user_activity_logsWhereInput
  }

  export type User_sessionsListRelationFilter = {
    every?: user_sessionsWhereInput
    some?: user_sessionsWhereInput
    none?: user_sessionsWhereInput
  }

  export type Refresh_tokensNullableRelationFilter = {
    is?: refresh_tokensWhereInput | null
    isNot?: refresh_tokensWhereInput | null
  }

  export type RolesNullableRelationFilter = {
    is?: rolesWhereInput | null
    isNot?: rolesWhereInput | null
  }

  export type login_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_activity_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    profileImage?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    lastLoginAt?: SortOrder
    passwordChangedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockoutUntil?: SortOrder
    departmentId?: SortOrder
    roleId?: SortOrder
    locationId?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    failedLoginAttempts?: SortOrder
    departmentId?: SortOrder
    roleId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    profileImage?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    lastLoginAt?: SortOrder
    passwordChangedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockoutUntil?: SortOrder
    departmentId?: SortOrder
    roleId?: SortOrder
    locationId?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    profileImage?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    lastLoginAt?: SortOrder
    passwordChangedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockoutUntil?: SortOrder
    departmentId?: SortOrder
    roleId?: SortOrder
    locationId?: SortOrder
    accessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    failedLoginAttempts?: SortOrder
    departmentId?: SortOrder
    roleId?: SortOrder
    locationId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type raw_xml_importCountOrderByAggregateInput = {
    id?: SortOrder
    doc?: SortOrder
    imported_at?: SortOrder
  }

  export type raw_xml_importAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type raw_xml_importMaxOrderByAggregateInput = {
    id?: SortOrder
    doc?: SortOrder
    imported_at?: SortOrder
  }

  export type raw_xml_importMinOrderByAggregateInput = {
    id?: SortOrder
    doc?: SortOrder
    imported_at?: SortOrder
  }

  export type raw_xml_importSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Prepaid_alertsListRelationFilter = {
    every?: prepaid_alertsWhereInput
    some?: prepaid_alertsWhereInput
    none?: prepaid_alertsWhereInput
  }

  export type Prepaid_rechargesListRelationFilter = {
    every?: prepaid_rechargesWhereInput
    some?: prepaid_rechargesWhereInput
    none?: prepaid_rechargesWhereInput
  }

  export type prepaid_alertsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type prepaid_rechargesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type prepaid_accountsCountOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
    accountNumber?: SortOrder
    currentBalance?: SortOrder
    totalRecharged?: SortOrder
    totalConsumed?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    blockReason?: SortOrder
    blockedAt?: SortOrder
    blockedBy?: SortOrder
    lowBalanceThreshold?: SortOrder
    emergencyThreshold?: SortOrder
    autoRechargeEnabled?: SortOrder
    autoRechargeAmount?: SortOrder
    autoRechargeThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prepaid_accountsAvgOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
    currentBalance?: SortOrder
    totalRecharged?: SortOrder
    totalConsumed?: SortOrder
    blockedBy?: SortOrder
    lowBalanceThreshold?: SortOrder
    emergencyThreshold?: SortOrder
    autoRechargeAmount?: SortOrder
    autoRechargeThreshold?: SortOrder
  }

  export type prepaid_accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
    accountNumber?: SortOrder
    currentBalance?: SortOrder
    totalRecharged?: SortOrder
    totalConsumed?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    blockReason?: SortOrder
    blockedAt?: SortOrder
    blockedBy?: SortOrder
    lowBalanceThreshold?: SortOrder
    emergencyThreshold?: SortOrder
    autoRechargeEnabled?: SortOrder
    autoRechargeAmount?: SortOrder
    autoRechargeThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prepaid_accountsMinOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
    accountNumber?: SortOrder
    currentBalance?: SortOrder
    totalRecharged?: SortOrder
    totalConsumed?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    blockReason?: SortOrder
    blockedAt?: SortOrder
    blockedBy?: SortOrder
    lowBalanceThreshold?: SortOrder
    emergencyThreshold?: SortOrder
    autoRechargeEnabled?: SortOrder
    autoRechargeAmount?: SortOrder
    autoRechargeThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prepaid_accountsSumOrderByAggregateInput = {
    id?: SortOrder
    consumerId?: SortOrder
    currentBalance?: SortOrder
    totalRecharged?: SortOrder
    totalConsumed?: SortOrder
    blockedBy?: SortOrder
    lowBalanceThreshold?: SortOrder
    emergencyThreshold?: SortOrder
    autoRechargeAmount?: SortOrder
    autoRechargeThreshold?: SortOrder
  }

  export type EnumPrepaidAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidAlertType | EnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidAlertType[] | ListEnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidAlertType[] | ListEnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidAlertTypeFilter<$PrismaModel> | $Enums.PrepaidAlertType
  }

  export type EnumPrepaidAlertLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidAlertLevel | EnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidAlertLevel[] | ListEnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidAlertLevel[] | ListEnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidAlertLevelFilter<$PrismaModel> | $Enums.PrepaidAlertLevel
  }

  export type Prepaid_accountsRelationFilter = {
    is?: prepaid_accountsWhereInput
    isNot?: prepaid_accountsWhereInput
  }

  export type prepaid_alertsCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    alertType?: SortOrder
    alertLevel?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    balanceAtAlert?: SortOrder
    consumptionAtAlert?: SortOrder
    thresholdValue?: SortOrder
    createdAt?: SortOrder
  }

  export type prepaid_alertsAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    balanceAtAlert?: SortOrder
    consumptionAtAlert?: SortOrder
    thresholdValue?: SortOrder
  }

  export type prepaid_alertsMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    alertType?: SortOrder
    alertLevel?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    balanceAtAlert?: SortOrder
    consumptionAtAlert?: SortOrder
    thresholdValue?: SortOrder
    createdAt?: SortOrder
  }

  export type prepaid_alertsMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    alertType?: SortOrder
    alertLevel?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    balanceAtAlert?: SortOrder
    consumptionAtAlert?: SortOrder
    thresholdValue?: SortOrder
    createdAt?: SortOrder
  }

  export type prepaid_alertsSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    balanceAtAlert?: SortOrder
    consumptionAtAlert?: SortOrder
    thresholdValue?: SortOrder
  }

  export type EnumPrepaidAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidAlertType | EnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidAlertType[] | ListEnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidAlertType[] | ListEnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidAlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumPrepaidAlertTypeFilter<$PrismaModel>
  }

  export type EnumPrepaidAlertLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidAlertLevel | EnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidAlertLevel[] | ListEnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidAlertLevel[] | ListEnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidAlertLevelWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidAlertLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidAlertLevelFilter<$PrismaModel>
    _max?: NestedEnumPrepaidAlertLevelFilter<$PrismaModel>
  }

  export type EnumPrepaidRechargeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidRechargeType | EnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidRechargeType[] | ListEnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidRechargeType[] | ListEnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidRechargeTypeFilter<$PrismaModel> | $Enums.PrepaidRechargeType
  }

  export type EnumPrepaidRechargeSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidRechargeSource | EnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidRechargeSource[] | ListEnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidRechargeSource[] | ListEnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidRechargeSourceFilter<$PrismaModel> | $Enums.PrepaidRechargeSource
  }

  export type prepaid_rechargesCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    rechargeId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    gatewayName?: SortOrder
    gatewayTransactionId?: SortOrder
    gatewayResponse?: SortOrder
    rechargeType?: SortOrder
    rechargeSource?: SortOrder
    isPromotional?: SortOrder
    promotionalCode?: SortOrder
    discountAmount?: SortOrder
    bonusAmount?: SortOrder
    receiptNumber?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prepaid_rechargesAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    discountAmount?: SortOrder
    bonusAmount?: SortOrder
  }

  export type prepaid_rechargesMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    rechargeId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    gatewayName?: SortOrder
    gatewayTransactionId?: SortOrder
    rechargeType?: SortOrder
    rechargeSource?: SortOrder
    isPromotional?: SortOrder
    promotionalCode?: SortOrder
    discountAmount?: SortOrder
    bonusAmount?: SortOrder
    receiptNumber?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prepaid_rechargesMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    rechargeId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    gatewayName?: SortOrder
    gatewayTransactionId?: SortOrder
    rechargeType?: SortOrder
    rechargeSource?: SortOrder
    isPromotional?: SortOrder
    promotionalCode?: SortOrder
    discountAmount?: SortOrder
    bonusAmount?: SortOrder
    receiptNumber?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prepaid_rechargesSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    discountAmount?: SortOrder
    bonusAmount?: SortOrder
  }

  export type EnumPrepaidRechargeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidRechargeType | EnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidRechargeType[] | ListEnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidRechargeType[] | ListEnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidRechargeTypeWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidRechargeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidRechargeTypeFilter<$PrismaModel>
    _max?: NestedEnumPrepaidRechargeTypeFilter<$PrismaModel>
  }

  export type EnumPrepaidRechargeSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidRechargeSource | EnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidRechargeSource[] | ListEnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidRechargeSource[] | ListEnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidRechargeSourceWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidRechargeSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidRechargeSourceFilter<$PrismaModel>
    _max?: NestedEnumPrepaidRechargeSourceFilter<$PrismaModel>
  }

  export type EnumPrepaidTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidTransactionType | EnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidTransactionType[] | ListEnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidTransactionType[] | ListEnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidTransactionTypeFilter<$PrismaModel> | $Enums.PrepaidTransactionType
  }

  export type EnumPrepaidTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidTransactionStatus | EnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidTransactionStatus[] | ListEnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidTransactionStatus[] | ListEnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidTransactionStatusFilter<$PrismaModel> | $Enums.PrepaidTransactionStatus
  }

  export type Meter_readingsNullableRelationFilter = {
    is?: meter_readingsWhereInput | null
    isNot?: meter_readingsWhereInput | null
  }

  export type prepaid_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    consumptionKWh?: SortOrder
    ratePerUnit?: SortOrder
    fixedCharges?: SortOrder
    taxes?: SortOrder
    readingId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prepaid_transactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    consumptionKWh?: SortOrder
    ratePerUnit?: SortOrder
    fixedCharges?: SortOrder
    readingId?: SortOrder
  }

  export type prepaid_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    consumptionKWh?: SortOrder
    ratePerUnit?: SortOrder
    fixedCharges?: SortOrder
    readingId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prepaid_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    transactionId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    consumptionKWh?: SortOrder
    ratePerUnit?: SortOrder
    fixedCharges?: SortOrder
    readingId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type prepaid_transactionsSumOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    consumptionKWh?: SortOrder
    ratePerUnit?: SortOrder
    fixedCharges?: SortOrder
    readingId?: SortOrder
  }

  export type EnumPrepaidTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidTransactionType | EnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidTransactionType[] | ListEnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidTransactionType[] | ListEnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumPrepaidTransactionTypeFilter<$PrismaModel>
  }

  export type EnumPrepaidTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidTransactionStatus | EnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidTransactionStatus[] | ListEnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidTransactionStatus[] | ListEnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidTransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumPrepaidTransactionStatusFilter<$PrismaModel>
  }

  export type tamper_code_descCountOrderByAggregateInput = {
    id?: SortOrder
    tamperCode?: SortOrder
    tamperDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tamper_code_descAvgOrderByAggregateInput = {
    id?: SortOrder
    tamperCode?: SortOrder
  }

  export type tamper_code_descMaxOrderByAggregateInput = {
    id?: SortOrder
    tamperCode?: SortOrder
    tamperDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tamper_code_descMinOrderByAggregateInput = {
    id?: SortOrder
    tamperCode?: SortOrder
    tamperDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tamper_code_descSumOrderByAggregateInput = {
    id?: SortOrder
    tamperCode?: SortOrder
  }

  export type EnumTamperTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TamperType | EnumTamperTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TamperType[] | ListEnumTamperTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TamperType[] | ListEnumTamperTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTamperTypeFilter<$PrismaModel> | $Enums.TamperType
  }

  export type EnumTamperStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TamperStatus | EnumTamperStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TamperStatus[] | ListEnumTamperStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TamperStatus[] | ListEnumTamperStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTamperStatusFilter<$PrismaModel> | $Enums.TamperStatus
  }

  export type tamper_eventsMeterIdTamperDatetimeTamperTypeTamperStatusCompoundUniqueInput = {
    meterId: number
    tamperDatetime: Date | string
    tamperType: $Enums.TamperType
    tamperStatus: $Enums.TamperStatus
  }

  export type tamper_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    tamperDatetime?: SortOrder
    tamperType?: SortOrder
    tamperStatus?: SortOrder
    avgCurrent?: SortOrder
    avgVoltage?: SortOrder
    avgPowerFactor?: SortOrder
    frequency?: SortOrder
    kwh?: SortOrder
    kwhExport?: SortOrder
    kwhImport?: SortOrder
    kwhNet?: SortOrder
    kwhTotal?: SortOrder
    kwExport?: SortOrder
    kwImport?: SortOrder
    kvaExport?: SortOrder
    kvaImport?: SortOrder
    voltageR?: SortOrder
    voltageY?: SortOrder
    voltageB?: SortOrder
    currentR?: SortOrder
    currentY?: SortOrder
    currentB?: SortOrder
    powerFactorR?: SortOrder
    powerFactorY?: SortOrder
    powerFactorB?: SortOrder
    tamperCount?: SortOrder
    param1?: SortOrder
    param2?: SortOrder
    param3?: SortOrder
    param4?: SortOrder
    param5?: SortOrder
    isProcessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tamper_eventsAvgOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    avgCurrent?: SortOrder
    avgVoltage?: SortOrder
    avgPowerFactor?: SortOrder
    frequency?: SortOrder
    kwh?: SortOrder
    kwhExport?: SortOrder
    kwhImport?: SortOrder
    kwhNet?: SortOrder
    kwhTotal?: SortOrder
    kwExport?: SortOrder
    kwImport?: SortOrder
    kvaExport?: SortOrder
    kvaImport?: SortOrder
    voltageR?: SortOrder
    voltageY?: SortOrder
    voltageB?: SortOrder
    currentR?: SortOrder
    currentY?: SortOrder
    currentB?: SortOrder
    powerFactorR?: SortOrder
    powerFactorY?: SortOrder
    powerFactorB?: SortOrder
    tamperCount?: SortOrder
    param1?: SortOrder
    param2?: SortOrder
    param3?: SortOrder
    param4?: SortOrder
    param5?: SortOrder
  }

  export type tamper_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    tamperDatetime?: SortOrder
    tamperType?: SortOrder
    tamperStatus?: SortOrder
    avgCurrent?: SortOrder
    avgVoltage?: SortOrder
    avgPowerFactor?: SortOrder
    frequency?: SortOrder
    kwh?: SortOrder
    kwhExport?: SortOrder
    kwhImport?: SortOrder
    kwhNet?: SortOrder
    kwhTotal?: SortOrder
    kwExport?: SortOrder
    kwImport?: SortOrder
    kvaExport?: SortOrder
    kvaImport?: SortOrder
    voltageR?: SortOrder
    voltageY?: SortOrder
    voltageB?: SortOrder
    currentR?: SortOrder
    currentY?: SortOrder
    currentB?: SortOrder
    powerFactorR?: SortOrder
    powerFactorY?: SortOrder
    powerFactorB?: SortOrder
    tamperCount?: SortOrder
    param1?: SortOrder
    param2?: SortOrder
    param3?: SortOrder
    param4?: SortOrder
    param5?: SortOrder
    isProcessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tamper_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    tamperDatetime?: SortOrder
    tamperType?: SortOrder
    tamperStatus?: SortOrder
    avgCurrent?: SortOrder
    avgVoltage?: SortOrder
    avgPowerFactor?: SortOrder
    frequency?: SortOrder
    kwh?: SortOrder
    kwhExport?: SortOrder
    kwhImport?: SortOrder
    kwhNet?: SortOrder
    kwhTotal?: SortOrder
    kwExport?: SortOrder
    kwImport?: SortOrder
    kvaExport?: SortOrder
    kvaImport?: SortOrder
    voltageR?: SortOrder
    voltageY?: SortOrder
    voltageB?: SortOrder
    currentR?: SortOrder
    currentY?: SortOrder
    currentB?: SortOrder
    powerFactorR?: SortOrder
    powerFactorY?: SortOrder
    powerFactorB?: SortOrder
    tamperCount?: SortOrder
    param1?: SortOrder
    param2?: SortOrder
    param3?: SortOrder
    param4?: SortOrder
    param5?: SortOrder
    isProcessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tamper_eventsSumOrderByAggregateInput = {
    id?: SortOrder
    meterId?: SortOrder
    avgCurrent?: SortOrder
    avgVoltage?: SortOrder
    avgPowerFactor?: SortOrder
    frequency?: SortOrder
    kwh?: SortOrder
    kwhExport?: SortOrder
    kwhImport?: SortOrder
    kwhNet?: SortOrder
    kwhTotal?: SortOrder
    kwExport?: SortOrder
    kwImport?: SortOrder
    kvaExport?: SortOrder
    kvaImport?: SortOrder
    voltageR?: SortOrder
    voltageY?: SortOrder
    voltageB?: SortOrder
    currentR?: SortOrder
    currentY?: SortOrder
    currentB?: SortOrder
    powerFactorR?: SortOrder
    powerFactorY?: SortOrder
    powerFactorB?: SortOrder
    tamperCount?: SortOrder
    param1?: SortOrder
    param2?: SortOrder
    param3?: SortOrder
    param4?: SortOrder
    param5?: SortOrder
  }

  export type EnumTamperTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TamperType | EnumTamperTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TamperType[] | ListEnumTamperTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TamperType[] | ListEnumTamperTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTamperTypeWithAggregatesFilter<$PrismaModel> | $Enums.TamperType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTamperTypeFilter<$PrismaModel>
    _max?: NestedEnumTamperTypeFilter<$PrismaModel>
  }

  export type EnumTamperStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TamperStatus | EnumTamperStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TamperStatus[] | ListEnumTamperStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TamperStatus[] | ListEnumTamperStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTamperStatusWithAggregatesFilter<$PrismaModel> | $Enums.TamperStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTamperStatusFilter<$PrismaModel>
    _max?: NestedEnumTamperStatusFilter<$PrismaModel>
  }

  export type Tariff_slabsListRelationFilter = {
    every?: tariff_slabsWhereInput
    some?: tariff_slabsWhereInput
    none?: tariff_slabsWhereInput
  }

  export type tariff_slabsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tariffCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    category?: SortOrder
    tariff_name?: SortOrder
    type?: SortOrder
    device?: SortOrder
    min_demand?: SortOrder
    min_demand_unit_rate?: SortOrder
    min_demand_excess_unit_rate?: SortOrder
    base_unit_rate?: SortOrder
    elec_duty_unit_rate?: SortOrder
    ims?: SortOrder
    gst?: SortOrder
    valid_from?: SortOrder
    valid_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tariffAvgOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    category?: SortOrder
    min_demand?: SortOrder
    min_demand_unit_rate?: SortOrder
    min_demand_excess_unit_rate?: SortOrder
    base_unit_rate?: SortOrder
    elec_duty_unit_rate?: SortOrder
    ims?: SortOrder
    gst?: SortOrder
  }

  export type tariffMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    category?: SortOrder
    tariff_name?: SortOrder
    type?: SortOrder
    device?: SortOrder
    min_demand?: SortOrder
    min_demand_unit_rate?: SortOrder
    min_demand_excess_unit_rate?: SortOrder
    base_unit_rate?: SortOrder
    elec_duty_unit_rate?: SortOrder
    ims?: SortOrder
    gst?: SortOrder
    valid_from?: SortOrder
    valid_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tariffMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    category?: SortOrder
    tariff_name?: SortOrder
    type?: SortOrder
    device?: SortOrder
    min_demand?: SortOrder
    min_demand_unit_rate?: SortOrder
    min_demand_excess_unit_rate?: SortOrder
    base_unit_rate?: SortOrder
    elec_duty_unit_rate?: SortOrder
    ims?: SortOrder
    gst?: SortOrder
    valid_from?: SortOrder
    valid_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tariffSumOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    category?: SortOrder
    min_demand?: SortOrder
    min_demand_unit_rate?: SortOrder
    min_demand_excess_unit_rate?: SortOrder
    base_unit_rate?: SortOrder
    elec_duty_unit_rate?: SortOrder
    ims?: SortOrder
    gst?: SortOrder
  }

  export type TariffRelationFilter = {
    is?: tariffWhereInput
    isNot?: tariffWhereInput
  }

  export type tariff_slabsCountOrderByAggregateInput = {
    id?: SortOrder
    tariff_id?: SortOrder
    slab_order?: SortOrder
    unit_limit?: SortOrder
    unit_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tariff_slabsAvgOrderByAggregateInput = {
    id?: SortOrder
    tariff_id?: SortOrder
    slab_order?: SortOrder
    unit_limit?: SortOrder
    unit_rate?: SortOrder
  }

  export type tariff_slabsMaxOrderByAggregateInput = {
    id?: SortOrder
    tariff_id?: SortOrder
    slab_order?: SortOrder
    unit_limit?: SortOrder
    unit_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tariff_slabsMinOrderByAggregateInput = {
    id?: SortOrder
    tariff_id?: SortOrder
    slab_order?: SortOrder
    unit_limit?: SortOrder
    unit_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tariff_slabsSumOrderByAggregateInput = {
    id?: SortOrder
    tariff_id?: SortOrder
    slab_order?: SortOrder
    unit_limit?: SortOrder
    unit_rate?: SortOrder
  }

  export type consumersCreateNestedOneWithoutBillsInput = {
    create?: XOR<consumersCreateWithoutBillsInput, consumersUncheckedCreateWithoutBillsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutBillsInput
    connect?: consumersWhereUniqueInput
  }

  export type metersCreateNestedOneWithoutBillsInput = {
    create?: XOR<metersCreateWithoutBillsInput, metersUncheckedCreateWithoutBillsInput>
    connectOrCreate?: metersCreateOrConnectWithoutBillsInput
    connect?: metersWhereUniqueInput
  }

  export type meter_readingsCreateNestedManyWithoutBillsInput = {
    create?: XOR<meter_readingsCreateWithoutBillsInput, meter_readingsUncheckedCreateWithoutBillsInput> | meter_readingsCreateWithoutBillsInput[] | meter_readingsUncheckedCreateWithoutBillsInput[]
    connectOrCreate?: meter_readingsCreateOrConnectWithoutBillsInput | meter_readingsCreateOrConnectWithoutBillsInput[]
    createMany?: meter_readingsCreateManyBillsInputEnvelope
    connect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutBillsInput = {
    create?: XOR<paymentsCreateWithoutBillsInput, paymentsUncheckedCreateWithoutBillsInput> | paymentsCreateWithoutBillsInput[] | paymentsUncheckedCreateWithoutBillsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBillsInput | paymentsCreateOrConnectWithoutBillsInput[]
    createMany?: paymentsCreateManyBillsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type meter_readingsUncheckedCreateNestedManyWithoutBillsInput = {
    create?: XOR<meter_readingsCreateWithoutBillsInput, meter_readingsUncheckedCreateWithoutBillsInput> | meter_readingsCreateWithoutBillsInput[] | meter_readingsUncheckedCreateWithoutBillsInput[]
    connectOrCreate?: meter_readingsCreateOrConnectWithoutBillsInput | meter_readingsCreateOrConnectWithoutBillsInput[]
    createMany?: meter_readingsCreateManyBillsInputEnvelope
    connect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutBillsInput = {
    create?: XOR<paymentsCreateWithoutBillsInput, paymentsUncheckedCreateWithoutBillsInput> | paymentsCreateWithoutBillsInput[] | paymentsUncheckedCreateWithoutBillsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBillsInput | paymentsCreateOrConnectWithoutBillsInput[]
    createMany?: paymentsCreateManyBillsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBillStatusFieldUpdateOperationsInput = {
    set?: $Enums.BillStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type consumersUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<consumersCreateWithoutBillsInput, consumersUncheckedCreateWithoutBillsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutBillsInput
    upsert?: consumersUpsertWithoutBillsInput
    connect?: consumersWhereUniqueInput
    update?: XOR<XOR<consumersUpdateToOneWithWhereWithoutBillsInput, consumersUpdateWithoutBillsInput>, consumersUncheckedUpdateWithoutBillsInput>
  }

  export type metersUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<metersCreateWithoutBillsInput, metersUncheckedCreateWithoutBillsInput>
    connectOrCreate?: metersCreateOrConnectWithoutBillsInput
    upsert?: metersUpsertWithoutBillsInput
    connect?: metersWhereUniqueInput
    update?: XOR<XOR<metersUpdateToOneWithWhereWithoutBillsInput, metersUpdateWithoutBillsInput>, metersUncheckedUpdateWithoutBillsInput>
  }

  export type meter_readingsUpdateManyWithoutBillsNestedInput = {
    create?: XOR<meter_readingsCreateWithoutBillsInput, meter_readingsUncheckedCreateWithoutBillsInput> | meter_readingsCreateWithoutBillsInput[] | meter_readingsUncheckedCreateWithoutBillsInput[]
    connectOrCreate?: meter_readingsCreateOrConnectWithoutBillsInput | meter_readingsCreateOrConnectWithoutBillsInput[]
    upsert?: meter_readingsUpsertWithWhereUniqueWithoutBillsInput | meter_readingsUpsertWithWhereUniqueWithoutBillsInput[]
    createMany?: meter_readingsCreateManyBillsInputEnvelope
    set?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    disconnect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    delete?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    connect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    update?: meter_readingsUpdateWithWhereUniqueWithoutBillsInput | meter_readingsUpdateWithWhereUniqueWithoutBillsInput[]
    updateMany?: meter_readingsUpdateManyWithWhereWithoutBillsInput | meter_readingsUpdateManyWithWhereWithoutBillsInput[]
    deleteMany?: meter_readingsScalarWhereInput | meter_readingsScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutBillsNestedInput = {
    create?: XOR<paymentsCreateWithoutBillsInput, paymentsUncheckedCreateWithoutBillsInput> | paymentsCreateWithoutBillsInput[] | paymentsUncheckedCreateWithoutBillsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBillsInput | paymentsCreateOrConnectWithoutBillsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutBillsInput | paymentsUpsertWithWhereUniqueWithoutBillsInput[]
    createMany?: paymentsCreateManyBillsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutBillsInput | paymentsUpdateWithWhereUniqueWithoutBillsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutBillsInput | paymentsUpdateManyWithWhereWithoutBillsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type meter_readingsUncheckedUpdateManyWithoutBillsNestedInput = {
    create?: XOR<meter_readingsCreateWithoutBillsInput, meter_readingsUncheckedCreateWithoutBillsInput> | meter_readingsCreateWithoutBillsInput[] | meter_readingsUncheckedCreateWithoutBillsInput[]
    connectOrCreate?: meter_readingsCreateOrConnectWithoutBillsInput | meter_readingsCreateOrConnectWithoutBillsInput[]
    upsert?: meter_readingsUpsertWithWhereUniqueWithoutBillsInput | meter_readingsUpsertWithWhereUniqueWithoutBillsInput[]
    createMany?: meter_readingsCreateManyBillsInputEnvelope
    set?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    disconnect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    delete?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    connect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    update?: meter_readingsUpdateWithWhereUniqueWithoutBillsInput | meter_readingsUpdateWithWhereUniqueWithoutBillsInput[]
    updateMany?: meter_readingsUpdateManyWithWhereWithoutBillsInput | meter_readingsUpdateManyWithWhereWithoutBillsInput[]
    deleteMany?: meter_readingsScalarWhereInput | meter_readingsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutBillsNestedInput = {
    create?: XOR<paymentsCreateWithoutBillsInput, paymentsUncheckedCreateWithoutBillsInput> | paymentsCreateWithoutBillsInput[] | paymentsUncheckedCreateWithoutBillsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBillsInput | paymentsCreateOrConnectWithoutBillsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutBillsInput | paymentsUpsertWithWhereUniqueWithoutBillsInput[]
    createMany?: paymentsCreateManyBillsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutBillsInput | paymentsUpdateWithWhereUniqueWithoutBillsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutBillsInput | paymentsUpdateManyWithWhereWithoutBillsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type consumersCreateNestedOneWithoutConsumer_documentsInput = {
    create?: XOR<consumersCreateWithoutConsumer_documentsInput, consumersUncheckedCreateWithoutConsumer_documentsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutConsumer_documentsInput
    connect?: consumersWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type consumersUpdateOneRequiredWithoutConsumer_documentsNestedInput = {
    create?: XOR<consumersCreateWithoutConsumer_documentsInput, consumersUncheckedCreateWithoutConsumer_documentsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutConsumer_documentsInput
    upsert?: consumersUpsertWithoutConsumer_documentsInput
    connect?: consumersWhereUniqueInput
    update?: XOR<XOR<consumersUpdateToOneWithWhereWithoutConsumer_documentsInput, consumersUpdateWithoutConsumer_documentsInput>, consumersUncheckedUpdateWithoutConsumer_documentsInput>
  }

  export type consumersCreatebillDeliveryModeInput = {
    set: $Enums.BillDeliveryMode[]
  }

  export type billsCreateNestedManyWithoutConsumersInput = {
    create?: XOR<billsCreateWithoutConsumersInput, billsUncheckedCreateWithoutConsumersInput> | billsCreateWithoutConsumersInput[] | billsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: billsCreateOrConnectWithoutConsumersInput | billsCreateOrConnectWithoutConsumersInput[]
    createMany?: billsCreateManyConsumersInputEnvelope
    connect?: billsWhereUniqueInput | billsWhereUniqueInput[]
  }

  export type consumer_documentsCreateNestedManyWithoutConsumersInput = {
    create?: XOR<consumer_documentsCreateWithoutConsumersInput, consumer_documentsUncheckedCreateWithoutConsumersInput> | consumer_documentsCreateWithoutConsumersInput[] | consumer_documentsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: consumer_documentsCreateOrConnectWithoutConsumersInput | consumer_documentsCreateOrConnectWithoutConsumersInput[]
    createMany?: consumer_documentsCreateManyConsumersInputEnvelope
    connect?: consumer_documentsWhereUniqueInput | consumer_documentsWhereUniqueInput[]
  }

  export type locationsCreateNestedOneWithoutConsumersInput = {
    create?: XOR<locationsCreateWithoutConsumersInput, locationsUncheckedCreateWithoutConsumersInput>
    connectOrCreate?: locationsCreateOrConnectWithoutConsumersInput
    connect?: locationsWhereUniqueInput
  }

  export type notificationsCreateNestedManyWithoutConsumersInput = {
    create?: XOR<notificationsCreateWithoutConsumersInput, notificationsUncheckedCreateWithoutConsumersInput> | notificationsCreateWithoutConsumersInput[] | notificationsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutConsumersInput | notificationsCreateOrConnectWithoutConsumersInput[]
    createMany?: notificationsCreateManyConsumersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type prepaid_accountsCreateNestedOneWithoutConsumersInput = {
    create?: XOR<prepaid_accountsCreateWithoutConsumersInput, prepaid_accountsUncheckedCreateWithoutConsumersInput>
    connectOrCreate?: prepaid_accountsCreateOrConnectWithoutConsumersInput
    connect?: prepaid_accountsWhereUniqueInput
  }

  export type billsUncheckedCreateNestedManyWithoutConsumersInput = {
    create?: XOR<billsCreateWithoutConsumersInput, billsUncheckedCreateWithoutConsumersInput> | billsCreateWithoutConsumersInput[] | billsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: billsCreateOrConnectWithoutConsumersInput | billsCreateOrConnectWithoutConsumersInput[]
    createMany?: billsCreateManyConsumersInputEnvelope
    connect?: billsWhereUniqueInput | billsWhereUniqueInput[]
  }

  export type consumer_documentsUncheckedCreateNestedManyWithoutConsumersInput = {
    create?: XOR<consumer_documentsCreateWithoutConsumersInput, consumer_documentsUncheckedCreateWithoutConsumersInput> | consumer_documentsCreateWithoutConsumersInput[] | consumer_documentsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: consumer_documentsCreateOrConnectWithoutConsumersInput | consumer_documentsCreateOrConnectWithoutConsumersInput[]
    createMany?: consumer_documentsCreateManyConsumersInputEnvelope
    connect?: consumer_documentsWhereUniqueInput | consumer_documentsWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutConsumersInput = {
    create?: XOR<notificationsCreateWithoutConsumersInput, notificationsUncheckedCreateWithoutConsumersInput> | notificationsCreateWithoutConsumersInput[] | notificationsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutConsumersInput | notificationsCreateOrConnectWithoutConsumersInput[]
    createMany?: notificationsCreateManyConsumersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type prepaid_accountsUncheckedCreateNestedOneWithoutConsumersInput = {
    create?: XOR<prepaid_accountsCreateWithoutConsumersInput, prepaid_accountsUncheckedCreateWithoutConsumersInput>
    connectOrCreate?: prepaid_accountsCreateOrConnectWithoutConsumersInput
    connect?: prepaid_accountsWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumIdTypeFieldUpdateOperationsInput = {
    set?: $Enums.IdType
  }

  export type EnumConnectionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConnectionType
  }

  export type EnumConsumerCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ConsumerCategory
  }

  export type EnumBillingCycleFieldUpdateOperationsInput = {
    set?: $Enums.BillingCycle
  }

  export type consumersUpdatebillDeliveryModeInput = {
    set?: $Enums.BillDeliveryMode[]
    push?: $Enums.BillDeliveryMode | $Enums.BillDeliveryMode[]
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type billsUpdateManyWithoutConsumersNestedInput = {
    create?: XOR<billsCreateWithoutConsumersInput, billsUncheckedCreateWithoutConsumersInput> | billsCreateWithoutConsumersInput[] | billsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: billsCreateOrConnectWithoutConsumersInput | billsCreateOrConnectWithoutConsumersInput[]
    upsert?: billsUpsertWithWhereUniqueWithoutConsumersInput | billsUpsertWithWhereUniqueWithoutConsumersInput[]
    createMany?: billsCreateManyConsumersInputEnvelope
    set?: billsWhereUniqueInput | billsWhereUniqueInput[]
    disconnect?: billsWhereUniqueInput | billsWhereUniqueInput[]
    delete?: billsWhereUniqueInput | billsWhereUniqueInput[]
    connect?: billsWhereUniqueInput | billsWhereUniqueInput[]
    update?: billsUpdateWithWhereUniqueWithoutConsumersInput | billsUpdateWithWhereUniqueWithoutConsumersInput[]
    updateMany?: billsUpdateManyWithWhereWithoutConsumersInput | billsUpdateManyWithWhereWithoutConsumersInput[]
    deleteMany?: billsScalarWhereInput | billsScalarWhereInput[]
  }

  export type consumer_documentsUpdateManyWithoutConsumersNestedInput = {
    create?: XOR<consumer_documentsCreateWithoutConsumersInput, consumer_documentsUncheckedCreateWithoutConsumersInput> | consumer_documentsCreateWithoutConsumersInput[] | consumer_documentsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: consumer_documentsCreateOrConnectWithoutConsumersInput | consumer_documentsCreateOrConnectWithoutConsumersInput[]
    upsert?: consumer_documentsUpsertWithWhereUniqueWithoutConsumersInput | consumer_documentsUpsertWithWhereUniqueWithoutConsumersInput[]
    createMany?: consumer_documentsCreateManyConsumersInputEnvelope
    set?: consumer_documentsWhereUniqueInput | consumer_documentsWhereUniqueInput[]
    disconnect?: consumer_documentsWhereUniqueInput | consumer_documentsWhereUniqueInput[]
    delete?: consumer_documentsWhereUniqueInput | consumer_documentsWhereUniqueInput[]
    connect?: consumer_documentsWhereUniqueInput | consumer_documentsWhereUniqueInput[]
    update?: consumer_documentsUpdateWithWhereUniqueWithoutConsumersInput | consumer_documentsUpdateWithWhereUniqueWithoutConsumersInput[]
    updateMany?: consumer_documentsUpdateManyWithWhereWithoutConsumersInput | consumer_documentsUpdateManyWithWhereWithoutConsumersInput[]
    deleteMany?: consumer_documentsScalarWhereInput | consumer_documentsScalarWhereInput[]
  }

  export type locationsUpdateOneRequiredWithoutConsumersNestedInput = {
    create?: XOR<locationsCreateWithoutConsumersInput, locationsUncheckedCreateWithoutConsumersInput>
    connectOrCreate?: locationsCreateOrConnectWithoutConsumersInput
    upsert?: locationsUpsertWithoutConsumersInput
    connect?: locationsWhereUniqueInput
    update?: XOR<XOR<locationsUpdateToOneWithWhereWithoutConsumersInput, locationsUpdateWithoutConsumersInput>, locationsUncheckedUpdateWithoutConsumersInput>
  }

  export type notificationsUpdateManyWithoutConsumersNestedInput = {
    create?: XOR<notificationsCreateWithoutConsumersInput, notificationsUncheckedCreateWithoutConsumersInput> | notificationsCreateWithoutConsumersInput[] | notificationsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutConsumersInput | notificationsCreateOrConnectWithoutConsumersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutConsumersInput | notificationsUpsertWithWhereUniqueWithoutConsumersInput[]
    createMany?: notificationsCreateManyConsumersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutConsumersInput | notificationsUpdateWithWhereUniqueWithoutConsumersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutConsumersInput | notificationsUpdateManyWithWhereWithoutConsumersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type prepaid_accountsUpdateOneWithoutConsumersNestedInput = {
    create?: XOR<prepaid_accountsCreateWithoutConsumersInput, prepaid_accountsUncheckedCreateWithoutConsumersInput>
    connectOrCreate?: prepaid_accountsCreateOrConnectWithoutConsumersInput
    upsert?: prepaid_accountsUpsertWithoutConsumersInput
    disconnect?: prepaid_accountsWhereInput | boolean
    delete?: prepaid_accountsWhereInput | boolean
    connect?: prepaid_accountsWhereUniqueInput
    update?: XOR<XOR<prepaid_accountsUpdateToOneWithWhereWithoutConsumersInput, prepaid_accountsUpdateWithoutConsumersInput>, prepaid_accountsUncheckedUpdateWithoutConsumersInput>
  }

  export type billsUncheckedUpdateManyWithoutConsumersNestedInput = {
    create?: XOR<billsCreateWithoutConsumersInput, billsUncheckedCreateWithoutConsumersInput> | billsCreateWithoutConsumersInput[] | billsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: billsCreateOrConnectWithoutConsumersInput | billsCreateOrConnectWithoutConsumersInput[]
    upsert?: billsUpsertWithWhereUniqueWithoutConsumersInput | billsUpsertWithWhereUniqueWithoutConsumersInput[]
    createMany?: billsCreateManyConsumersInputEnvelope
    set?: billsWhereUniqueInput | billsWhereUniqueInput[]
    disconnect?: billsWhereUniqueInput | billsWhereUniqueInput[]
    delete?: billsWhereUniqueInput | billsWhereUniqueInput[]
    connect?: billsWhereUniqueInput | billsWhereUniqueInput[]
    update?: billsUpdateWithWhereUniqueWithoutConsumersInput | billsUpdateWithWhereUniqueWithoutConsumersInput[]
    updateMany?: billsUpdateManyWithWhereWithoutConsumersInput | billsUpdateManyWithWhereWithoutConsumersInput[]
    deleteMany?: billsScalarWhereInput | billsScalarWhereInput[]
  }

  export type consumer_documentsUncheckedUpdateManyWithoutConsumersNestedInput = {
    create?: XOR<consumer_documentsCreateWithoutConsumersInput, consumer_documentsUncheckedCreateWithoutConsumersInput> | consumer_documentsCreateWithoutConsumersInput[] | consumer_documentsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: consumer_documentsCreateOrConnectWithoutConsumersInput | consumer_documentsCreateOrConnectWithoutConsumersInput[]
    upsert?: consumer_documentsUpsertWithWhereUniqueWithoutConsumersInput | consumer_documentsUpsertWithWhereUniqueWithoutConsumersInput[]
    createMany?: consumer_documentsCreateManyConsumersInputEnvelope
    set?: consumer_documentsWhereUniqueInput | consumer_documentsWhereUniqueInput[]
    disconnect?: consumer_documentsWhereUniqueInput | consumer_documentsWhereUniqueInput[]
    delete?: consumer_documentsWhereUniqueInput | consumer_documentsWhereUniqueInput[]
    connect?: consumer_documentsWhereUniqueInput | consumer_documentsWhereUniqueInput[]
    update?: consumer_documentsUpdateWithWhereUniqueWithoutConsumersInput | consumer_documentsUpdateWithWhereUniqueWithoutConsumersInput[]
    updateMany?: consumer_documentsUpdateManyWithWhereWithoutConsumersInput | consumer_documentsUpdateManyWithWhereWithoutConsumersInput[]
    deleteMany?: consumer_documentsScalarWhereInput | consumer_documentsScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutConsumersNestedInput = {
    create?: XOR<notificationsCreateWithoutConsumersInput, notificationsUncheckedCreateWithoutConsumersInput> | notificationsCreateWithoutConsumersInput[] | notificationsUncheckedCreateWithoutConsumersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutConsumersInput | notificationsCreateOrConnectWithoutConsumersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutConsumersInput | notificationsUpsertWithWhereUniqueWithoutConsumersInput[]
    createMany?: notificationsCreateManyConsumersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutConsumersInput | notificationsUpdateWithWhereUniqueWithoutConsumersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutConsumersInput | notificationsUpdateManyWithWhereWithoutConsumersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type prepaid_accountsUncheckedUpdateOneWithoutConsumersNestedInput = {
    create?: XOR<prepaid_accountsCreateWithoutConsumersInput, prepaid_accountsUncheckedCreateWithoutConsumersInput>
    connectOrCreate?: prepaid_accountsCreateOrConnectWithoutConsumersInput
    upsert?: prepaid_accountsUpsertWithoutConsumersInput
    disconnect?: prepaid_accountsWhereInput | boolean
    delete?: prepaid_accountsWhereInput | boolean
    connect?: prepaid_accountsWhereUniqueInput
    update?: XOR<XOR<prepaid_accountsUpdateToOneWithWhereWithoutConsumersInput, prepaid_accountsUpdateWithoutConsumersInput>, prepaid_accountsUncheckedUpdateWithoutConsumersInput>
  }

  export type metersCreateNestedOneWithoutCurrent_transformersInput = {
    create?: XOR<metersCreateWithoutCurrent_transformersInput, metersUncheckedCreateWithoutCurrent_transformersInput>
    connectOrCreate?: metersCreateOrConnectWithoutCurrent_transformersInput
    connect?: metersWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type metersUpdateOneRequiredWithoutCurrent_transformersNestedInput = {
    create?: XOR<metersCreateWithoutCurrent_transformersInput, metersUncheckedCreateWithoutCurrent_transformersInput>
    connectOrCreate?: metersCreateOrConnectWithoutCurrent_transformersInput
    upsert?: metersUpsertWithoutCurrent_transformersInput
    connect?: metersWhereUniqueInput
    update?: XOR<XOR<metersUpdateToOneWithWhereWithoutCurrent_transformersInput, metersUpdateWithoutCurrent_transformersInput>, metersUncheckedUpdateWithoutCurrent_transformersInput>
  }

  export type departmentsCreateNestedOneWithoutChildrenInput = {
    create?: XOR<departmentsCreateWithoutChildrenInput, departmentsUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutChildrenInput
    connect?: departmentsWhereUniqueInput
  }

  export type departmentsCreateNestedManyWithoutParentInput = {
    create?: XOR<departmentsCreateWithoutParentInput, departmentsUncheckedCreateWithoutParentInput> | departmentsCreateWithoutParentInput[] | departmentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: departmentsCreateOrConnectWithoutParentInput | departmentsCreateOrConnectWithoutParentInput[]
    createMany?: departmentsCreateManyParentInputEnvelope
    connect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<usersCreateWithoutDepartmentsInput, usersUncheckedCreateWithoutDepartmentsInput> | usersCreateWithoutDepartmentsInput[] | usersUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutDepartmentsInput | usersCreateOrConnectWithoutDepartmentsInput[]
    createMany?: usersCreateManyDepartmentsInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type departmentsUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<departmentsCreateWithoutParentInput, departmentsUncheckedCreateWithoutParentInput> | departmentsCreateWithoutParentInput[] | departmentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: departmentsCreateOrConnectWithoutParentInput | departmentsCreateOrConnectWithoutParentInput[]
    createMany?: departmentsCreateManyParentInputEnvelope
    connect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutDepartmentsInput = {
    create?: XOR<usersCreateWithoutDepartmentsInput, usersUncheckedCreateWithoutDepartmentsInput> | usersCreateWithoutDepartmentsInput[] | usersUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutDepartmentsInput | usersCreateOrConnectWithoutDepartmentsInput[]
    createMany?: usersCreateManyDepartmentsInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type departmentsUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<departmentsCreateWithoutChildrenInput, departmentsUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutChildrenInput
    upsert?: departmentsUpsertWithoutChildrenInput
    disconnect?: departmentsWhereInput | boolean
    delete?: departmentsWhereInput | boolean
    connect?: departmentsWhereUniqueInput
    update?: XOR<XOR<departmentsUpdateToOneWithWhereWithoutChildrenInput, departmentsUpdateWithoutChildrenInput>, departmentsUncheckedUpdateWithoutChildrenInput>
  }

  export type departmentsUpdateManyWithoutParentNestedInput = {
    create?: XOR<departmentsCreateWithoutParentInput, departmentsUncheckedCreateWithoutParentInput> | departmentsCreateWithoutParentInput[] | departmentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: departmentsCreateOrConnectWithoutParentInput | departmentsCreateOrConnectWithoutParentInput[]
    upsert?: departmentsUpsertWithWhereUniqueWithoutParentInput | departmentsUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: departmentsCreateManyParentInputEnvelope
    set?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    disconnect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    delete?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    connect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    update?: departmentsUpdateWithWhereUniqueWithoutParentInput | departmentsUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: departmentsUpdateManyWithWhereWithoutParentInput | departmentsUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: departmentsScalarWhereInput | departmentsScalarWhereInput[]
  }

  export type usersUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<usersCreateWithoutDepartmentsInput, usersUncheckedCreateWithoutDepartmentsInput> | usersCreateWithoutDepartmentsInput[] | usersUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutDepartmentsInput | usersCreateOrConnectWithoutDepartmentsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutDepartmentsInput | usersUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: usersCreateManyDepartmentsInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutDepartmentsInput | usersUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutDepartmentsInput | usersUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type departmentsUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<departmentsCreateWithoutParentInput, departmentsUncheckedCreateWithoutParentInput> | departmentsCreateWithoutParentInput[] | departmentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: departmentsCreateOrConnectWithoutParentInput | departmentsCreateOrConnectWithoutParentInput[]
    upsert?: departmentsUpsertWithWhereUniqueWithoutParentInput | departmentsUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: departmentsCreateManyParentInputEnvelope
    set?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    disconnect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    delete?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    connect?: departmentsWhereUniqueInput | departmentsWhereUniqueInput[]
    update?: departmentsUpdateWithWhereUniqueWithoutParentInput | departmentsUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: departmentsUpdateManyWithWhereWithoutParentInput | departmentsUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: departmentsScalarWhereInput | departmentsScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutDepartmentsNestedInput = {
    create?: XOR<usersCreateWithoutDepartmentsInput, usersUncheckedCreateWithoutDepartmentsInput> | usersCreateWithoutDepartmentsInput[] | usersUncheckedCreateWithoutDepartmentsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutDepartmentsInput | usersCreateOrConnectWithoutDepartmentsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutDepartmentsInput | usersUpsertWithWhereUniqueWithoutDepartmentsInput[]
    createMany?: usersCreateManyDepartmentsInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutDepartmentsInput | usersUpdateWithWhereUniqueWithoutDepartmentsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutDepartmentsInput | usersUpdateManyWithWhereWithoutDepartmentsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type dtrsCreateNestedOneWithoutDtr_faultsInput = {
    create?: XOR<dtrsCreateWithoutDtr_faultsInput, dtrsUncheckedCreateWithoutDtr_faultsInput>
    connectOrCreate?: dtrsCreateOrConnectWithoutDtr_faultsInput
    connect?: dtrsWhereUniqueInput
  }

  export type EnumFaultTypeFieldUpdateOperationsInput = {
    set?: $Enums.FaultType
  }

  export type EnumFaultSeverityFieldUpdateOperationsInput = {
    set?: $Enums.FaultSeverity
  }

  export type EnumFaultStatusFieldUpdateOperationsInput = {
    set?: $Enums.FaultStatus
  }

  export type dtrsUpdateOneRequiredWithoutDtr_faultsNestedInput = {
    create?: XOR<dtrsCreateWithoutDtr_faultsInput, dtrsUncheckedCreateWithoutDtr_faultsInput>
    connectOrCreate?: dtrsCreateOrConnectWithoutDtr_faultsInput
    upsert?: dtrsUpsertWithoutDtr_faultsInput
    connect?: dtrsWhereUniqueInput
    update?: XOR<XOR<dtrsUpdateToOneWithWhereWithoutDtr_faultsInput, dtrsUpdateWithoutDtr_faultsInput>, dtrsUncheckedUpdateWithoutDtr_faultsInput>
  }

  export type dtrsCreateNestedOneWithoutDtr_maintenanceInput = {
    create?: XOR<dtrsCreateWithoutDtr_maintenanceInput, dtrsUncheckedCreateWithoutDtr_maintenanceInput>
    connectOrCreate?: dtrsCreateOrConnectWithoutDtr_maintenanceInput
    connect?: dtrsWhereUniqueInput
  }

  export type EnumMaintenanceTypeFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceType
  }

  export type EnumMaintenanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceStatus
  }

  export type dtrsUpdateOneRequiredWithoutDtr_maintenanceNestedInput = {
    create?: XOR<dtrsCreateWithoutDtr_maintenanceInput, dtrsUncheckedCreateWithoutDtr_maintenanceInput>
    connectOrCreate?: dtrsCreateOrConnectWithoutDtr_maintenanceInput
    upsert?: dtrsUpsertWithoutDtr_maintenanceInput
    connect?: dtrsWhereUniqueInput
    update?: XOR<XOR<dtrsUpdateToOneWithWhereWithoutDtr_maintenanceInput, dtrsUpdateWithoutDtr_maintenanceInput>, dtrsUncheckedUpdateWithoutDtr_maintenanceInput>
  }

  export type dtrsCreateNestedOneWithoutDtr_readingsInput = {
    create?: XOR<dtrsCreateWithoutDtr_readingsInput, dtrsUncheckedCreateWithoutDtr_readingsInput>
    connectOrCreate?: dtrsCreateOrConnectWithoutDtr_readingsInput
    connect?: dtrsWhereUniqueInput
  }

  export type EnumDTRReadingTypeFieldUpdateOperationsInput = {
    set?: $Enums.DTRReadingType
  }

  export type dtrsUpdateOneRequiredWithoutDtr_readingsNestedInput = {
    create?: XOR<dtrsCreateWithoutDtr_readingsInput, dtrsUncheckedCreateWithoutDtr_readingsInput>
    connectOrCreate?: dtrsCreateOrConnectWithoutDtr_readingsInput
    upsert?: dtrsUpsertWithoutDtr_readingsInput
    connect?: dtrsWhereUniqueInput
    update?: XOR<XOR<dtrsUpdateToOneWithWhereWithoutDtr_readingsInput, dtrsUpdateWithoutDtr_readingsInput>, dtrsUncheckedUpdateWithoutDtr_readingsInput>
  }

  export type dtr_faultsCreateNestedManyWithoutDtrsInput = {
    create?: XOR<dtr_faultsCreateWithoutDtrsInput, dtr_faultsUncheckedCreateWithoutDtrsInput> | dtr_faultsCreateWithoutDtrsInput[] | dtr_faultsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_faultsCreateOrConnectWithoutDtrsInput | dtr_faultsCreateOrConnectWithoutDtrsInput[]
    createMany?: dtr_faultsCreateManyDtrsInputEnvelope
    connect?: dtr_faultsWhereUniqueInput | dtr_faultsWhereUniqueInput[]
  }

  export type dtr_maintenanceCreateNestedManyWithoutDtrsInput = {
    create?: XOR<dtr_maintenanceCreateWithoutDtrsInput, dtr_maintenanceUncheckedCreateWithoutDtrsInput> | dtr_maintenanceCreateWithoutDtrsInput[] | dtr_maintenanceUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_maintenanceCreateOrConnectWithoutDtrsInput | dtr_maintenanceCreateOrConnectWithoutDtrsInput[]
    createMany?: dtr_maintenanceCreateManyDtrsInputEnvelope
    connect?: dtr_maintenanceWhereUniqueInput | dtr_maintenanceWhereUniqueInput[]
  }

  export type dtr_readingsCreateNestedManyWithoutDtrsInput = {
    create?: XOR<dtr_readingsCreateWithoutDtrsInput, dtr_readingsUncheckedCreateWithoutDtrsInput> | dtr_readingsCreateWithoutDtrsInput[] | dtr_readingsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_readingsCreateOrConnectWithoutDtrsInput | dtr_readingsCreateOrConnectWithoutDtrsInput[]
    createMany?: dtr_readingsCreateManyDtrsInputEnvelope
    connect?: dtr_readingsWhereUniqueInput | dtr_readingsWhereUniqueInput[]
  }

  export type locationsCreateNestedOneWithoutDtrsInput = {
    create?: XOR<locationsCreateWithoutDtrsInput, locationsUncheckedCreateWithoutDtrsInput>
    connectOrCreate?: locationsCreateOrConnectWithoutDtrsInput
    connect?: locationsWhereUniqueInput
  }

  export type metersCreateNestedManyWithoutDtrsInput = {
    create?: XOR<metersCreateWithoutDtrsInput, metersUncheckedCreateWithoutDtrsInput> | metersCreateWithoutDtrsInput[] | metersUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: metersCreateOrConnectWithoutDtrsInput | metersCreateOrConnectWithoutDtrsInput[]
    createMany?: metersCreateManyDtrsInputEnvelope
    connect?: metersWhereUniqueInput | metersWhereUniqueInput[]
  }

  export type ticketsCreateNestedManyWithoutDtrsInput = {
    create?: XOR<ticketsCreateWithoutDtrsInput, ticketsUncheckedCreateWithoutDtrsInput> | ticketsCreateWithoutDtrsInput[] | ticketsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutDtrsInput | ticketsCreateOrConnectWithoutDtrsInput[]
    createMany?: ticketsCreateManyDtrsInputEnvelope
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
  }

  export type dtr_faultsUncheckedCreateNestedManyWithoutDtrsInput = {
    create?: XOR<dtr_faultsCreateWithoutDtrsInput, dtr_faultsUncheckedCreateWithoutDtrsInput> | dtr_faultsCreateWithoutDtrsInput[] | dtr_faultsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_faultsCreateOrConnectWithoutDtrsInput | dtr_faultsCreateOrConnectWithoutDtrsInput[]
    createMany?: dtr_faultsCreateManyDtrsInputEnvelope
    connect?: dtr_faultsWhereUniqueInput | dtr_faultsWhereUniqueInput[]
  }

  export type dtr_maintenanceUncheckedCreateNestedManyWithoutDtrsInput = {
    create?: XOR<dtr_maintenanceCreateWithoutDtrsInput, dtr_maintenanceUncheckedCreateWithoutDtrsInput> | dtr_maintenanceCreateWithoutDtrsInput[] | dtr_maintenanceUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_maintenanceCreateOrConnectWithoutDtrsInput | dtr_maintenanceCreateOrConnectWithoutDtrsInput[]
    createMany?: dtr_maintenanceCreateManyDtrsInputEnvelope
    connect?: dtr_maintenanceWhereUniqueInput | dtr_maintenanceWhereUniqueInput[]
  }

  export type dtr_readingsUncheckedCreateNestedManyWithoutDtrsInput = {
    create?: XOR<dtr_readingsCreateWithoutDtrsInput, dtr_readingsUncheckedCreateWithoutDtrsInput> | dtr_readingsCreateWithoutDtrsInput[] | dtr_readingsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_readingsCreateOrConnectWithoutDtrsInput | dtr_readingsCreateOrConnectWithoutDtrsInput[]
    createMany?: dtr_readingsCreateManyDtrsInputEnvelope
    connect?: dtr_readingsWhereUniqueInput | dtr_readingsWhereUniqueInput[]
  }

  export type metersUncheckedCreateNestedManyWithoutDtrsInput = {
    create?: XOR<metersCreateWithoutDtrsInput, metersUncheckedCreateWithoutDtrsInput> | metersCreateWithoutDtrsInput[] | metersUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: metersCreateOrConnectWithoutDtrsInput | metersCreateOrConnectWithoutDtrsInput[]
    createMany?: metersCreateManyDtrsInputEnvelope
    connect?: metersWhereUniqueInput | metersWhereUniqueInput[]
  }

  export type ticketsUncheckedCreateNestedManyWithoutDtrsInput = {
    create?: XOR<ticketsCreateWithoutDtrsInput, ticketsUncheckedCreateWithoutDtrsInput> | ticketsCreateWithoutDtrsInput[] | ticketsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutDtrsInput | ticketsCreateOrConnectWithoutDtrsInput[]
    createMany?: ticketsCreateManyDtrsInputEnvelope
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
  }

  export type EnumDTRTypeFieldUpdateOperationsInput = {
    set?: $Enums.DTRType
  }

  export type EnumCoolingTypeFieldUpdateOperationsInput = {
    set?: $Enums.CoolingType
  }

  export type NullableEnumOilTypeFieldUpdateOperationsInput = {
    set?: $Enums.OilType | null
  }

  export type EnumDTRStatusFieldUpdateOperationsInput = {
    set?: $Enums.DTRStatus
  }

  export type dtr_faultsUpdateManyWithoutDtrsNestedInput = {
    create?: XOR<dtr_faultsCreateWithoutDtrsInput, dtr_faultsUncheckedCreateWithoutDtrsInput> | dtr_faultsCreateWithoutDtrsInput[] | dtr_faultsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_faultsCreateOrConnectWithoutDtrsInput | dtr_faultsCreateOrConnectWithoutDtrsInput[]
    upsert?: dtr_faultsUpsertWithWhereUniqueWithoutDtrsInput | dtr_faultsUpsertWithWhereUniqueWithoutDtrsInput[]
    createMany?: dtr_faultsCreateManyDtrsInputEnvelope
    set?: dtr_faultsWhereUniqueInput | dtr_faultsWhereUniqueInput[]
    disconnect?: dtr_faultsWhereUniqueInput | dtr_faultsWhereUniqueInput[]
    delete?: dtr_faultsWhereUniqueInput | dtr_faultsWhereUniqueInput[]
    connect?: dtr_faultsWhereUniqueInput | dtr_faultsWhereUniqueInput[]
    update?: dtr_faultsUpdateWithWhereUniqueWithoutDtrsInput | dtr_faultsUpdateWithWhereUniqueWithoutDtrsInput[]
    updateMany?: dtr_faultsUpdateManyWithWhereWithoutDtrsInput | dtr_faultsUpdateManyWithWhereWithoutDtrsInput[]
    deleteMany?: dtr_faultsScalarWhereInput | dtr_faultsScalarWhereInput[]
  }

  export type dtr_maintenanceUpdateManyWithoutDtrsNestedInput = {
    create?: XOR<dtr_maintenanceCreateWithoutDtrsInput, dtr_maintenanceUncheckedCreateWithoutDtrsInput> | dtr_maintenanceCreateWithoutDtrsInput[] | dtr_maintenanceUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_maintenanceCreateOrConnectWithoutDtrsInput | dtr_maintenanceCreateOrConnectWithoutDtrsInput[]
    upsert?: dtr_maintenanceUpsertWithWhereUniqueWithoutDtrsInput | dtr_maintenanceUpsertWithWhereUniqueWithoutDtrsInput[]
    createMany?: dtr_maintenanceCreateManyDtrsInputEnvelope
    set?: dtr_maintenanceWhereUniqueInput | dtr_maintenanceWhereUniqueInput[]
    disconnect?: dtr_maintenanceWhereUniqueInput | dtr_maintenanceWhereUniqueInput[]
    delete?: dtr_maintenanceWhereUniqueInput | dtr_maintenanceWhereUniqueInput[]
    connect?: dtr_maintenanceWhereUniqueInput | dtr_maintenanceWhereUniqueInput[]
    update?: dtr_maintenanceUpdateWithWhereUniqueWithoutDtrsInput | dtr_maintenanceUpdateWithWhereUniqueWithoutDtrsInput[]
    updateMany?: dtr_maintenanceUpdateManyWithWhereWithoutDtrsInput | dtr_maintenanceUpdateManyWithWhereWithoutDtrsInput[]
    deleteMany?: dtr_maintenanceScalarWhereInput | dtr_maintenanceScalarWhereInput[]
  }

  export type dtr_readingsUpdateManyWithoutDtrsNestedInput = {
    create?: XOR<dtr_readingsCreateWithoutDtrsInput, dtr_readingsUncheckedCreateWithoutDtrsInput> | dtr_readingsCreateWithoutDtrsInput[] | dtr_readingsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_readingsCreateOrConnectWithoutDtrsInput | dtr_readingsCreateOrConnectWithoutDtrsInput[]
    upsert?: dtr_readingsUpsertWithWhereUniqueWithoutDtrsInput | dtr_readingsUpsertWithWhereUniqueWithoutDtrsInput[]
    createMany?: dtr_readingsCreateManyDtrsInputEnvelope
    set?: dtr_readingsWhereUniqueInput | dtr_readingsWhereUniqueInput[]
    disconnect?: dtr_readingsWhereUniqueInput | dtr_readingsWhereUniqueInput[]
    delete?: dtr_readingsWhereUniqueInput | dtr_readingsWhereUniqueInput[]
    connect?: dtr_readingsWhereUniqueInput | dtr_readingsWhereUniqueInput[]
    update?: dtr_readingsUpdateWithWhereUniqueWithoutDtrsInput | dtr_readingsUpdateWithWhereUniqueWithoutDtrsInput[]
    updateMany?: dtr_readingsUpdateManyWithWhereWithoutDtrsInput | dtr_readingsUpdateManyWithWhereWithoutDtrsInput[]
    deleteMany?: dtr_readingsScalarWhereInput | dtr_readingsScalarWhereInput[]
  }

  export type locationsUpdateOneRequiredWithoutDtrsNestedInput = {
    create?: XOR<locationsCreateWithoutDtrsInput, locationsUncheckedCreateWithoutDtrsInput>
    connectOrCreate?: locationsCreateOrConnectWithoutDtrsInput
    upsert?: locationsUpsertWithoutDtrsInput
    connect?: locationsWhereUniqueInput
    update?: XOR<XOR<locationsUpdateToOneWithWhereWithoutDtrsInput, locationsUpdateWithoutDtrsInput>, locationsUncheckedUpdateWithoutDtrsInput>
  }

  export type metersUpdateManyWithoutDtrsNestedInput = {
    create?: XOR<metersCreateWithoutDtrsInput, metersUncheckedCreateWithoutDtrsInput> | metersCreateWithoutDtrsInput[] | metersUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: metersCreateOrConnectWithoutDtrsInput | metersCreateOrConnectWithoutDtrsInput[]
    upsert?: metersUpsertWithWhereUniqueWithoutDtrsInput | metersUpsertWithWhereUniqueWithoutDtrsInput[]
    createMany?: metersCreateManyDtrsInputEnvelope
    set?: metersWhereUniqueInput | metersWhereUniqueInput[]
    disconnect?: metersWhereUniqueInput | metersWhereUniqueInput[]
    delete?: metersWhereUniqueInput | metersWhereUniqueInput[]
    connect?: metersWhereUniqueInput | metersWhereUniqueInput[]
    update?: metersUpdateWithWhereUniqueWithoutDtrsInput | metersUpdateWithWhereUniqueWithoutDtrsInput[]
    updateMany?: metersUpdateManyWithWhereWithoutDtrsInput | metersUpdateManyWithWhereWithoutDtrsInput[]
    deleteMany?: metersScalarWhereInput | metersScalarWhereInput[]
  }

  export type ticketsUpdateManyWithoutDtrsNestedInput = {
    create?: XOR<ticketsCreateWithoutDtrsInput, ticketsUncheckedCreateWithoutDtrsInput> | ticketsCreateWithoutDtrsInput[] | ticketsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutDtrsInput | ticketsCreateOrConnectWithoutDtrsInput[]
    upsert?: ticketsUpsertWithWhereUniqueWithoutDtrsInput | ticketsUpsertWithWhereUniqueWithoutDtrsInput[]
    createMany?: ticketsCreateManyDtrsInputEnvelope
    set?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    disconnect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    delete?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    update?: ticketsUpdateWithWhereUniqueWithoutDtrsInput | ticketsUpdateWithWhereUniqueWithoutDtrsInput[]
    updateMany?: ticketsUpdateManyWithWhereWithoutDtrsInput | ticketsUpdateManyWithWhereWithoutDtrsInput[]
    deleteMany?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
  }

  export type dtr_faultsUncheckedUpdateManyWithoutDtrsNestedInput = {
    create?: XOR<dtr_faultsCreateWithoutDtrsInput, dtr_faultsUncheckedCreateWithoutDtrsInput> | dtr_faultsCreateWithoutDtrsInput[] | dtr_faultsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_faultsCreateOrConnectWithoutDtrsInput | dtr_faultsCreateOrConnectWithoutDtrsInput[]
    upsert?: dtr_faultsUpsertWithWhereUniqueWithoutDtrsInput | dtr_faultsUpsertWithWhereUniqueWithoutDtrsInput[]
    createMany?: dtr_faultsCreateManyDtrsInputEnvelope
    set?: dtr_faultsWhereUniqueInput | dtr_faultsWhereUniqueInput[]
    disconnect?: dtr_faultsWhereUniqueInput | dtr_faultsWhereUniqueInput[]
    delete?: dtr_faultsWhereUniqueInput | dtr_faultsWhereUniqueInput[]
    connect?: dtr_faultsWhereUniqueInput | dtr_faultsWhereUniqueInput[]
    update?: dtr_faultsUpdateWithWhereUniqueWithoutDtrsInput | dtr_faultsUpdateWithWhereUniqueWithoutDtrsInput[]
    updateMany?: dtr_faultsUpdateManyWithWhereWithoutDtrsInput | dtr_faultsUpdateManyWithWhereWithoutDtrsInput[]
    deleteMany?: dtr_faultsScalarWhereInput | dtr_faultsScalarWhereInput[]
  }

  export type dtr_maintenanceUncheckedUpdateManyWithoutDtrsNestedInput = {
    create?: XOR<dtr_maintenanceCreateWithoutDtrsInput, dtr_maintenanceUncheckedCreateWithoutDtrsInput> | dtr_maintenanceCreateWithoutDtrsInput[] | dtr_maintenanceUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_maintenanceCreateOrConnectWithoutDtrsInput | dtr_maintenanceCreateOrConnectWithoutDtrsInput[]
    upsert?: dtr_maintenanceUpsertWithWhereUniqueWithoutDtrsInput | dtr_maintenanceUpsertWithWhereUniqueWithoutDtrsInput[]
    createMany?: dtr_maintenanceCreateManyDtrsInputEnvelope
    set?: dtr_maintenanceWhereUniqueInput | dtr_maintenanceWhereUniqueInput[]
    disconnect?: dtr_maintenanceWhereUniqueInput | dtr_maintenanceWhereUniqueInput[]
    delete?: dtr_maintenanceWhereUniqueInput | dtr_maintenanceWhereUniqueInput[]
    connect?: dtr_maintenanceWhereUniqueInput | dtr_maintenanceWhereUniqueInput[]
    update?: dtr_maintenanceUpdateWithWhereUniqueWithoutDtrsInput | dtr_maintenanceUpdateWithWhereUniqueWithoutDtrsInput[]
    updateMany?: dtr_maintenanceUpdateManyWithWhereWithoutDtrsInput | dtr_maintenanceUpdateManyWithWhereWithoutDtrsInput[]
    deleteMany?: dtr_maintenanceScalarWhereInput | dtr_maintenanceScalarWhereInput[]
  }

  export type dtr_readingsUncheckedUpdateManyWithoutDtrsNestedInput = {
    create?: XOR<dtr_readingsCreateWithoutDtrsInput, dtr_readingsUncheckedCreateWithoutDtrsInput> | dtr_readingsCreateWithoutDtrsInput[] | dtr_readingsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: dtr_readingsCreateOrConnectWithoutDtrsInput | dtr_readingsCreateOrConnectWithoutDtrsInput[]
    upsert?: dtr_readingsUpsertWithWhereUniqueWithoutDtrsInput | dtr_readingsUpsertWithWhereUniqueWithoutDtrsInput[]
    createMany?: dtr_readingsCreateManyDtrsInputEnvelope
    set?: dtr_readingsWhereUniqueInput | dtr_readingsWhereUniqueInput[]
    disconnect?: dtr_readingsWhereUniqueInput | dtr_readingsWhereUniqueInput[]
    delete?: dtr_readingsWhereUniqueInput | dtr_readingsWhereUniqueInput[]
    connect?: dtr_readingsWhereUniqueInput | dtr_readingsWhereUniqueInput[]
    update?: dtr_readingsUpdateWithWhereUniqueWithoutDtrsInput | dtr_readingsUpdateWithWhereUniqueWithoutDtrsInput[]
    updateMany?: dtr_readingsUpdateManyWithWhereWithoutDtrsInput | dtr_readingsUpdateManyWithWhereWithoutDtrsInput[]
    deleteMany?: dtr_readingsScalarWhereInput | dtr_readingsScalarWhereInput[]
  }

  export type metersUncheckedUpdateManyWithoutDtrsNestedInput = {
    create?: XOR<metersCreateWithoutDtrsInput, metersUncheckedCreateWithoutDtrsInput> | metersCreateWithoutDtrsInput[] | metersUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: metersCreateOrConnectWithoutDtrsInput | metersCreateOrConnectWithoutDtrsInput[]
    upsert?: metersUpsertWithWhereUniqueWithoutDtrsInput | metersUpsertWithWhereUniqueWithoutDtrsInput[]
    createMany?: metersCreateManyDtrsInputEnvelope
    set?: metersWhereUniqueInput | metersWhereUniqueInput[]
    disconnect?: metersWhereUniqueInput | metersWhereUniqueInput[]
    delete?: metersWhereUniqueInput | metersWhereUniqueInput[]
    connect?: metersWhereUniqueInput | metersWhereUniqueInput[]
    update?: metersUpdateWithWhereUniqueWithoutDtrsInput | metersUpdateWithWhereUniqueWithoutDtrsInput[]
    updateMany?: metersUpdateManyWithWhereWithoutDtrsInput | metersUpdateManyWithWhereWithoutDtrsInput[]
    deleteMany?: metersScalarWhereInput | metersScalarWhereInput[]
  }

  export type ticketsUncheckedUpdateManyWithoutDtrsNestedInput = {
    create?: XOR<ticketsCreateWithoutDtrsInput, ticketsUncheckedCreateWithoutDtrsInput> | ticketsCreateWithoutDtrsInput[] | ticketsUncheckedCreateWithoutDtrsInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutDtrsInput | ticketsCreateOrConnectWithoutDtrsInput[]
    upsert?: ticketsUpsertWithWhereUniqueWithoutDtrsInput | ticketsUpsertWithWhereUniqueWithoutDtrsInput[]
    createMany?: ticketsCreateManyDtrsInputEnvelope
    set?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    disconnect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    delete?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    update?: ticketsUpdateWithWhereUniqueWithoutDtrsInput | ticketsUpdateWithWhereUniqueWithoutDtrsInput[]
    updateMany?: ticketsUpdateManyWithWhereWithoutDtrsInput | ticketsUpdateManyWithWhereWithoutDtrsInput[]
    deleteMany?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
  }

  export type locationsCreateNestedManyWithoutLocation_typesInput = {
    create?: XOR<locationsCreateWithoutLocation_typesInput, locationsUncheckedCreateWithoutLocation_typesInput> | locationsCreateWithoutLocation_typesInput[] | locationsUncheckedCreateWithoutLocation_typesInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutLocation_typesInput | locationsCreateOrConnectWithoutLocation_typesInput[]
    createMany?: locationsCreateManyLocation_typesInputEnvelope
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
  }

  export type locationsUncheckedCreateNestedManyWithoutLocation_typesInput = {
    create?: XOR<locationsCreateWithoutLocation_typesInput, locationsUncheckedCreateWithoutLocation_typesInput> | locationsCreateWithoutLocation_typesInput[] | locationsUncheckedCreateWithoutLocation_typesInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutLocation_typesInput | locationsCreateOrConnectWithoutLocation_typesInput[]
    createMany?: locationsCreateManyLocation_typesInputEnvelope
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
  }

  export type locationsUpdateManyWithoutLocation_typesNestedInput = {
    create?: XOR<locationsCreateWithoutLocation_typesInput, locationsUncheckedCreateWithoutLocation_typesInput> | locationsCreateWithoutLocation_typesInput[] | locationsUncheckedCreateWithoutLocation_typesInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutLocation_typesInput | locationsCreateOrConnectWithoutLocation_typesInput[]
    upsert?: locationsUpsertWithWhereUniqueWithoutLocation_typesInput | locationsUpsertWithWhereUniqueWithoutLocation_typesInput[]
    createMany?: locationsCreateManyLocation_typesInputEnvelope
    set?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    disconnect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    delete?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    update?: locationsUpdateWithWhereUniqueWithoutLocation_typesInput | locationsUpdateWithWhereUniqueWithoutLocation_typesInput[]
    updateMany?: locationsUpdateManyWithWhereWithoutLocation_typesInput | locationsUpdateManyWithWhereWithoutLocation_typesInput[]
    deleteMany?: locationsScalarWhereInput | locationsScalarWhereInput[]
  }

  export type locationsUncheckedUpdateManyWithoutLocation_typesNestedInput = {
    create?: XOR<locationsCreateWithoutLocation_typesInput, locationsUncheckedCreateWithoutLocation_typesInput> | locationsCreateWithoutLocation_typesInput[] | locationsUncheckedCreateWithoutLocation_typesInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutLocation_typesInput | locationsCreateOrConnectWithoutLocation_typesInput[]
    upsert?: locationsUpsertWithWhereUniqueWithoutLocation_typesInput | locationsUpsertWithWhereUniqueWithoutLocation_typesInput[]
    createMany?: locationsCreateManyLocation_typesInputEnvelope
    set?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    disconnect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    delete?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    update?: locationsUpdateWithWhereUniqueWithoutLocation_typesInput | locationsUpdateWithWhereUniqueWithoutLocation_typesInput[]
    updateMany?: locationsUpdateManyWithWhereWithoutLocation_typesInput | locationsUpdateManyWithWhereWithoutLocation_typesInput[]
    deleteMany?: locationsScalarWhereInput | locationsScalarWhereInput[]
  }

  export type consumersCreateNestedOneWithoutLocationsInput = {
    create?: XOR<consumersCreateWithoutLocationsInput, consumersUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutLocationsInput
    connect?: consumersWhereUniqueInput
  }

  export type dtrsCreateNestedManyWithoutLocationsInput = {
    create?: XOR<dtrsCreateWithoutLocationsInput, dtrsUncheckedCreateWithoutLocationsInput> | dtrsCreateWithoutLocationsInput[] | dtrsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: dtrsCreateOrConnectWithoutLocationsInput | dtrsCreateOrConnectWithoutLocationsInput[]
    createMany?: dtrsCreateManyLocationsInputEnvelope
    connect?: dtrsWhereUniqueInput | dtrsWhereUniqueInput[]
  }

  export type location_typesCreateNestedOneWithoutLocationsInput = {
    create?: XOR<location_typesCreateWithoutLocationsInput, location_typesUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: location_typesCreateOrConnectWithoutLocationsInput
    connect?: location_typesWhereUniqueInput
  }

  export type locationsCreateNestedOneWithoutOther_locationsInput = {
    create?: XOR<locationsCreateWithoutOther_locationsInput, locationsUncheckedCreateWithoutOther_locationsInput>
    connectOrCreate?: locationsCreateOrConnectWithoutOther_locationsInput
    connect?: locationsWhereUniqueInput
  }

  export type locationsCreateNestedManyWithoutLocationsInput = {
    create?: XOR<locationsCreateWithoutLocationsInput, locationsUncheckedCreateWithoutLocationsInput> | locationsCreateWithoutLocationsInput[] | locationsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutLocationsInput | locationsCreateOrConnectWithoutLocationsInput[]
    createMany?: locationsCreateManyLocationsInputEnvelope
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
  }

  export type metersCreateNestedManyWithoutLocationsInput = {
    create?: XOR<metersCreateWithoutLocationsInput, metersUncheckedCreateWithoutLocationsInput> | metersCreateWithoutLocationsInput[] | metersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: metersCreateOrConnectWithoutLocationsInput | metersCreateOrConnectWithoutLocationsInput[]
    createMany?: metersCreateManyLocationsInputEnvelope
    connect?: metersWhereUniqueInput | metersWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutLocationsInput = {
    create?: XOR<usersCreateWithoutLocationsInput, usersUncheckedCreateWithoutLocationsInput> | usersCreateWithoutLocationsInput[] | usersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLocationsInput | usersCreateOrConnectWithoutLocationsInput[]
    createMany?: usersCreateManyLocationsInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type consumersUncheckedCreateNestedOneWithoutLocationsInput = {
    create?: XOR<consumersCreateWithoutLocationsInput, consumersUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutLocationsInput
    connect?: consumersWhereUniqueInput
  }

  export type dtrsUncheckedCreateNestedManyWithoutLocationsInput = {
    create?: XOR<dtrsCreateWithoutLocationsInput, dtrsUncheckedCreateWithoutLocationsInput> | dtrsCreateWithoutLocationsInput[] | dtrsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: dtrsCreateOrConnectWithoutLocationsInput | dtrsCreateOrConnectWithoutLocationsInput[]
    createMany?: dtrsCreateManyLocationsInputEnvelope
    connect?: dtrsWhereUniqueInput | dtrsWhereUniqueInput[]
  }

  export type locationsUncheckedCreateNestedManyWithoutLocationsInput = {
    create?: XOR<locationsCreateWithoutLocationsInput, locationsUncheckedCreateWithoutLocationsInput> | locationsCreateWithoutLocationsInput[] | locationsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutLocationsInput | locationsCreateOrConnectWithoutLocationsInput[]
    createMany?: locationsCreateManyLocationsInputEnvelope
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
  }

  export type metersUncheckedCreateNestedManyWithoutLocationsInput = {
    create?: XOR<metersCreateWithoutLocationsInput, metersUncheckedCreateWithoutLocationsInput> | metersCreateWithoutLocationsInput[] | metersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: metersCreateOrConnectWithoutLocationsInput | metersCreateOrConnectWithoutLocationsInput[]
    createMany?: metersCreateManyLocationsInputEnvelope
    connect?: metersWhereUniqueInput | metersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutLocationsInput = {
    create?: XOR<usersCreateWithoutLocationsInput, usersUncheckedCreateWithoutLocationsInput> | usersCreateWithoutLocationsInput[] | usersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLocationsInput | usersCreateOrConnectWithoutLocationsInput[]
    createMany?: usersCreateManyLocationsInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type consumersUpdateOneWithoutLocationsNestedInput = {
    create?: XOR<consumersCreateWithoutLocationsInput, consumersUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutLocationsInput
    upsert?: consumersUpsertWithoutLocationsInput
    disconnect?: consumersWhereInput | boolean
    delete?: consumersWhereInput | boolean
    connect?: consumersWhereUniqueInput
    update?: XOR<XOR<consumersUpdateToOneWithWhereWithoutLocationsInput, consumersUpdateWithoutLocationsInput>, consumersUncheckedUpdateWithoutLocationsInput>
  }

  export type dtrsUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<dtrsCreateWithoutLocationsInput, dtrsUncheckedCreateWithoutLocationsInput> | dtrsCreateWithoutLocationsInput[] | dtrsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: dtrsCreateOrConnectWithoutLocationsInput | dtrsCreateOrConnectWithoutLocationsInput[]
    upsert?: dtrsUpsertWithWhereUniqueWithoutLocationsInput | dtrsUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: dtrsCreateManyLocationsInputEnvelope
    set?: dtrsWhereUniqueInput | dtrsWhereUniqueInput[]
    disconnect?: dtrsWhereUniqueInput | dtrsWhereUniqueInput[]
    delete?: dtrsWhereUniqueInput | dtrsWhereUniqueInput[]
    connect?: dtrsWhereUniqueInput | dtrsWhereUniqueInput[]
    update?: dtrsUpdateWithWhereUniqueWithoutLocationsInput | dtrsUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: dtrsUpdateManyWithWhereWithoutLocationsInput | dtrsUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: dtrsScalarWhereInput | dtrsScalarWhereInput[]
  }

  export type location_typesUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<location_typesCreateWithoutLocationsInput, location_typesUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: location_typesCreateOrConnectWithoutLocationsInput
    upsert?: location_typesUpsertWithoutLocationsInput
    connect?: location_typesWhereUniqueInput
    update?: XOR<XOR<location_typesUpdateToOneWithWhereWithoutLocationsInput, location_typesUpdateWithoutLocationsInput>, location_typesUncheckedUpdateWithoutLocationsInput>
  }

  export type locationsUpdateOneWithoutOther_locationsNestedInput = {
    create?: XOR<locationsCreateWithoutOther_locationsInput, locationsUncheckedCreateWithoutOther_locationsInput>
    connectOrCreate?: locationsCreateOrConnectWithoutOther_locationsInput
    upsert?: locationsUpsertWithoutOther_locationsInput
    disconnect?: locationsWhereInput | boolean
    delete?: locationsWhereInput | boolean
    connect?: locationsWhereUniqueInput
    update?: XOR<XOR<locationsUpdateToOneWithWhereWithoutOther_locationsInput, locationsUpdateWithoutOther_locationsInput>, locationsUncheckedUpdateWithoutOther_locationsInput>
  }

  export type locationsUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<locationsCreateWithoutLocationsInput, locationsUncheckedCreateWithoutLocationsInput> | locationsCreateWithoutLocationsInput[] | locationsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutLocationsInput | locationsCreateOrConnectWithoutLocationsInput[]
    upsert?: locationsUpsertWithWhereUniqueWithoutLocationsInput | locationsUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: locationsCreateManyLocationsInputEnvelope
    set?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    disconnect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    delete?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    update?: locationsUpdateWithWhereUniqueWithoutLocationsInput | locationsUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: locationsUpdateManyWithWhereWithoutLocationsInput | locationsUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: locationsScalarWhereInput | locationsScalarWhereInput[]
  }

  export type metersUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<metersCreateWithoutLocationsInput, metersUncheckedCreateWithoutLocationsInput> | metersCreateWithoutLocationsInput[] | metersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: metersCreateOrConnectWithoutLocationsInput | metersCreateOrConnectWithoutLocationsInput[]
    upsert?: metersUpsertWithWhereUniqueWithoutLocationsInput | metersUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: metersCreateManyLocationsInputEnvelope
    set?: metersWhereUniqueInput | metersWhereUniqueInput[]
    disconnect?: metersWhereUniqueInput | metersWhereUniqueInput[]
    delete?: metersWhereUniqueInput | metersWhereUniqueInput[]
    connect?: metersWhereUniqueInput | metersWhereUniqueInput[]
    update?: metersUpdateWithWhereUniqueWithoutLocationsInput | metersUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: metersUpdateManyWithWhereWithoutLocationsInput | metersUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: metersScalarWhereInput | metersScalarWhereInput[]
  }

  export type usersUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<usersCreateWithoutLocationsInput, usersUncheckedCreateWithoutLocationsInput> | usersCreateWithoutLocationsInput[] | usersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLocationsInput | usersCreateOrConnectWithoutLocationsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutLocationsInput | usersUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: usersCreateManyLocationsInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutLocationsInput | usersUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutLocationsInput | usersUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type consumersUncheckedUpdateOneWithoutLocationsNestedInput = {
    create?: XOR<consumersCreateWithoutLocationsInput, consumersUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutLocationsInput
    upsert?: consumersUpsertWithoutLocationsInput
    disconnect?: consumersWhereInput | boolean
    delete?: consumersWhereInput | boolean
    connect?: consumersWhereUniqueInput
    update?: XOR<XOR<consumersUpdateToOneWithWhereWithoutLocationsInput, consumersUpdateWithoutLocationsInput>, consumersUncheckedUpdateWithoutLocationsInput>
  }

  export type dtrsUncheckedUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<dtrsCreateWithoutLocationsInput, dtrsUncheckedCreateWithoutLocationsInput> | dtrsCreateWithoutLocationsInput[] | dtrsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: dtrsCreateOrConnectWithoutLocationsInput | dtrsCreateOrConnectWithoutLocationsInput[]
    upsert?: dtrsUpsertWithWhereUniqueWithoutLocationsInput | dtrsUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: dtrsCreateManyLocationsInputEnvelope
    set?: dtrsWhereUniqueInput | dtrsWhereUniqueInput[]
    disconnect?: dtrsWhereUniqueInput | dtrsWhereUniqueInput[]
    delete?: dtrsWhereUniqueInput | dtrsWhereUniqueInput[]
    connect?: dtrsWhereUniqueInput | dtrsWhereUniqueInput[]
    update?: dtrsUpdateWithWhereUniqueWithoutLocationsInput | dtrsUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: dtrsUpdateManyWithWhereWithoutLocationsInput | dtrsUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: dtrsScalarWhereInput | dtrsScalarWhereInput[]
  }

  export type locationsUncheckedUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<locationsCreateWithoutLocationsInput, locationsUncheckedCreateWithoutLocationsInput> | locationsCreateWithoutLocationsInput[] | locationsUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: locationsCreateOrConnectWithoutLocationsInput | locationsCreateOrConnectWithoutLocationsInput[]
    upsert?: locationsUpsertWithWhereUniqueWithoutLocationsInput | locationsUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: locationsCreateManyLocationsInputEnvelope
    set?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    disconnect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    delete?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    connect?: locationsWhereUniqueInput | locationsWhereUniqueInput[]
    update?: locationsUpdateWithWhereUniqueWithoutLocationsInput | locationsUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: locationsUpdateManyWithWhereWithoutLocationsInput | locationsUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: locationsScalarWhereInput | locationsScalarWhereInput[]
  }

  export type metersUncheckedUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<metersCreateWithoutLocationsInput, metersUncheckedCreateWithoutLocationsInput> | metersCreateWithoutLocationsInput[] | metersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: metersCreateOrConnectWithoutLocationsInput | metersCreateOrConnectWithoutLocationsInput[]
    upsert?: metersUpsertWithWhereUniqueWithoutLocationsInput | metersUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: metersCreateManyLocationsInputEnvelope
    set?: metersWhereUniqueInput | metersWhereUniqueInput[]
    disconnect?: metersWhereUniqueInput | metersWhereUniqueInput[]
    delete?: metersWhereUniqueInput | metersWhereUniqueInput[]
    connect?: metersWhereUniqueInput | metersWhereUniqueInput[]
    update?: metersUpdateWithWhereUniqueWithoutLocationsInput | metersUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: metersUpdateManyWithWhereWithoutLocationsInput | metersUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: metersScalarWhereInput | metersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<usersCreateWithoutLocationsInput, usersUncheckedCreateWithoutLocationsInput> | usersCreateWithoutLocationsInput[] | usersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLocationsInput | usersCreateOrConnectWithoutLocationsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutLocationsInput | usersUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: usersCreateManyLocationsInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutLocationsInput | usersUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutLocationsInput | usersUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutLogin_historyInput = {
    create?: XOR<usersCreateWithoutLogin_historyInput, usersUncheckedCreateWithoutLogin_historyInput>
    connectOrCreate?: usersCreateOrConnectWithoutLogin_historyInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutLogin_historyNestedInput = {
    create?: XOR<usersCreateWithoutLogin_historyInput, usersUncheckedCreateWithoutLogin_historyInput>
    connectOrCreate?: usersCreateOrConnectWithoutLogin_historyInput
    upsert?: usersUpsertWithoutLogin_historyInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLogin_historyInput, usersUpdateWithoutLogin_historyInput>, usersUncheckedUpdateWithoutLogin_historyInput>
  }

  export type metersCreateNestedOneWithoutMeter_configurationsInput = {
    create?: XOR<metersCreateWithoutMeter_configurationsInput, metersUncheckedCreateWithoutMeter_configurationsInput>
    connectOrCreate?: metersCreateOrConnectWithoutMeter_configurationsInput
    connect?: metersWhereUniqueInput
  }

  export type metersUpdateOneRequiredWithoutMeter_configurationsNestedInput = {
    create?: XOR<metersCreateWithoutMeter_configurationsInput, metersUncheckedCreateWithoutMeter_configurationsInput>
    connectOrCreate?: metersCreateOrConnectWithoutMeter_configurationsInput
    upsert?: metersUpsertWithoutMeter_configurationsInput
    connect?: metersWhereUniqueInput
    update?: XOR<XOR<metersUpdateToOneWithWhereWithoutMeter_configurationsInput, metersUpdateWithoutMeter_configurationsInput>, metersUncheckedUpdateWithoutMeter_configurationsInput>
  }

  export type billsCreateNestedOneWithoutMeter_readingsInput = {
    create?: XOR<billsCreateWithoutMeter_readingsInput, billsUncheckedCreateWithoutMeter_readingsInput>
    connectOrCreate?: billsCreateOrConnectWithoutMeter_readingsInput
    connect?: billsWhereUniqueInput
  }

  export type metersCreateNestedOneWithoutMeter_readingsInput = {
    create?: XOR<metersCreateWithoutMeter_readingsInput, metersUncheckedCreateWithoutMeter_readingsInput>
    connectOrCreate?: metersCreateOrConnectWithoutMeter_readingsInput
    connect?: metersWhereUniqueInput
  }

  export type prepaid_transactionsCreateNestedManyWithoutMeter_readingsInput = {
    create?: XOR<prepaid_transactionsCreateWithoutMeter_readingsInput, prepaid_transactionsUncheckedCreateWithoutMeter_readingsInput> | prepaid_transactionsCreateWithoutMeter_readingsInput[] | prepaid_transactionsUncheckedCreateWithoutMeter_readingsInput[]
    connectOrCreate?: prepaid_transactionsCreateOrConnectWithoutMeter_readingsInput | prepaid_transactionsCreateOrConnectWithoutMeter_readingsInput[]
    createMany?: prepaid_transactionsCreateManyMeter_readingsInputEnvelope
    connect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
  }

  export type prepaid_transactionsUncheckedCreateNestedManyWithoutMeter_readingsInput = {
    create?: XOR<prepaid_transactionsCreateWithoutMeter_readingsInput, prepaid_transactionsUncheckedCreateWithoutMeter_readingsInput> | prepaid_transactionsCreateWithoutMeter_readingsInput[] | prepaid_transactionsUncheckedCreateWithoutMeter_readingsInput[]
    connectOrCreate?: prepaid_transactionsCreateOrConnectWithoutMeter_readingsInput | prepaid_transactionsCreateOrConnectWithoutMeter_readingsInput[]
    createMany?: prepaid_transactionsCreateManyMeter_readingsInputEnvelope
    connect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
  }

  export type EnumReadingTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReadingType
  }

  export type EnumReadingSourceFieldUpdateOperationsInput = {
    set?: $Enums.ReadingSource
  }

  export type billsUpdateOneWithoutMeter_readingsNestedInput = {
    create?: XOR<billsCreateWithoutMeter_readingsInput, billsUncheckedCreateWithoutMeter_readingsInput>
    connectOrCreate?: billsCreateOrConnectWithoutMeter_readingsInput
    upsert?: billsUpsertWithoutMeter_readingsInput
    disconnect?: billsWhereInput | boolean
    delete?: billsWhereInput | boolean
    connect?: billsWhereUniqueInput
    update?: XOR<XOR<billsUpdateToOneWithWhereWithoutMeter_readingsInput, billsUpdateWithoutMeter_readingsInput>, billsUncheckedUpdateWithoutMeter_readingsInput>
  }

  export type metersUpdateOneRequiredWithoutMeter_readingsNestedInput = {
    create?: XOR<metersCreateWithoutMeter_readingsInput, metersUncheckedCreateWithoutMeter_readingsInput>
    connectOrCreate?: metersCreateOrConnectWithoutMeter_readingsInput
    upsert?: metersUpsertWithoutMeter_readingsInput
    connect?: metersWhereUniqueInput
    update?: XOR<XOR<metersUpdateToOneWithWhereWithoutMeter_readingsInput, metersUpdateWithoutMeter_readingsInput>, metersUncheckedUpdateWithoutMeter_readingsInput>
  }

  export type prepaid_transactionsUpdateManyWithoutMeter_readingsNestedInput = {
    create?: XOR<prepaid_transactionsCreateWithoutMeter_readingsInput, prepaid_transactionsUncheckedCreateWithoutMeter_readingsInput> | prepaid_transactionsCreateWithoutMeter_readingsInput[] | prepaid_transactionsUncheckedCreateWithoutMeter_readingsInput[]
    connectOrCreate?: prepaid_transactionsCreateOrConnectWithoutMeter_readingsInput | prepaid_transactionsCreateOrConnectWithoutMeter_readingsInput[]
    upsert?: prepaid_transactionsUpsertWithWhereUniqueWithoutMeter_readingsInput | prepaid_transactionsUpsertWithWhereUniqueWithoutMeter_readingsInput[]
    createMany?: prepaid_transactionsCreateManyMeter_readingsInputEnvelope
    set?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    disconnect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    delete?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    connect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    update?: prepaid_transactionsUpdateWithWhereUniqueWithoutMeter_readingsInput | prepaid_transactionsUpdateWithWhereUniqueWithoutMeter_readingsInput[]
    updateMany?: prepaid_transactionsUpdateManyWithWhereWithoutMeter_readingsInput | prepaid_transactionsUpdateManyWithWhereWithoutMeter_readingsInput[]
    deleteMany?: prepaid_transactionsScalarWhereInput | prepaid_transactionsScalarWhereInput[]
  }

  export type prepaid_transactionsUncheckedUpdateManyWithoutMeter_readingsNestedInput = {
    create?: XOR<prepaid_transactionsCreateWithoutMeter_readingsInput, prepaid_transactionsUncheckedCreateWithoutMeter_readingsInput> | prepaid_transactionsCreateWithoutMeter_readingsInput[] | prepaid_transactionsUncheckedCreateWithoutMeter_readingsInput[]
    connectOrCreate?: prepaid_transactionsCreateOrConnectWithoutMeter_readingsInput | prepaid_transactionsCreateOrConnectWithoutMeter_readingsInput[]
    upsert?: prepaid_transactionsUpsertWithWhereUniqueWithoutMeter_readingsInput | prepaid_transactionsUpsertWithWhereUniqueWithoutMeter_readingsInput[]
    createMany?: prepaid_transactionsCreateManyMeter_readingsInputEnvelope
    set?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    disconnect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    delete?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    connect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    update?: prepaid_transactionsUpdateWithWhereUniqueWithoutMeter_readingsInput | prepaid_transactionsUpdateWithWhereUniqueWithoutMeter_readingsInput[]
    updateMany?: prepaid_transactionsUpdateManyWithWhereWithoutMeter_readingsInput | prepaid_transactionsUpdateManyWithWhereWithoutMeter_readingsInput[]
    deleteMany?: prepaid_transactionsScalarWhereInput | prepaid_transactionsScalarWhereInput[]
  }

  export type billsCreateNestedManyWithoutMetersInput = {
    create?: XOR<billsCreateWithoutMetersInput, billsUncheckedCreateWithoutMetersInput> | billsCreateWithoutMetersInput[] | billsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: billsCreateOrConnectWithoutMetersInput | billsCreateOrConnectWithoutMetersInput[]
    createMany?: billsCreateManyMetersInputEnvelope
    connect?: billsWhereUniqueInput | billsWhereUniqueInput[]
  }

  export type current_transformersCreateNestedManyWithoutMetersInput = {
    create?: XOR<current_transformersCreateWithoutMetersInput, current_transformersUncheckedCreateWithoutMetersInput> | current_transformersCreateWithoutMetersInput[] | current_transformersUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: current_transformersCreateOrConnectWithoutMetersInput | current_transformersCreateOrConnectWithoutMetersInput[]
    createMany?: current_transformersCreateManyMetersInputEnvelope
    connect?: current_transformersWhereUniqueInput | current_transformersWhereUniqueInput[]
  }

  export type meter_configurationsCreateNestedOneWithoutMetersInput = {
    create?: XOR<meter_configurationsCreateWithoutMetersInput, meter_configurationsUncheckedCreateWithoutMetersInput>
    connectOrCreate?: meter_configurationsCreateOrConnectWithoutMetersInput
    connect?: meter_configurationsWhereUniqueInput
  }

  export type meter_readingsCreateNestedManyWithoutMetersInput = {
    create?: XOR<meter_readingsCreateWithoutMetersInput, meter_readingsUncheckedCreateWithoutMetersInput> | meter_readingsCreateWithoutMetersInput[] | meter_readingsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: meter_readingsCreateOrConnectWithoutMetersInput | meter_readingsCreateOrConnectWithoutMetersInput[]
    createMany?: meter_readingsCreateManyMetersInputEnvelope
    connect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
  }

  export type dtrsCreateNestedOneWithoutMetersInput = {
    create?: XOR<dtrsCreateWithoutMetersInput, dtrsUncheckedCreateWithoutMetersInput>
    connectOrCreate?: dtrsCreateOrConnectWithoutMetersInput
    connect?: dtrsWhereUniqueInput
  }

  export type locationsCreateNestedOneWithoutMetersInput = {
    create?: XOR<locationsCreateWithoutMetersInput, locationsUncheckedCreateWithoutMetersInput>
    connectOrCreate?: locationsCreateOrConnectWithoutMetersInput
    connect?: locationsWhereUniqueInput
  }

  export type potential_transformersCreateNestedManyWithoutMetersInput = {
    create?: XOR<potential_transformersCreateWithoutMetersInput, potential_transformersUncheckedCreateWithoutMetersInput> | potential_transformersCreateWithoutMetersInput[] | potential_transformersUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: potential_transformersCreateOrConnectWithoutMetersInput | potential_transformersCreateOrConnectWithoutMetersInput[]
    createMany?: potential_transformersCreateManyMetersInputEnvelope
    connect?: potential_transformersWhereUniqueInput | potential_transformersWhereUniqueInput[]
  }

  export type tamper_eventsCreateNestedManyWithoutMetersInput = {
    create?: XOR<tamper_eventsCreateWithoutMetersInput, tamper_eventsUncheckedCreateWithoutMetersInput> | tamper_eventsCreateWithoutMetersInput[] | tamper_eventsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: tamper_eventsCreateOrConnectWithoutMetersInput | tamper_eventsCreateOrConnectWithoutMetersInput[]
    createMany?: tamper_eventsCreateManyMetersInputEnvelope
    connect?: tamper_eventsWhereUniqueInput | tamper_eventsWhereUniqueInput[]
  }

  export type billsUncheckedCreateNestedManyWithoutMetersInput = {
    create?: XOR<billsCreateWithoutMetersInput, billsUncheckedCreateWithoutMetersInput> | billsCreateWithoutMetersInput[] | billsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: billsCreateOrConnectWithoutMetersInput | billsCreateOrConnectWithoutMetersInput[]
    createMany?: billsCreateManyMetersInputEnvelope
    connect?: billsWhereUniqueInput | billsWhereUniqueInput[]
  }

  export type current_transformersUncheckedCreateNestedManyWithoutMetersInput = {
    create?: XOR<current_transformersCreateWithoutMetersInput, current_transformersUncheckedCreateWithoutMetersInput> | current_transformersCreateWithoutMetersInput[] | current_transformersUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: current_transformersCreateOrConnectWithoutMetersInput | current_transformersCreateOrConnectWithoutMetersInput[]
    createMany?: current_transformersCreateManyMetersInputEnvelope
    connect?: current_transformersWhereUniqueInput | current_transformersWhereUniqueInput[]
  }

  export type meter_configurationsUncheckedCreateNestedOneWithoutMetersInput = {
    create?: XOR<meter_configurationsCreateWithoutMetersInput, meter_configurationsUncheckedCreateWithoutMetersInput>
    connectOrCreate?: meter_configurationsCreateOrConnectWithoutMetersInput
    connect?: meter_configurationsWhereUniqueInput
  }

  export type meter_readingsUncheckedCreateNestedManyWithoutMetersInput = {
    create?: XOR<meter_readingsCreateWithoutMetersInput, meter_readingsUncheckedCreateWithoutMetersInput> | meter_readingsCreateWithoutMetersInput[] | meter_readingsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: meter_readingsCreateOrConnectWithoutMetersInput | meter_readingsCreateOrConnectWithoutMetersInput[]
    createMany?: meter_readingsCreateManyMetersInputEnvelope
    connect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
  }

  export type potential_transformersUncheckedCreateNestedManyWithoutMetersInput = {
    create?: XOR<potential_transformersCreateWithoutMetersInput, potential_transformersUncheckedCreateWithoutMetersInput> | potential_transformersCreateWithoutMetersInput[] | potential_transformersUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: potential_transformersCreateOrConnectWithoutMetersInput | potential_transformersCreateOrConnectWithoutMetersInput[]
    createMany?: potential_transformersCreateManyMetersInputEnvelope
    connect?: potential_transformersWhereUniqueInput | potential_transformersWhereUniqueInput[]
  }

  export type tamper_eventsUncheckedCreateNestedManyWithoutMetersInput = {
    create?: XOR<tamper_eventsCreateWithoutMetersInput, tamper_eventsUncheckedCreateWithoutMetersInput> | tamper_eventsCreateWithoutMetersInput[] | tamper_eventsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: tamper_eventsCreateOrConnectWithoutMetersInput | tamper_eventsCreateOrConnectWithoutMetersInput[]
    createMany?: tamper_eventsCreateManyMetersInputEnvelope
    connect?: tamper_eventsWhereUniqueInput | tamper_eventsWhereUniqueInput[]
  }

  export type EnumMeterTypeFieldUpdateOperationsInput = {
    set?: $Enums.MeterType
  }

  export type EnumMeterStatusFieldUpdateOperationsInput = {
    set?: $Enums.MeterStatus
  }

  export type billsUpdateManyWithoutMetersNestedInput = {
    create?: XOR<billsCreateWithoutMetersInput, billsUncheckedCreateWithoutMetersInput> | billsCreateWithoutMetersInput[] | billsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: billsCreateOrConnectWithoutMetersInput | billsCreateOrConnectWithoutMetersInput[]
    upsert?: billsUpsertWithWhereUniqueWithoutMetersInput | billsUpsertWithWhereUniqueWithoutMetersInput[]
    createMany?: billsCreateManyMetersInputEnvelope
    set?: billsWhereUniqueInput | billsWhereUniqueInput[]
    disconnect?: billsWhereUniqueInput | billsWhereUniqueInput[]
    delete?: billsWhereUniqueInput | billsWhereUniqueInput[]
    connect?: billsWhereUniqueInput | billsWhereUniqueInput[]
    update?: billsUpdateWithWhereUniqueWithoutMetersInput | billsUpdateWithWhereUniqueWithoutMetersInput[]
    updateMany?: billsUpdateManyWithWhereWithoutMetersInput | billsUpdateManyWithWhereWithoutMetersInput[]
    deleteMany?: billsScalarWhereInput | billsScalarWhereInput[]
  }

  export type current_transformersUpdateManyWithoutMetersNestedInput = {
    create?: XOR<current_transformersCreateWithoutMetersInput, current_transformersUncheckedCreateWithoutMetersInput> | current_transformersCreateWithoutMetersInput[] | current_transformersUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: current_transformersCreateOrConnectWithoutMetersInput | current_transformersCreateOrConnectWithoutMetersInput[]
    upsert?: current_transformersUpsertWithWhereUniqueWithoutMetersInput | current_transformersUpsertWithWhereUniqueWithoutMetersInput[]
    createMany?: current_transformersCreateManyMetersInputEnvelope
    set?: current_transformersWhereUniqueInput | current_transformersWhereUniqueInput[]
    disconnect?: current_transformersWhereUniqueInput | current_transformersWhereUniqueInput[]
    delete?: current_transformersWhereUniqueInput | current_transformersWhereUniqueInput[]
    connect?: current_transformersWhereUniqueInput | current_transformersWhereUniqueInput[]
    update?: current_transformersUpdateWithWhereUniqueWithoutMetersInput | current_transformersUpdateWithWhereUniqueWithoutMetersInput[]
    updateMany?: current_transformersUpdateManyWithWhereWithoutMetersInput | current_transformersUpdateManyWithWhereWithoutMetersInput[]
    deleteMany?: current_transformersScalarWhereInput | current_transformersScalarWhereInput[]
  }

  export type meter_configurationsUpdateOneWithoutMetersNestedInput = {
    create?: XOR<meter_configurationsCreateWithoutMetersInput, meter_configurationsUncheckedCreateWithoutMetersInput>
    connectOrCreate?: meter_configurationsCreateOrConnectWithoutMetersInput
    upsert?: meter_configurationsUpsertWithoutMetersInput
    disconnect?: meter_configurationsWhereInput | boolean
    delete?: meter_configurationsWhereInput | boolean
    connect?: meter_configurationsWhereUniqueInput
    update?: XOR<XOR<meter_configurationsUpdateToOneWithWhereWithoutMetersInput, meter_configurationsUpdateWithoutMetersInput>, meter_configurationsUncheckedUpdateWithoutMetersInput>
  }

  export type meter_readingsUpdateManyWithoutMetersNestedInput = {
    create?: XOR<meter_readingsCreateWithoutMetersInput, meter_readingsUncheckedCreateWithoutMetersInput> | meter_readingsCreateWithoutMetersInput[] | meter_readingsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: meter_readingsCreateOrConnectWithoutMetersInput | meter_readingsCreateOrConnectWithoutMetersInput[]
    upsert?: meter_readingsUpsertWithWhereUniqueWithoutMetersInput | meter_readingsUpsertWithWhereUniqueWithoutMetersInput[]
    createMany?: meter_readingsCreateManyMetersInputEnvelope
    set?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    disconnect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    delete?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    connect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    update?: meter_readingsUpdateWithWhereUniqueWithoutMetersInput | meter_readingsUpdateWithWhereUniqueWithoutMetersInput[]
    updateMany?: meter_readingsUpdateManyWithWhereWithoutMetersInput | meter_readingsUpdateManyWithWhereWithoutMetersInput[]
    deleteMany?: meter_readingsScalarWhereInput | meter_readingsScalarWhereInput[]
  }

  export type dtrsUpdateOneWithoutMetersNestedInput = {
    create?: XOR<dtrsCreateWithoutMetersInput, dtrsUncheckedCreateWithoutMetersInput>
    connectOrCreate?: dtrsCreateOrConnectWithoutMetersInput
    upsert?: dtrsUpsertWithoutMetersInput
    disconnect?: dtrsWhereInput | boolean
    delete?: dtrsWhereInput | boolean
    connect?: dtrsWhereUniqueInput
    update?: XOR<XOR<dtrsUpdateToOneWithWhereWithoutMetersInput, dtrsUpdateWithoutMetersInput>, dtrsUncheckedUpdateWithoutMetersInput>
  }

  export type locationsUpdateOneRequiredWithoutMetersNestedInput = {
    create?: XOR<locationsCreateWithoutMetersInput, locationsUncheckedCreateWithoutMetersInput>
    connectOrCreate?: locationsCreateOrConnectWithoutMetersInput
    upsert?: locationsUpsertWithoutMetersInput
    connect?: locationsWhereUniqueInput
    update?: XOR<XOR<locationsUpdateToOneWithWhereWithoutMetersInput, locationsUpdateWithoutMetersInput>, locationsUncheckedUpdateWithoutMetersInput>
  }

  export type potential_transformersUpdateManyWithoutMetersNestedInput = {
    create?: XOR<potential_transformersCreateWithoutMetersInput, potential_transformersUncheckedCreateWithoutMetersInput> | potential_transformersCreateWithoutMetersInput[] | potential_transformersUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: potential_transformersCreateOrConnectWithoutMetersInput | potential_transformersCreateOrConnectWithoutMetersInput[]
    upsert?: potential_transformersUpsertWithWhereUniqueWithoutMetersInput | potential_transformersUpsertWithWhereUniqueWithoutMetersInput[]
    createMany?: potential_transformersCreateManyMetersInputEnvelope
    set?: potential_transformersWhereUniqueInput | potential_transformersWhereUniqueInput[]
    disconnect?: potential_transformersWhereUniqueInput | potential_transformersWhereUniqueInput[]
    delete?: potential_transformersWhereUniqueInput | potential_transformersWhereUniqueInput[]
    connect?: potential_transformersWhereUniqueInput | potential_transformersWhereUniqueInput[]
    update?: potential_transformersUpdateWithWhereUniqueWithoutMetersInput | potential_transformersUpdateWithWhereUniqueWithoutMetersInput[]
    updateMany?: potential_transformersUpdateManyWithWhereWithoutMetersInput | potential_transformersUpdateManyWithWhereWithoutMetersInput[]
    deleteMany?: potential_transformersScalarWhereInput | potential_transformersScalarWhereInput[]
  }

  export type tamper_eventsUpdateManyWithoutMetersNestedInput = {
    create?: XOR<tamper_eventsCreateWithoutMetersInput, tamper_eventsUncheckedCreateWithoutMetersInput> | tamper_eventsCreateWithoutMetersInput[] | tamper_eventsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: tamper_eventsCreateOrConnectWithoutMetersInput | tamper_eventsCreateOrConnectWithoutMetersInput[]
    upsert?: tamper_eventsUpsertWithWhereUniqueWithoutMetersInput | tamper_eventsUpsertWithWhereUniqueWithoutMetersInput[]
    createMany?: tamper_eventsCreateManyMetersInputEnvelope
    set?: tamper_eventsWhereUniqueInput | tamper_eventsWhereUniqueInput[]
    disconnect?: tamper_eventsWhereUniqueInput | tamper_eventsWhereUniqueInput[]
    delete?: tamper_eventsWhereUniqueInput | tamper_eventsWhereUniqueInput[]
    connect?: tamper_eventsWhereUniqueInput | tamper_eventsWhereUniqueInput[]
    update?: tamper_eventsUpdateWithWhereUniqueWithoutMetersInput | tamper_eventsUpdateWithWhereUniqueWithoutMetersInput[]
    updateMany?: tamper_eventsUpdateManyWithWhereWithoutMetersInput | tamper_eventsUpdateManyWithWhereWithoutMetersInput[]
    deleteMany?: tamper_eventsScalarWhereInput | tamper_eventsScalarWhereInput[]
  }

  export type billsUncheckedUpdateManyWithoutMetersNestedInput = {
    create?: XOR<billsCreateWithoutMetersInput, billsUncheckedCreateWithoutMetersInput> | billsCreateWithoutMetersInput[] | billsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: billsCreateOrConnectWithoutMetersInput | billsCreateOrConnectWithoutMetersInput[]
    upsert?: billsUpsertWithWhereUniqueWithoutMetersInput | billsUpsertWithWhereUniqueWithoutMetersInput[]
    createMany?: billsCreateManyMetersInputEnvelope
    set?: billsWhereUniqueInput | billsWhereUniqueInput[]
    disconnect?: billsWhereUniqueInput | billsWhereUniqueInput[]
    delete?: billsWhereUniqueInput | billsWhereUniqueInput[]
    connect?: billsWhereUniqueInput | billsWhereUniqueInput[]
    update?: billsUpdateWithWhereUniqueWithoutMetersInput | billsUpdateWithWhereUniqueWithoutMetersInput[]
    updateMany?: billsUpdateManyWithWhereWithoutMetersInput | billsUpdateManyWithWhereWithoutMetersInput[]
    deleteMany?: billsScalarWhereInput | billsScalarWhereInput[]
  }

  export type current_transformersUncheckedUpdateManyWithoutMetersNestedInput = {
    create?: XOR<current_transformersCreateWithoutMetersInput, current_transformersUncheckedCreateWithoutMetersInput> | current_transformersCreateWithoutMetersInput[] | current_transformersUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: current_transformersCreateOrConnectWithoutMetersInput | current_transformersCreateOrConnectWithoutMetersInput[]
    upsert?: current_transformersUpsertWithWhereUniqueWithoutMetersInput | current_transformersUpsertWithWhereUniqueWithoutMetersInput[]
    createMany?: current_transformersCreateManyMetersInputEnvelope
    set?: current_transformersWhereUniqueInput | current_transformersWhereUniqueInput[]
    disconnect?: current_transformersWhereUniqueInput | current_transformersWhereUniqueInput[]
    delete?: current_transformersWhereUniqueInput | current_transformersWhereUniqueInput[]
    connect?: current_transformersWhereUniqueInput | current_transformersWhereUniqueInput[]
    update?: current_transformersUpdateWithWhereUniqueWithoutMetersInput | current_transformersUpdateWithWhereUniqueWithoutMetersInput[]
    updateMany?: current_transformersUpdateManyWithWhereWithoutMetersInput | current_transformersUpdateManyWithWhereWithoutMetersInput[]
    deleteMany?: current_transformersScalarWhereInput | current_transformersScalarWhereInput[]
  }

  export type meter_configurationsUncheckedUpdateOneWithoutMetersNestedInput = {
    create?: XOR<meter_configurationsCreateWithoutMetersInput, meter_configurationsUncheckedCreateWithoutMetersInput>
    connectOrCreate?: meter_configurationsCreateOrConnectWithoutMetersInput
    upsert?: meter_configurationsUpsertWithoutMetersInput
    disconnect?: meter_configurationsWhereInput | boolean
    delete?: meter_configurationsWhereInput | boolean
    connect?: meter_configurationsWhereUniqueInput
    update?: XOR<XOR<meter_configurationsUpdateToOneWithWhereWithoutMetersInput, meter_configurationsUpdateWithoutMetersInput>, meter_configurationsUncheckedUpdateWithoutMetersInput>
  }

  export type meter_readingsUncheckedUpdateManyWithoutMetersNestedInput = {
    create?: XOR<meter_readingsCreateWithoutMetersInput, meter_readingsUncheckedCreateWithoutMetersInput> | meter_readingsCreateWithoutMetersInput[] | meter_readingsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: meter_readingsCreateOrConnectWithoutMetersInput | meter_readingsCreateOrConnectWithoutMetersInput[]
    upsert?: meter_readingsUpsertWithWhereUniqueWithoutMetersInput | meter_readingsUpsertWithWhereUniqueWithoutMetersInput[]
    createMany?: meter_readingsCreateManyMetersInputEnvelope
    set?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    disconnect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    delete?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    connect?: meter_readingsWhereUniqueInput | meter_readingsWhereUniqueInput[]
    update?: meter_readingsUpdateWithWhereUniqueWithoutMetersInput | meter_readingsUpdateWithWhereUniqueWithoutMetersInput[]
    updateMany?: meter_readingsUpdateManyWithWhereWithoutMetersInput | meter_readingsUpdateManyWithWhereWithoutMetersInput[]
    deleteMany?: meter_readingsScalarWhereInput | meter_readingsScalarWhereInput[]
  }

  export type potential_transformersUncheckedUpdateManyWithoutMetersNestedInput = {
    create?: XOR<potential_transformersCreateWithoutMetersInput, potential_transformersUncheckedCreateWithoutMetersInput> | potential_transformersCreateWithoutMetersInput[] | potential_transformersUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: potential_transformersCreateOrConnectWithoutMetersInput | potential_transformersCreateOrConnectWithoutMetersInput[]
    upsert?: potential_transformersUpsertWithWhereUniqueWithoutMetersInput | potential_transformersUpsertWithWhereUniqueWithoutMetersInput[]
    createMany?: potential_transformersCreateManyMetersInputEnvelope
    set?: potential_transformersWhereUniqueInput | potential_transformersWhereUniqueInput[]
    disconnect?: potential_transformersWhereUniqueInput | potential_transformersWhereUniqueInput[]
    delete?: potential_transformersWhereUniqueInput | potential_transformersWhereUniqueInput[]
    connect?: potential_transformersWhereUniqueInput | potential_transformersWhereUniqueInput[]
    update?: potential_transformersUpdateWithWhereUniqueWithoutMetersInput | potential_transformersUpdateWithWhereUniqueWithoutMetersInput[]
    updateMany?: potential_transformersUpdateManyWithWhereWithoutMetersInput | potential_transformersUpdateManyWithWhereWithoutMetersInput[]
    deleteMany?: potential_transformersScalarWhereInput | potential_transformersScalarWhereInput[]
  }

  export type tamper_eventsUncheckedUpdateManyWithoutMetersNestedInput = {
    create?: XOR<tamper_eventsCreateWithoutMetersInput, tamper_eventsUncheckedCreateWithoutMetersInput> | tamper_eventsCreateWithoutMetersInput[] | tamper_eventsUncheckedCreateWithoutMetersInput[]
    connectOrCreate?: tamper_eventsCreateOrConnectWithoutMetersInput | tamper_eventsCreateOrConnectWithoutMetersInput[]
    upsert?: tamper_eventsUpsertWithWhereUniqueWithoutMetersInput | tamper_eventsUpsertWithWhereUniqueWithoutMetersInput[]
    createMany?: tamper_eventsCreateManyMetersInputEnvelope
    set?: tamper_eventsWhereUniqueInput | tamper_eventsWhereUniqueInput[]
    disconnect?: tamper_eventsWhereUniqueInput | tamper_eventsWhereUniqueInput[]
    delete?: tamper_eventsWhereUniqueInput | tamper_eventsWhereUniqueInput[]
    connect?: tamper_eventsWhereUniqueInput | tamper_eventsWhereUniqueInput[]
    update?: tamper_eventsUpdateWithWhereUniqueWithoutMetersInput | tamper_eventsUpdateWithWhereUniqueWithoutMetersInput[]
    updateMany?: tamper_eventsUpdateManyWithWhereWithoutMetersInput | tamper_eventsUpdateManyWithWhereWithoutMetersInput[]
    deleteMany?: tamper_eventsScalarWhereInput | tamper_eventsScalarWhereInput[]
  }

  export type notificationsCreatechannelsInput = {
    set: $Enums.NotificationChannel[]
  }

  export type consumersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<consumersCreateWithoutNotificationsInput, consumersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutNotificationsInput
    connect?: consumersWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority
  }

  export type notificationsUpdatechannelsInput = {
    set?: $Enums.NotificationChannel[]
    push?: $Enums.NotificationChannel | $Enums.NotificationChannel[]
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type consumersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<consumersCreateWithoutNotificationsInput, consumersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutNotificationsInput
    upsert?: consumersUpsertWithoutNotificationsInput
    connect?: consumersWhereUniqueInput
    update?: XOR<XOR<consumersUpdateToOneWithWhereWithoutNotificationsInput, consumersUpdateWithoutNotificationsInput>, consumersUncheckedUpdateWithoutNotificationsInput>
  }

  export type billsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<billsCreateWithoutPaymentsInput, billsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: billsCreateOrConnectWithoutPaymentsInput
    connect?: billsWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type billsUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<billsCreateWithoutPaymentsInput, billsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: billsCreateOrConnectWithoutPaymentsInput
    upsert?: billsUpsertWithoutPaymentsInput
    connect?: billsWhereUniqueInput
    update?: XOR<XOR<billsUpdateToOneWithWhereWithoutPaymentsInput, billsUpdateWithoutPaymentsInput>, billsUncheckedUpdateWithoutPaymentsInput>
  }

  export type user_permissionsCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<user_permissionsCreateWithoutPermissionsInput, user_permissionsUncheckedCreateWithoutPermissionsInput> | user_permissionsCreateWithoutPermissionsInput[] | user_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutPermissionsInput | user_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: user_permissionsCreateManyPermissionsInputEnvelope
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
  }

  export type user_permissionsUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<user_permissionsCreateWithoutPermissionsInput, user_permissionsUncheckedCreateWithoutPermissionsInput> | user_permissionsCreateWithoutPermissionsInput[] | user_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutPermissionsInput | user_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: user_permissionsCreateManyPermissionsInputEnvelope
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
  }

  export type user_permissionsUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<user_permissionsCreateWithoutPermissionsInput, user_permissionsUncheckedCreateWithoutPermissionsInput> | user_permissionsCreateWithoutPermissionsInput[] | user_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutPermissionsInput | user_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: user_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | user_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: user_permissionsCreateManyPermissionsInputEnvelope
    set?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    disconnect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    delete?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    update?: user_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | user_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: user_permissionsUpdateManyWithWhereWithoutPermissionsInput | user_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
  }

  export type user_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<user_permissionsCreateWithoutPermissionsInput, user_permissionsUncheckedCreateWithoutPermissionsInput> | user_permissionsCreateWithoutPermissionsInput[] | user_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutPermissionsInput | user_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: user_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | user_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: user_permissionsCreateManyPermissionsInputEnvelope
    set?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    disconnect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    delete?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    update?: user_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | user_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: user_permissionsUpdateManyWithWhereWithoutPermissionsInput | user_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
  }

  export type metersCreateNestedOneWithoutPotential_transformersInput = {
    create?: XOR<metersCreateWithoutPotential_transformersInput, metersUncheckedCreateWithoutPotential_transformersInput>
    connectOrCreate?: metersCreateOrConnectWithoutPotential_transformersInput
    connect?: metersWhereUniqueInput
  }

  export type metersUpdateOneRequiredWithoutPotential_transformersNestedInput = {
    create?: XOR<metersCreateWithoutPotential_transformersInput, metersUncheckedCreateWithoutPotential_transformersInput>
    connectOrCreate?: metersCreateOrConnectWithoutPotential_transformersInput
    upsert?: metersUpsertWithoutPotential_transformersInput
    connect?: metersWhereUniqueInput
    update?: XOR<XOR<metersUpdateToOneWithWhereWithoutPotential_transformersInput, metersUpdateWithoutPotential_transformersInput>, metersUncheckedUpdateWithoutPotential_transformersInput>
  }

  export type rolesCreateNestedOneWithoutRole_permissionsInput = {
    create?: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_permissionsInput
    connect?: rolesWhereUniqueInput
  }

  export type rolesUpdateOneRequiredWithoutRole_permissionsNestedInput = {
    create?: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_permissionsInput
    upsert?: rolesUpsertWithoutRole_permissionsInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutRole_permissionsInput, rolesUpdateWithoutRole_permissionsInput>, rolesUncheckedUpdateWithoutRole_permissionsInput>
  }

  export type role_permissionsCreateNestedManyWithoutRolesInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutRolesInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput> | usersCreateWithoutRolesInput[] | usersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput | usersCreateOrConnectWithoutRolesInput[]
    createMany?: usersCreateManyRolesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type role_permissionsUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput> | usersCreateWithoutRolesInput[] | usersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput | usersCreateOrConnectWithoutRolesInput[]
    createMany?: usersCreateManyRolesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type EnumAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.AccessLevel
  }

  export type role_permissionsUpdateManyWithoutRolesNestedInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    upsert?: role_permissionsUpsertWithWhereUniqueWithoutRolesInput | role_permissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    set?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    disconnect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    delete?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    update?: role_permissionsUpdateWithWhereUniqueWithoutRolesInput | role_permissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: role_permissionsUpdateManyWithWhereWithoutRolesInput | role_permissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
  }

  export type usersUpdateManyWithoutRolesNestedInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput> | usersCreateWithoutRolesInput[] | usersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput | usersCreateOrConnectWithoutRolesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutRolesInput | usersUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: usersCreateManyRolesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutRolesInput | usersUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutRolesInput | usersUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type role_permissionsUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput> | role_permissionsCreateWithoutRolesInput[] | role_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_permissionsCreateOrConnectWithoutRolesInput | role_permissionsCreateOrConnectWithoutRolesInput[]
    upsert?: role_permissionsUpsertWithWhereUniqueWithoutRolesInput | role_permissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: role_permissionsCreateManyRolesInputEnvelope
    set?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    disconnect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    delete?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    connect?: role_permissionsWhereUniqueInput | role_permissionsWhereUniqueInput[]
    update?: role_permissionsUpdateWithWhereUniqueWithoutRolesInput | role_permissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: role_permissionsUpdateManyWithWhereWithoutRolesInput | role_permissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput> | usersCreateWithoutRolesInput[] | usersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput | usersCreateOrConnectWithoutRolesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutRolesInput | usersUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: usersCreateManyRolesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutRolesInput | usersUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutRolesInput | usersUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutTickets_tickets_assignedToIdTousersInput = {
    create?: XOR<usersCreateWithoutTickets_tickets_assignedToIdTousersInput, usersUncheckedCreateWithoutTickets_tickets_assignedToIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutTickets_tickets_assignedToIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type dtrsCreateNestedOneWithoutTicketsInput = {
    create?: XOR<dtrsCreateWithoutTicketsInput, dtrsUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: dtrsCreateOrConnectWithoutTicketsInput
    connect?: dtrsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTickets_tickets_raisedByIdTousersInput = {
    create?: XOR<usersCreateWithoutTickets_tickets_raisedByIdTousersInput, usersUncheckedCreateWithoutTickets_tickets_raisedByIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutTickets_tickets_raisedByIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type EnumTicketTypeFieldUpdateOperationsInput = {
    set?: $Enums.TicketType
  }

  export type EnumTicketCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TicketCategory
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type usersUpdateOneWithoutTickets_tickets_assignedToIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutTickets_tickets_assignedToIdTousersInput, usersUncheckedCreateWithoutTickets_tickets_assignedToIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutTickets_tickets_assignedToIdTousersInput
    upsert?: usersUpsertWithoutTickets_tickets_assignedToIdTousersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTickets_tickets_assignedToIdTousersInput, usersUpdateWithoutTickets_tickets_assignedToIdTousersInput>, usersUncheckedUpdateWithoutTickets_tickets_assignedToIdTousersInput>
  }

  export type dtrsUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<dtrsCreateWithoutTicketsInput, dtrsUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: dtrsCreateOrConnectWithoutTicketsInput
    upsert?: dtrsUpsertWithoutTicketsInput
    disconnect?: dtrsWhereInput | boolean
    delete?: dtrsWhereInput | boolean
    connect?: dtrsWhereUniqueInput
    update?: XOR<XOR<dtrsUpdateToOneWithWhereWithoutTicketsInput, dtrsUpdateWithoutTicketsInput>, dtrsUncheckedUpdateWithoutTicketsInput>
  }

  export type usersUpdateOneRequiredWithoutTickets_tickets_raisedByIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutTickets_tickets_raisedByIdTousersInput, usersUncheckedCreateWithoutTickets_tickets_raisedByIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutTickets_tickets_raisedByIdTousersInput
    upsert?: usersUpsertWithoutTickets_tickets_raisedByIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTickets_tickets_raisedByIdTousersInput, usersUpdateWithoutTickets_tickets_raisedByIdTousersInput>, usersUncheckedUpdateWithoutTickets_tickets_raisedByIdTousersInput>
  }

  export type usersCreateNestedOneWithoutUser_activity_logsInput = {
    create?: XOR<usersCreateWithoutUser_activity_logsInput, usersUncheckedCreateWithoutUser_activity_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_activity_logsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_activity_logsNestedInput = {
    create?: XOR<usersCreateWithoutUser_activity_logsInput, usersUncheckedCreateWithoutUser_activity_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_activity_logsInput
    upsert?: usersUpsertWithoutUser_activity_logsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_activity_logsInput, usersUpdateWithoutUser_activity_logsInput>, usersUncheckedUpdateWithoutUser_activity_logsInput>
  }

  export type permissionsCreateNestedOneWithoutUser_permissionsInput = {
    create?: XOR<permissionsCreateWithoutUser_permissionsInput, permissionsUncheckedCreateWithoutUser_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutUser_permissionsInput
    connect?: permissionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUser_permissionsInput = {
    create?: XOR<usersCreateWithoutUser_permissionsInput, usersUncheckedCreateWithoutUser_permissionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_permissionsInput
    connect?: usersWhereUniqueInput
  }

  export type permissionsUpdateOneRequiredWithoutUser_permissionsNestedInput = {
    create?: XOR<permissionsCreateWithoutUser_permissionsInput, permissionsUncheckedCreateWithoutUser_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutUser_permissionsInput
    upsert?: permissionsUpsertWithoutUser_permissionsInput
    connect?: permissionsWhereUniqueInput
    update?: XOR<XOR<permissionsUpdateToOneWithWhereWithoutUser_permissionsInput, permissionsUpdateWithoutUser_permissionsInput>, permissionsUncheckedUpdateWithoutUser_permissionsInput>
  }

  export type usersUpdateOneRequiredWithoutUser_permissionsNestedInput = {
    create?: XOR<usersCreateWithoutUser_permissionsInput, usersUncheckedCreateWithoutUser_permissionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_permissionsInput
    upsert?: usersUpsertWithoutUser_permissionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_permissionsInput, usersUpdateWithoutUser_permissionsInput>, usersUncheckedUpdateWithoutUser_permissionsInput>
  }

  export type usersCreateNestedOneWithoutUser_sessionsInput = {
    create?: XOR<usersCreateWithoutUser_sessionsInput, usersUncheckedCreateWithoutUser_sessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_sessionsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_sessionsNestedInput = {
    create?: XOR<usersCreateWithoutUser_sessionsInput, usersUncheckedCreateWithoutUser_sessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_sessionsInput
    upsert?: usersUpsertWithoutUser_sessionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_sessionsInput, usersUpdateWithoutUser_sessionsInput>, usersUncheckedUpdateWithoutUser_sessionsInput>
  }

  export type usersCreateNestedOneWithoutRefresh_tokensInput = {
    create?: XOR<usersCreateWithoutRefresh_tokensInput, usersUncheckedCreateWithoutRefresh_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutRefresh_tokensInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutRefresh_tokensNestedInput = {
    create?: XOR<usersCreateWithoutRefresh_tokensInput, usersUncheckedCreateWithoutRefresh_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutRefresh_tokensInput
    upsert?: usersUpsertWithoutRefresh_tokensInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRefresh_tokensInput, usersUpdateWithoutRefresh_tokensInput>, usersUncheckedUpdateWithoutRefresh_tokensInput>
  }

  export type login_historyCreateNestedManyWithoutUsersInput = {
    create?: XOR<login_historyCreateWithoutUsersInput, login_historyUncheckedCreateWithoutUsersInput> | login_historyCreateWithoutUsersInput[] | login_historyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: login_historyCreateOrConnectWithoutUsersInput | login_historyCreateOrConnectWithoutUsersInput[]
    createMany?: login_historyCreateManyUsersInputEnvelope
    connect?: login_historyWhereUniqueInput | login_historyWhereUniqueInput[]
  }

  export type ticketsCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput = {
    create?: XOR<ticketsCreateWithoutUsers_tickets_assignedToIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_assignedToIdTousersInput> | ticketsCreateWithoutUsers_tickets_assignedToIdTousersInput[] | ticketsUncheckedCreateWithoutUsers_tickets_assignedToIdTousersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsers_tickets_assignedToIdTousersInput | ticketsCreateOrConnectWithoutUsers_tickets_assignedToIdTousersInput[]
    createMany?: ticketsCreateManyUsers_tickets_assignedToIdTousersInputEnvelope
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
  }

  export type ticketsCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput = {
    create?: XOR<ticketsCreateWithoutUsers_tickets_raisedByIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_raisedByIdTousersInput> | ticketsCreateWithoutUsers_tickets_raisedByIdTousersInput[] | ticketsUncheckedCreateWithoutUsers_tickets_raisedByIdTousersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsers_tickets_raisedByIdTousersInput | ticketsCreateOrConnectWithoutUsers_tickets_raisedByIdTousersInput[]
    createMany?: ticketsCreateManyUsers_tickets_raisedByIdTousersInputEnvelope
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
  }

  export type user_activity_logsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_activity_logsCreateWithoutUsersInput, user_activity_logsUncheckedCreateWithoutUsersInput> | user_activity_logsCreateWithoutUsersInput[] | user_activity_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_activity_logsCreateOrConnectWithoutUsersInput | user_activity_logsCreateOrConnectWithoutUsersInput[]
    createMany?: user_activity_logsCreateManyUsersInputEnvelope
    connect?: user_activity_logsWhereUniqueInput | user_activity_logsWhereUniqueInput[]
  }

  export type user_permissionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_permissionsCreateWithoutUsersInput, user_permissionsUncheckedCreateWithoutUsersInput> | user_permissionsCreateWithoutUsersInput[] | user_permissionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutUsersInput | user_permissionsCreateOrConnectWithoutUsersInput[]
    createMany?: user_permissionsCreateManyUsersInputEnvelope
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
  }

  export type user_sessionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_sessionsCreateWithoutUsersInput, user_sessionsUncheckedCreateWithoutUsersInput> | user_sessionsCreateWithoutUsersInput[] | user_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_sessionsCreateOrConnectWithoutUsersInput | user_sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: user_sessionsCreateManyUsersInputEnvelope
    connect?: user_sessionsWhereUniqueInput | user_sessionsWhereUniqueInput[]
  }

  export type refresh_tokensCreateNestedOneWithoutUsersInput = {
    create?: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutUsersInput
    connect?: refresh_tokensWhereUniqueInput
  }

  export type departmentsCreateNestedOneWithoutUsersInput = {
    create?: XOR<departmentsCreateWithoutUsersInput, departmentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutUsersInput
    connect?: departmentsWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutUsersInput = {
    create?: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsersInput
    connect?: rolesWhereUniqueInput
  }

  export type locationsCreateNestedOneWithoutUsersInput = {
    create?: XOR<locationsCreateWithoutUsersInput, locationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: locationsCreateOrConnectWithoutUsersInput
    connect?: locationsWhereUniqueInput
  }

  export type login_historyUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<login_historyCreateWithoutUsersInput, login_historyUncheckedCreateWithoutUsersInput> | login_historyCreateWithoutUsersInput[] | login_historyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: login_historyCreateOrConnectWithoutUsersInput | login_historyCreateOrConnectWithoutUsersInput[]
    createMany?: login_historyCreateManyUsersInputEnvelope
    connect?: login_historyWhereUniqueInput | login_historyWhereUniqueInput[]
  }

  export type ticketsUncheckedCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput = {
    create?: XOR<ticketsCreateWithoutUsers_tickets_assignedToIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_assignedToIdTousersInput> | ticketsCreateWithoutUsers_tickets_assignedToIdTousersInput[] | ticketsUncheckedCreateWithoutUsers_tickets_assignedToIdTousersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsers_tickets_assignedToIdTousersInput | ticketsCreateOrConnectWithoutUsers_tickets_assignedToIdTousersInput[]
    createMany?: ticketsCreateManyUsers_tickets_assignedToIdTousersInputEnvelope
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
  }

  export type ticketsUncheckedCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput = {
    create?: XOR<ticketsCreateWithoutUsers_tickets_raisedByIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_raisedByIdTousersInput> | ticketsCreateWithoutUsers_tickets_raisedByIdTousersInput[] | ticketsUncheckedCreateWithoutUsers_tickets_raisedByIdTousersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsers_tickets_raisedByIdTousersInput | ticketsCreateOrConnectWithoutUsers_tickets_raisedByIdTousersInput[]
    createMany?: ticketsCreateManyUsers_tickets_raisedByIdTousersInputEnvelope
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
  }

  export type user_activity_logsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_activity_logsCreateWithoutUsersInput, user_activity_logsUncheckedCreateWithoutUsersInput> | user_activity_logsCreateWithoutUsersInput[] | user_activity_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_activity_logsCreateOrConnectWithoutUsersInput | user_activity_logsCreateOrConnectWithoutUsersInput[]
    createMany?: user_activity_logsCreateManyUsersInputEnvelope
    connect?: user_activity_logsWhereUniqueInput | user_activity_logsWhereUniqueInput[]
  }

  export type user_permissionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_permissionsCreateWithoutUsersInput, user_permissionsUncheckedCreateWithoutUsersInput> | user_permissionsCreateWithoutUsersInput[] | user_permissionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutUsersInput | user_permissionsCreateOrConnectWithoutUsersInput[]
    createMany?: user_permissionsCreateManyUsersInputEnvelope
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
  }

  export type user_sessionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_sessionsCreateWithoutUsersInput, user_sessionsUncheckedCreateWithoutUsersInput> | user_sessionsCreateWithoutUsersInput[] | user_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_sessionsCreateOrConnectWithoutUsersInput | user_sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: user_sessionsCreateManyUsersInputEnvelope
    connect?: user_sessionsWhereUniqueInput | user_sessionsWhereUniqueInput[]
  }

  export type refresh_tokensUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutUsersInput
    connect?: refresh_tokensWhereUniqueInput
  }

  export type login_historyUpdateManyWithoutUsersNestedInput = {
    create?: XOR<login_historyCreateWithoutUsersInput, login_historyUncheckedCreateWithoutUsersInput> | login_historyCreateWithoutUsersInput[] | login_historyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: login_historyCreateOrConnectWithoutUsersInput | login_historyCreateOrConnectWithoutUsersInput[]
    upsert?: login_historyUpsertWithWhereUniqueWithoutUsersInput | login_historyUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: login_historyCreateManyUsersInputEnvelope
    set?: login_historyWhereUniqueInput | login_historyWhereUniqueInput[]
    disconnect?: login_historyWhereUniqueInput | login_historyWhereUniqueInput[]
    delete?: login_historyWhereUniqueInput | login_historyWhereUniqueInput[]
    connect?: login_historyWhereUniqueInput | login_historyWhereUniqueInput[]
    update?: login_historyUpdateWithWhereUniqueWithoutUsersInput | login_historyUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: login_historyUpdateManyWithWhereWithoutUsersInput | login_historyUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: login_historyScalarWhereInput | login_historyScalarWhereInput[]
  }

  export type ticketsUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput = {
    create?: XOR<ticketsCreateWithoutUsers_tickets_assignedToIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_assignedToIdTousersInput> | ticketsCreateWithoutUsers_tickets_assignedToIdTousersInput[] | ticketsUncheckedCreateWithoutUsers_tickets_assignedToIdTousersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsers_tickets_assignedToIdTousersInput | ticketsCreateOrConnectWithoutUsers_tickets_assignedToIdTousersInput[]
    upsert?: ticketsUpsertWithWhereUniqueWithoutUsers_tickets_assignedToIdTousersInput | ticketsUpsertWithWhereUniqueWithoutUsers_tickets_assignedToIdTousersInput[]
    createMany?: ticketsCreateManyUsers_tickets_assignedToIdTousersInputEnvelope
    set?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    disconnect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    delete?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    update?: ticketsUpdateWithWhereUniqueWithoutUsers_tickets_assignedToIdTousersInput | ticketsUpdateWithWhereUniqueWithoutUsers_tickets_assignedToIdTousersInput[]
    updateMany?: ticketsUpdateManyWithWhereWithoutUsers_tickets_assignedToIdTousersInput | ticketsUpdateManyWithWhereWithoutUsers_tickets_assignedToIdTousersInput[]
    deleteMany?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
  }

  export type ticketsUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput = {
    create?: XOR<ticketsCreateWithoutUsers_tickets_raisedByIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_raisedByIdTousersInput> | ticketsCreateWithoutUsers_tickets_raisedByIdTousersInput[] | ticketsUncheckedCreateWithoutUsers_tickets_raisedByIdTousersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsers_tickets_raisedByIdTousersInput | ticketsCreateOrConnectWithoutUsers_tickets_raisedByIdTousersInput[]
    upsert?: ticketsUpsertWithWhereUniqueWithoutUsers_tickets_raisedByIdTousersInput | ticketsUpsertWithWhereUniqueWithoutUsers_tickets_raisedByIdTousersInput[]
    createMany?: ticketsCreateManyUsers_tickets_raisedByIdTousersInputEnvelope
    set?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    disconnect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    delete?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    update?: ticketsUpdateWithWhereUniqueWithoutUsers_tickets_raisedByIdTousersInput | ticketsUpdateWithWhereUniqueWithoutUsers_tickets_raisedByIdTousersInput[]
    updateMany?: ticketsUpdateManyWithWhereWithoutUsers_tickets_raisedByIdTousersInput | ticketsUpdateManyWithWhereWithoutUsers_tickets_raisedByIdTousersInput[]
    deleteMany?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
  }

  export type user_activity_logsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_activity_logsCreateWithoutUsersInput, user_activity_logsUncheckedCreateWithoutUsersInput> | user_activity_logsCreateWithoutUsersInput[] | user_activity_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_activity_logsCreateOrConnectWithoutUsersInput | user_activity_logsCreateOrConnectWithoutUsersInput[]
    upsert?: user_activity_logsUpsertWithWhereUniqueWithoutUsersInput | user_activity_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_activity_logsCreateManyUsersInputEnvelope
    set?: user_activity_logsWhereUniqueInput | user_activity_logsWhereUniqueInput[]
    disconnect?: user_activity_logsWhereUniqueInput | user_activity_logsWhereUniqueInput[]
    delete?: user_activity_logsWhereUniqueInput | user_activity_logsWhereUniqueInput[]
    connect?: user_activity_logsWhereUniqueInput | user_activity_logsWhereUniqueInput[]
    update?: user_activity_logsUpdateWithWhereUniqueWithoutUsersInput | user_activity_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_activity_logsUpdateManyWithWhereWithoutUsersInput | user_activity_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_activity_logsScalarWhereInput | user_activity_logsScalarWhereInput[]
  }

  export type user_permissionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_permissionsCreateWithoutUsersInput, user_permissionsUncheckedCreateWithoutUsersInput> | user_permissionsCreateWithoutUsersInput[] | user_permissionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutUsersInput | user_permissionsCreateOrConnectWithoutUsersInput[]
    upsert?: user_permissionsUpsertWithWhereUniqueWithoutUsersInput | user_permissionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_permissionsCreateManyUsersInputEnvelope
    set?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    disconnect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    delete?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    update?: user_permissionsUpdateWithWhereUniqueWithoutUsersInput | user_permissionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_permissionsUpdateManyWithWhereWithoutUsersInput | user_permissionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
  }

  export type user_sessionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_sessionsCreateWithoutUsersInput, user_sessionsUncheckedCreateWithoutUsersInput> | user_sessionsCreateWithoutUsersInput[] | user_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_sessionsCreateOrConnectWithoutUsersInput | user_sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: user_sessionsUpsertWithWhereUniqueWithoutUsersInput | user_sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_sessionsCreateManyUsersInputEnvelope
    set?: user_sessionsWhereUniqueInput | user_sessionsWhereUniqueInput[]
    disconnect?: user_sessionsWhereUniqueInput | user_sessionsWhereUniqueInput[]
    delete?: user_sessionsWhereUniqueInput | user_sessionsWhereUniqueInput[]
    connect?: user_sessionsWhereUniqueInput | user_sessionsWhereUniqueInput[]
    update?: user_sessionsUpdateWithWhereUniqueWithoutUsersInput | user_sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_sessionsUpdateManyWithWhereWithoutUsersInput | user_sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_sessionsScalarWhereInput | user_sessionsScalarWhereInput[]
  }

  export type refresh_tokensUpdateOneWithoutUsersNestedInput = {
    create?: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutUsersInput
    upsert?: refresh_tokensUpsertWithoutUsersInput
    disconnect?: refresh_tokensWhereInput | boolean
    delete?: refresh_tokensWhereInput | boolean
    connect?: refresh_tokensWhereUniqueInput
    update?: XOR<XOR<refresh_tokensUpdateToOneWithWhereWithoutUsersInput, refresh_tokensUpdateWithoutUsersInput>, refresh_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type departmentsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<departmentsCreateWithoutUsersInput, departmentsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: departmentsCreateOrConnectWithoutUsersInput
    upsert?: departmentsUpsertWithoutUsersInput
    disconnect?: departmentsWhereInput | boolean
    delete?: departmentsWhereInput | boolean
    connect?: departmentsWhereUniqueInput
    update?: XOR<XOR<departmentsUpdateToOneWithWhereWithoutUsersInput, departmentsUpdateWithoutUsersInput>, departmentsUncheckedUpdateWithoutUsersInput>
  }

  export type rolesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsersInput
    upsert?: rolesUpsertWithoutUsersInput
    disconnect?: rolesWhereInput | boolean
    delete?: rolesWhereInput | boolean
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutUsersInput, rolesUpdateWithoutUsersInput>, rolesUncheckedUpdateWithoutUsersInput>
  }

  export type locationsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<locationsCreateWithoutUsersInput, locationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: locationsCreateOrConnectWithoutUsersInput
    upsert?: locationsUpsertWithoutUsersInput
    disconnect?: locationsWhereInput | boolean
    delete?: locationsWhereInput | boolean
    connect?: locationsWhereUniqueInput
    update?: XOR<XOR<locationsUpdateToOneWithWhereWithoutUsersInput, locationsUpdateWithoutUsersInput>, locationsUncheckedUpdateWithoutUsersInput>
  }

  export type login_historyUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<login_historyCreateWithoutUsersInput, login_historyUncheckedCreateWithoutUsersInput> | login_historyCreateWithoutUsersInput[] | login_historyUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: login_historyCreateOrConnectWithoutUsersInput | login_historyCreateOrConnectWithoutUsersInput[]
    upsert?: login_historyUpsertWithWhereUniqueWithoutUsersInput | login_historyUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: login_historyCreateManyUsersInputEnvelope
    set?: login_historyWhereUniqueInput | login_historyWhereUniqueInput[]
    disconnect?: login_historyWhereUniqueInput | login_historyWhereUniqueInput[]
    delete?: login_historyWhereUniqueInput | login_historyWhereUniqueInput[]
    connect?: login_historyWhereUniqueInput | login_historyWhereUniqueInput[]
    update?: login_historyUpdateWithWhereUniqueWithoutUsersInput | login_historyUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: login_historyUpdateManyWithWhereWithoutUsersInput | login_historyUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: login_historyScalarWhereInput | login_historyScalarWhereInput[]
  }

  export type ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput = {
    create?: XOR<ticketsCreateWithoutUsers_tickets_assignedToIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_assignedToIdTousersInput> | ticketsCreateWithoutUsers_tickets_assignedToIdTousersInput[] | ticketsUncheckedCreateWithoutUsers_tickets_assignedToIdTousersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsers_tickets_assignedToIdTousersInput | ticketsCreateOrConnectWithoutUsers_tickets_assignedToIdTousersInput[]
    upsert?: ticketsUpsertWithWhereUniqueWithoutUsers_tickets_assignedToIdTousersInput | ticketsUpsertWithWhereUniqueWithoutUsers_tickets_assignedToIdTousersInput[]
    createMany?: ticketsCreateManyUsers_tickets_assignedToIdTousersInputEnvelope
    set?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    disconnect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    delete?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    update?: ticketsUpdateWithWhereUniqueWithoutUsers_tickets_assignedToIdTousersInput | ticketsUpdateWithWhereUniqueWithoutUsers_tickets_assignedToIdTousersInput[]
    updateMany?: ticketsUpdateManyWithWhereWithoutUsers_tickets_assignedToIdTousersInput | ticketsUpdateManyWithWhereWithoutUsers_tickets_assignedToIdTousersInput[]
    deleteMany?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
  }

  export type ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput = {
    create?: XOR<ticketsCreateWithoutUsers_tickets_raisedByIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_raisedByIdTousersInput> | ticketsCreateWithoutUsers_tickets_raisedByIdTousersInput[] | ticketsUncheckedCreateWithoutUsers_tickets_raisedByIdTousersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsers_tickets_raisedByIdTousersInput | ticketsCreateOrConnectWithoutUsers_tickets_raisedByIdTousersInput[]
    upsert?: ticketsUpsertWithWhereUniqueWithoutUsers_tickets_raisedByIdTousersInput | ticketsUpsertWithWhereUniqueWithoutUsers_tickets_raisedByIdTousersInput[]
    createMany?: ticketsCreateManyUsers_tickets_raisedByIdTousersInputEnvelope
    set?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    disconnect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    delete?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    update?: ticketsUpdateWithWhereUniqueWithoutUsers_tickets_raisedByIdTousersInput | ticketsUpdateWithWhereUniqueWithoutUsers_tickets_raisedByIdTousersInput[]
    updateMany?: ticketsUpdateManyWithWhereWithoutUsers_tickets_raisedByIdTousersInput | ticketsUpdateManyWithWhereWithoutUsers_tickets_raisedByIdTousersInput[]
    deleteMany?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
  }

  export type user_activity_logsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_activity_logsCreateWithoutUsersInput, user_activity_logsUncheckedCreateWithoutUsersInput> | user_activity_logsCreateWithoutUsersInput[] | user_activity_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_activity_logsCreateOrConnectWithoutUsersInput | user_activity_logsCreateOrConnectWithoutUsersInput[]
    upsert?: user_activity_logsUpsertWithWhereUniqueWithoutUsersInput | user_activity_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_activity_logsCreateManyUsersInputEnvelope
    set?: user_activity_logsWhereUniqueInput | user_activity_logsWhereUniqueInput[]
    disconnect?: user_activity_logsWhereUniqueInput | user_activity_logsWhereUniqueInput[]
    delete?: user_activity_logsWhereUniqueInput | user_activity_logsWhereUniqueInput[]
    connect?: user_activity_logsWhereUniqueInput | user_activity_logsWhereUniqueInput[]
    update?: user_activity_logsUpdateWithWhereUniqueWithoutUsersInput | user_activity_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_activity_logsUpdateManyWithWhereWithoutUsersInput | user_activity_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_activity_logsScalarWhereInput | user_activity_logsScalarWhereInput[]
  }

  export type user_permissionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_permissionsCreateWithoutUsersInput, user_permissionsUncheckedCreateWithoutUsersInput> | user_permissionsCreateWithoutUsersInput[] | user_permissionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutUsersInput | user_permissionsCreateOrConnectWithoutUsersInput[]
    upsert?: user_permissionsUpsertWithWhereUniqueWithoutUsersInput | user_permissionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_permissionsCreateManyUsersInputEnvelope
    set?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    disconnect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    delete?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    update?: user_permissionsUpdateWithWhereUniqueWithoutUsersInput | user_permissionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_permissionsUpdateManyWithWhereWithoutUsersInput | user_permissionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
  }

  export type user_sessionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_sessionsCreateWithoutUsersInput, user_sessionsUncheckedCreateWithoutUsersInput> | user_sessionsCreateWithoutUsersInput[] | user_sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_sessionsCreateOrConnectWithoutUsersInput | user_sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: user_sessionsUpsertWithWhereUniqueWithoutUsersInput | user_sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_sessionsCreateManyUsersInputEnvelope
    set?: user_sessionsWhereUniqueInput | user_sessionsWhereUniqueInput[]
    disconnect?: user_sessionsWhereUniqueInput | user_sessionsWhereUniqueInput[]
    delete?: user_sessionsWhereUniqueInput | user_sessionsWhereUniqueInput[]
    connect?: user_sessionsWhereUniqueInput | user_sessionsWhereUniqueInput[]
    update?: user_sessionsUpdateWithWhereUniqueWithoutUsersInput | user_sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_sessionsUpdateManyWithWhereWithoutUsersInput | user_sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_sessionsScalarWhereInput | user_sessionsScalarWhereInput[]
  }

  export type refresh_tokensUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput>
    connectOrCreate?: refresh_tokensCreateOrConnectWithoutUsersInput
    upsert?: refresh_tokensUpsertWithoutUsersInput
    disconnect?: refresh_tokensWhereInput | boolean
    delete?: refresh_tokensWhereInput | boolean
    connect?: refresh_tokensWhereUniqueInput
    update?: XOR<XOR<refresh_tokensUpdateToOneWithWhereWithoutUsersInput, refresh_tokensUpdateWithoutUsersInput>, refresh_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type consumersCreateNestedOneWithoutPrepaid_accountsInput = {
    create?: XOR<consumersCreateWithoutPrepaid_accountsInput, consumersUncheckedCreateWithoutPrepaid_accountsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutPrepaid_accountsInput
    connect?: consumersWhereUniqueInput
  }

  export type prepaid_alertsCreateNestedManyWithoutPrepaid_accountsInput = {
    create?: XOR<prepaid_alertsCreateWithoutPrepaid_accountsInput, prepaid_alertsUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_alertsCreateWithoutPrepaid_accountsInput[] | prepaid_alertsUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_alertsCreateOrConnectWithoutPrepaid_accountsInput | prepaid_alertsCreateOrConnectWithoutPrepaid_accountsInput[]
    createMany?: prepaid_alertsCreateManyPrepaid_accountsInputEnvelope
    connect?: prepaid_alertsWhereUniqueInput | prepaid_alertsWhereUniqueInput[]
  }

  export type prepaid_rechargesCreateNestedManyWithoutPrepaid_accountsInput = {
    create?: XOR<prepaid_rechargesCreateWithoutPrepaid_accountsInput, prepaid_rechargesUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_rechargesCreateWithoutPrepaid_accountsInput[] | prepaid_rechargesUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_rechargesCreateOrConnectWithoutPrepaid_accountsInput | prepaid_rechargesCreateOrConnectWithoutPrepaid_accountsInput[]
    createMany?: prepaid_rechargesCreateManyPrepaid_accountsInputEnvelope
    connect?: prepaid_rechargesWhereUniqueInput | prepaid_rechargesWhereUniqueInput[]
  }

  export type prepaid_transactionsCreateNestedManyWithoutPrepaid_accountsInput = {
    create?: XOR<prepaid_transactionsCreateWithoutPrepaid_accountsInput, prepaid_transactionsUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_transactionsCreateWithoutPrepaid_accountsInput[] | prepaid_transactionsUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_transactionsCreateOrConnectWithoutPrepaid_accountsInput | prepaid_transactionsCreateOrConnectWithoutPrepaid_accountsInput[]
    createMany?: prepaid_transactionsCreateManyPrepaid_accountsInputEnvelope
    connect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
  }

  export type prepaid_alertsUncheckedCreateNestedManyWithoutPrepaid_accountsInput = {
    create?: XOR<prepaid_alertsCreateWithoutPrepaid_accountsInput, prepaid_alertsUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_alertsCreateWithoutPrepaid_accountsInput[] | prepaid_alertsUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_alertsCreateOrConnectWithoutPrepaid_accountsInput | prepaid_alertsCreateOrConnectWithoutPrepaid_accountsInput[]
    createMany?: prepaid_alertsCreateManyPrepaid_accountsInputEnvelope
    connect?: prepaid_alertsWhereUniqueInput | prepaid_alertsWhereUniqueInput[]
  }

  export type prepaid_rechargesUncheckedCreateNestedManyWithoutPrepaid_accountsInput = {
    create?: XOR<prepaid_rechargesCreateWithoutPrepaid_accountsInput, prepaid_rechargesUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_rechargesCreateWithoutPrepaid_accountsInput[] | prepaid_rechargesUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_rechargesCreateOrConnectWithoutPrepaid_accountsInput | prepaid_rechargesCreateOrConnectWithoutPrepaid_accountsInput[]
    createMany?: prepaid_rechargesCreateManyPrepaid_accountsInputEnvelope
    connect?: prepaid_rechargesWhereUniqueInput | prepaid_rechargesWhereUniqueInput[]
  }

  export type prepaid_transactionsUncheckedCreateNestedManyWithoutPrepaid_accountsInput = {
    create?: XOR<prepaid_transactionsCreateWithoutPrepaid_accountsInput, prepaid_transactionsUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_transactionsCreateWithoutPrepaid_accountsInput[] | prepaid_transactionsUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_transactionsCreateOrConnectWithoutPrepaid_accountsInput | prepaid_transactionsCreateOrConnectWithoutPrepaid_accountsInput[]
    createMany?: prepaid_transactionsCreateManyPrepaid_accountsInputEnvelope
    connect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
  }

  export type consumersUpdateOneRequiredWithoutPrepaid_accountsNestedInput = {
    create?: XOR<consumersCreateWithoutPrepaid_accountsInput, consumersUncheckedCreateWithoutPrepaid_accountsInput>
    connectOrCreate?: consumersCreateOrConnectWithoutPrepaid_accountsInput
    upsert?: consumersUpsertWithoutPrepaid_accountsInput
    connect?: consumersWhereUniqueInput
    update?: XOR<XOR<consumersUpdateToOneWithWhereWithoutPrepaid_accountsInput, consumersUpdateWithoutPrepaid_accountsInput>, consumersUncheckedUpdateWithoutPrepaid_accountsInput>
  }

  export type prepaid_alertsUpdateManyWithoutPrepaid_accountsNestedInput = {
    create?: XOR<prepaid_alertsCreateWithoutPrepaid_accountsInput, prepaid_alertsUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_alertsCreateWithoutPrepaid_accountsInput[] | prepaid_alertsUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_alertsCreateOrConnectWithoutPrepaid_accountsInput | prepaid_alertsCreateOrConnectWithoutPrepaid_accountsInput[]
    upsert?: prepaid_alertsUpsertWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_alertsUpsertWithWhereUniqueWithoutPrepaid_accountsInput[]
    createMany?: prepaid_alertsCreateManyPrepaid_accountsInputEnvelope
    set?: prepaid_alertsWhereUniqueInput | prepaid_alertsWhereUniqueInput[]
    disconnect?: prepaid_alertsWhereUniqueInput | prepaid_alertsWhereUniqueInput[]
    delete?: prepaid_alertsWhereUniqueInput | prepaid_alertsWhereUniqueInput[]
    connect?: prepaid_alertsWhereUniqueInput | prepaid_alertsWhereUniqueInput[]
    update?: prepaid_alertsUpdateWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_alertsUpdateWithWhereUniqueWithoutPrepaid_accountsInput[]
    updateMany?: prepaid_alertsUpdateManyWithWhereWithoutPrepaid_accountsInput | prepaid_alertsUpdateManyWithWhereWithoutPrepaid_accountsInput[]
    deleteMany?: prepaid_alertsScalarWhereInput | prepaid_alertsScalarWhereInput[]
  }

  export type prepaid_rechargesUpdateManyWithoutPrepaid_accountsNestedInput = {
    create?: XOR<prepaid_rechargesCreateWithoutPrepaid_accountsInput, prepaid_rechargesUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_rechargesCreateWithoutPrepaid_accountsInput[] | prepaid_rechargesUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_rechargesCreateOrConnectWithoutPrepaid_accountsInput | prepaid_rechargesCreateOrConnectWithoutPrepaid_accountsInput[]
    upsert?: prepaid_rechargesUpsertWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_rechargesUpsertWithWhereUniqueWithoutPrepaid_accountsInput[]
    createMany?: prepaid_rechargesCreateManyPrepaid_accountsInputEnvelope
    set?: prepaid_rechargesWhereUniqueInput | prepaid_rechargesWhereUniqueInput[]
    disconnect?: prepaid_rechargesWhereUniqueInput | prepaid_rechargesWhereUniqueInput[]
    delete?: prepaid_rechargesWhereUniqueInput | prepaid_rechargesWhereUniqueInput[]
    connect?: prepaid_rechargesWhereUniqueInput | prepaid_rechargesWhereUniqueInput[]
    update?: prepaid_rechargesUpdateWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_rechargesUpdateWithWhereUniqueWithoutPrepaid_accountsInput[]
    updateMany?: prepaid_rechargesUpdateManyWithWhereWithoutPrepaid_accountsInput | prepaid_rechargesUpdateManyWithWhereWithoutPrepaid_accountsInput[]
    deleteMany?: prepaid_rechargesScalarWhereInput | prepaid_rechargesScalarWhereInput[]
  }

  export type prepaid_transactionsUpdateManyWithoutPrepaid_accountsNestedInput = {
    create?: XOR<prepaid_transactionsCreateWithoutPrepaid_accountsInput, prepaid_transactionsUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_transactionsCreateWithoutPrepaid_accountsInput[] | prepaid_transactionsUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_transactionsCreateOrConnectWithoutPrepaid_accountsInput | prepaid_transactionsCreateOrConnectWithoutPrepaid_accountsInput[]
    upsert?: prepaid_transactionsUpsertWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_transactionsUpsertWithWhereUniqueWithoutPrepaid_accountsInput[]
    createMany?: prepaid_transactionsCreateManyPrepaid_accountsInputEnvelope
    set?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    disconnect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    delete?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    connect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    update?: prepaid_transactionsUpdateWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_transactionsUpdateWithWhereUniqueWithoutPrepaid_accountsInput[]
    updateMany?: prepaid_transactionsUpdateManyWithWhereWithoutPrepaid_accountsInput | prepaid_transactionsUpdateManyWithWhereWithoutPrepaid_accountsInput[]
    deleteMany?: prepaid_transactionsScalarWhereInput | prepaid_transactionsScalarWhereInput[]
  }

  export type prepaid_alertsUncheckedUpdateManyWithoutPrepaid_accountsNestedInput = {
    create?: XOR<prepaid_alertsCreateWithoutPrepaid_accountsInput, prepaid_alertsUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_alertsCreateWithoutPrepaid_accountsInput[] | prepaid_alertsUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_alertsCreateOrConnectWithoutPrepaid_accountsInput | prepaid_alertsCreateOrConnectWithoutPrepaid_accountsInput[]
    upsert?: prepaid_alertsUpsertWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_alertsUpsertWithWhereUniqueWithoutPrepaid_accountsInput[]
    createMany?: prepaid_alertsCreateManyPrepaid_accountsInputEnvelope
    set?: prepaid_alertsWhereUniqueInput | prepaid_alertsWhereUniqueInput[]
    disconnect?: prepaid_alertsWhereUniqueInput | prepaid_alertsWhereUniqueInput[]
    delete?: prepaid_alertsWhereUniqueInput | prepaid_alertsWhereUniqueInput[]
    connect?: prepaid_alertsWhereUniqueInput | prepaid_alertsWhereUniqueInput[]
    update?: prepaid_alertsUpdateWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_alertsUpdateWithWhereUniqueWithoutPrepaid_accountsInput[]
    updateMany?: prepaid_alertsUpdateManyWithWhereWithoutPrepaid_accountsInput | prepaid_alertsUpdateManyWithWhereWithoutPrepaid_accountsInput[]
    deleteMany?: prepaid_alertsScalarWhereInput | prepaid_alertsScalarWhereInput[]
  }

  export type prepaid_rechargesUncheckedUpdateManyWithoutPrepaid_accountsNestedInput = {
    create?: XOR<prepaid_rechargesCreateWithoutPrepaid_accountsInput, prepaid_rechargesUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_rechargesCreateWithoutPrepaid_accountsInput[] | prepaid_rechargesUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_rechargesCreateOrConnectWithoutPrepaid_accountsInput | prepaid_rechargesCreateOrConnectWithoutPrepaid_accountsInput[]
    upsert?: prepaid_rechargesUpsertWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_rechargesUpsertWithWhereUniqueWithoutPrepaid_accountsInput[]
    createMany?: prepaid_rechargesCreateManyPrepaid_accountsInputEnvelope
    set?: prepaid_rechargesWhereUniqueInput | prepaid_rechargesWhereUniqueInput[]
    disconnect?: prepaid_rechargesWhereUniqueInput | prepaid_rechargesWhereUniqueInput[]
    delete?: prepaid_rechargesWhereUniqueInput | prepaid_rechargesWhereUniqueInput[]
    connect?: prepaid_rechargesWhereUniqueInput | prepaid_rechargesWhereUniqueInput[]
    update?: prepaid_rechargesUpdateWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_rechargesUpdateWithWhereUniqueWithoutPrepaid_accountsInput[]
    updateMany?: prepaid_rechargesUpdateManyWithWhereWithoutPrepaid_accountsInput | prepaid_rechargesUpdateManyWithWhereWithoutPrepaid_accountsInput[]
    deleteMany?: prepaid_rechargesScalarWhereInput | prepaid_rechargesScalarWhereInput[]
  }

  export type prepaid_transactionsUncheckedUpdateManyWithoutPrepaid_accountsNestedInput = {
    create?: XOR<prepaid_transactionsCreateWithoutPrepaid_accountsInput, prepaid_transactionsUncheckedCreateWithoutPrepaid_accountsInput> | prepaid_transactionsCreateWithoutPrepaid_accountsInput[] | prepaid_transactionsUncheckedCreateWithoutPrepaid_accountsInput[]
    connectOrCreate?: prepaid_transactionsCreateOrConnectWithoutPrepaid_accountsInput | prepaid_transactionsCreateOrConnectWithoutPrepaid_accountsInput[]
    upsert?: prepaid_transactionsUpsertWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_transactionsUpsertWithWhereUniqueWithoutPrepaid_accountsInput[]
    createMany?: prepaid_transactionsCreateManyPrepaid_accountsInputEnvelope
    set?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    disconnect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    delete?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    connect?: prepaid_transactionsWhereUniqueInput | prepaid_transactionsWhereUniqueInput[]
    update?: prepaid_transactionsUpdateWithWhereUniqueWithoutPrepaid_accountsInput | prepaid_transactionsUpdateWithWhereUniqueWithoutPrepaid_accountsInput[]
    updateMany?: prepaid_transactionsUpdateManyWithWhereWithoutPrepaid_accountsInput | prepaid_transactionsUpdateManyWithWhereWithoutPrepaid_accountsInput[]
    deleteMany?: prepaid_transactionsScalarWhereInput | prepaid_transactionsScalarWhereInput[]
  }

  export type prepaid_accountsCreateNestedOneWithoutPrepaid_alertsInput = {
    create?: XOR<prepaid_accountsCreateWithoutPrepaid_alertsInput, prepaid_accountsUncheckedCreateWithoutPrepaid_alertsInput>
    connectOrCreate?: prepaid_accountsCreateOrConnectWithoutPrepaid_alertsInput
    connect?: prepaid_accountsWhereUniqueInput
  }

  export type EnumPrepaidAlertTypeFieldUpdateOperationsInput = {
    set?: $Enums.PrepaidAlertType
  }

  export type EnumPrepaidAlertLevelFieldUpdateOperationsInput = {
    set?: $Enums.PrepaidAlertLevel
  }

  export type prepaid_accountsUpdateOneRequiredWithoutPrepaid_alertsNestedInput = {
    create?: XOR<prepaid_accountsCreateWithoutPrepaid_alertsInput, prepaid_accountsUncheckedCreateWithoutPrepaid_alertsInput>
    connectOrCreate?: prepaid_accountsCreateOrConnectWithoutPrepaid_alertsInput
    upsert?: prepaid_accountsUpsertWithoutPrepaid_alertsInput
    connect?: prepaid_accountsWhereUniqueInput
    update?: XOR<XOR<prepaid_accountsUpdateToOneWithWhereWithoutPrepaid_alertsInput, prepaid_accountsUpdateWithoutPrepaid_alertsInput>, prepaid_accountsUncheckedUpdateWithoutPrepaid_alertsInput>
  }

  export type prepaid_accountsCreateNestedOneWithoutPrepaid_rechargesInput = {
    create?: XOR<prepaid_accountsCreateWithoutPrepaid_rechargesInput, prepaid_accountsUncheckedCreateWithoutPrepaid_rechargesInput>
    connectOrCreate?: prepaid_accountsCreateOrConnectWithoutPrepaid_rechargesInput
    connect?: prepaid_accountsWhereUniqueInput
  }

  export type EnumPrepaidRechargeTypeFieldUpdateOperationsInput = {
    set?: $Enums.PrepaidRechargeType
  }

  export type EnumPrepaidRechargeSourceFieldUpdateOperationsInput = {
    set?: $Enums.PrepaidRechargeSource
  }

  export type prepaid_accountsUpdateOneRequiredWithoutPrepaid_rechargesNestedInput = {
    create?: XOR<prepaid_accountsCreateWithoutPrepaid_rechargesInput, prepaid_accountsUncheckedCreateWithoutPrepaid_rechargesInput>
    connectOrCreate?: prepaid_accountsCreateOrConnectWithoutPrepaid_rechargesInput
    upsert?: prepaid_accountsUpsertWithoutPrepaid_rechargesInput
    connect?: prepaid_accountsWhereUniqueInput
    update?: XOR<XOR<prepaid_accountsUpdateToOneWithWhereWithoutPrepaid_rechargesInput, prepaid_accountsUpdateWithoutPrepaid_rechargesInput>, prepaid_accountsUncheckedUpdateWithoutPrepaid_rechargesInput>
  }

  export type prepaid_accountsCreateNestedOneWithoutPrepaid_transactionsInput = {
    create?: XOR<prepaid_accountsCreateWithoutPrepaid_transactionsInput, prepaid_accountsUncheckedCreateWithoutPrepaid_transactionsInput>
    connectOrCreate?: prepaid_accountsCreateOrConnectWithoutPrepaid_transactionsInput
    connect?: prepaid_accountsWhereUniqueInput
  }

  export type meter_readingsCreateNestedOneWithoutPrepaid_transactionsInput = {
    create?: XOR<meter_readingsCreateWithoutPrepaid_transactionsInput, meter_readingsUncheckedCreateWithoutPrepaid_transactionsInput>
    connectOrCreate?: meter_readingsCreateOrConnectWithoutPrepaid_transactionsInput
    connect?: meter_readingsWhereUniqueInput
  }

  export type EnumPrepaidTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.PrepaidTransactionType
  }

  export type EnumPrepaidTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.PrepaidTransactionStatus
  }

  export type prepaid_accountsUpdateOneRequiredWithoutPrepaid_transactionsNestedInput = {
    create?: XOR<prepaid_accountsCreateWithoutPrepaid_transactionsInput, prepaid_accountsUncheckedCreateWithoutPrepaid_transactionsInput>
    connectOrCreate?: prepaid_accountsCreateOrConnectWithoutPrepaid_transactionsInput
    upsert?: prepaid_accountsUpsertWithoutPrepaid_transactionsInput
    connect?: prepaid_accountsWhereUniqueInput
    update?: XOR<XOR<prepaid_accountsUpdateToOneWithWhereWithoutPrepaid_transactionsInput, prepaid_accountsUpdateWithoutPrepaid_transactionsInput>, prepaid_accountsUncheckedUpdateWithoutPrepaid_transactionsInput>
  }

  export type meter_readingsUpdateOneWithoutPrepaid_transactionsNestedInput = {
    create?: XOR<meter_readingsCreateWithoutPrepaid_transactionsInput, meter_readingsUncheckedCreateWithoutPrepaid_transactionsInput>
    connectOrCreate?: meter_readingsCreateOrConnectWithoutPrepaid_transactionsInput
    upsert?: meter_readingsUpsertWithoutPrepaid_transactionsInput
    disconnect?: meter_readingsWhereInput | boolean
    delete?: meter_readingsWhereInput | boolean
    connect?: meter_readingsWhereUniqueInput
    update?: XOR<XOR<meter_readingsUpdateToOneWithWhereWithoutPrepaid_transactionsInput, meter_readingsUpdateWithoutPrepaid_transactionsInput>, meter_readingsUncheckedUpdateWithoutPrepaid_transactionsInput>
  }

  export type metersCreateNestedOneWithoutTamper_eventsInput = {
    create?: XOR<metersCreateWithoutTamper_eventsInput, metersUncheckedCreateWithoutTamper_eventsInput>
    connectOrCreate?: metersCreateOrConnectWithoutTamper_eventsInput
    connect?: metersWhereUniqueInput
  }

  export type EnumTamperTypeFieldUpdateOperationsInput = {
    set?: $Enums.TamperType
  }

  export type EnumTamperStatusFieldUpdateOperationsInput = {
    set?: $Enums.TamperStatus
  }

  export type metersUpdateOneRequiredWithoutTamper_eventsNestedInput = {
    create?: XOR<metersCreateWithoutTamper_eventsInput, metersUncheckedCreateWithoutTamper_eventsInput>
    connectOrCreate?: metersCreateOrConnectWithoutTamper_eventsInput
    upsert?: metersUpsertWithoutTamper_eventsInput
    connect?: metersWhereUniqueInput
    update?: XOR<XOR<metersUpdateToOneWithWhereWithoutTamper_eventsInput, metersUpdateWithoutTamper_eventsInput>, metersUncheckedUpdateWithoutTamper_eventsInput>
  }

  export type tariff_slabsCreateNestedManyWithoutTariffInput = {
    create?: XOR<tariff_slabsCreateWithoutTariffInput, tariff_slabsUncheckedCreateWithoutTariffInput> | tariff_slabsCreateWithoutTariffInput[] | tariff_slabsUncheckedCreateWithoutTariffInput[]
    connectOrCreate?: tariff_slabsCreateOrConnectWithoutTariffInput | tariff_slabsCreateOrConnectWithoutTariffInput[]
    createMany?: tariff_slabsCreateManyTariffInputEnvelope
    connect?: tariff_slabsWhereUniqueInput | tariff_slabsWhereUniqueInput[]
  }

  export type tariff_slabsUncheckedCreateNestedManyWithoutTariffInput = {
    create?: XOR<tariff_slabsCreateWithoutTariffInput, tariff_slabsUncheckedCreateWithoutTariffInput> | tariff_slabsCreateWithoutTariffInput[] | tariff_slabsUncheckedCreateWithoutTariffInput[]
    connectOrCreate?: tariff_slabsCreateOrConnectWithoutTariffInput | tariff_slabsCreateOrConnectWithoutTariffInput[]
    createMany?: tariff_slabsCreateManyTariffInputEnvelope
    connect?: tariff_slabsWhereUniqueInput | tariff_slabsWhereUniqueInput[]
  }

  export type tariff_slabsUpdateManyWithoutTariffNestedInput = {
    create?: XOR<tariff_slabsCreateWithoutTariffInput, tariff_slabsUncheckedCreateWithoutTariffInput> | tariff_slabsCreateWithoutTariffInput[] | tariff_slabsUncheckedCreateWithoutTariffInput[]
    connectOrCreate?: tariff_slabsCreateOrConnectWithoutTariffInput | tariff_slabsCreateOrConnectWithoutTariffInput[]
    upsert?: tariff_slabsUpsertWithWhereUniqueWithoutTariffInput | tariff_slabsUpsertWithWhereUniqueWithoutTariffInput[]
    createMany?: tariff_slabsCreateManyTariffInputEnvelope
    set?: tariff_slabsWhereUniqueInput | tariff_slabsWhereUniqueInput[]
    disconnect?: tariff_slabsWhereUniqueInput | tariff_slabsWhereUniqueInput[]
    delete?: tariff_slabsWhereUniqueInput | tariff_slabsWhereUniqueInput[]
    connect?: tariff_slabsWhereUniqueInput | tariff_slabsWhereUniqueInput[]
    update?: tariff_slabsUpdateWithWhereUniqueWithoutTariffInput | tariff_slabsUpdateWithWhereUniqueWithoutTariffInput[]
    updateMany?: tariff_slabsUpdateManyWithWhereWithoutTariffInput | tariff_slabsUpdateManyWithWhereWithoutTariffInput[]
    deleteMany?: tariff_slabsScalarWhereInput | tariff_slabsScalarWhereInput[]
  }

  export type tariff_slabsUncheckedUpdateManyWithoutTariffNestedInput = {
    create?: XOR<tariff_slabsCreateWithoutTariffInput, tariff_slabsUncheckedCreateWithoutTariffInput> | tariff_slabsCreateWithoutTariffInput[] | tariff_slabsUncheckedCreateWithoutTariffInput[]
    connectOrCreate?: tariff_slabsCreateOrConnectWithoutTariffInput | tariff_slabsCreateOrConnectWithoutTariffInput[]
    upsert?: tariff_slabsUpsertWithWhereUniqueWithoutTariffInput | tariff_slabsUpsertWithWhereUniqueWithoutTariffInput[]
    createMany?: tariff_slabsCreateManyTariffInputEnvelope
    set?: tariff_slabsWhereUniqueInput | tariff_slabsWhereUniqueInput[]
    disconnect?: tariff_slabsWhereUniqueInput | tariff_slabsWhereUniqueInput[]
    delete?: tariff_slabsWhereUniqueInput | tariff_slabsWhereUniqueInput[]
    connect?: tariff_slabsWhereUniqueInput | tariff_slabsWhereUniqueInput[]
    update?: tariff_slabsUpdateWithWhereUniqueWithoutTariffInput | tariff_slabsUpdateWithWhereUniqueWithoutTariffInput[]
    updateMany?: tariff_slabsUpdateManyWithWhereWithoutTariffInput | tariff_slabsUpdateManyWithWhereWithoutTariffInput[]
    deleteMany?: tariff_slabsScalarWhereInput | tariff_slabsScalarWhereInput[]
  }

  export type tariffCreateNestedOneWithoutTariff_slabsInput = {
    create?: XOR<tariffCreateWithoutTariff_slabsInput, tariffUncheckedCreateWithoutTariff_slabsInput>
    connectOrCreate?: tariffCreateOrConnectWithoutTariff_slabsInput
    connect?: tariffWhereUniqueInput
  }

  export type tariffUpdateOneRequiredWithoutTariff_slabsNestedInput = {
    create?: XOR<tariffCreateWithoutTariff_slabsInput, tariffUncheckedCreateWithoutTariff_slabsInput>
    connectOrCreate?: tariffCreateOrConnectWithoutTariff_slabsInput
    upsert?: tariffUpsertWithoutTariff_slabsInput
    connect?: tariffWhereUniqueInput
    update?: XOR<XOR<tariffUpdateToOneWithWhereWithoutTariff_slabsInput, tariffUpdateWithoutTariff_slabsInput>, tariffUncheckedUpdateWithoutTariff_slabsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBillStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusFilter<$PrismaModel> | $Enums.BillStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumBillStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillStatusFilter<$PrismaModel>
    _max?: NestedEnumBillStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumIdTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IdType | EnumIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdType[] | ListEnumIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdType[] | ListEnumIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdTypeFilter<$PrismaModel> | $Enums.IdType
  }

  export type NestedEnumConnectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionTypeFilter<$PrismaModel> | $Enums.ConnectionType
  }

  export type NestedEnumConsumerCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsumerCategory | EnumConsumerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ConsumerCategory[] | ListEnumConsumerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsumerCategory[] | ListEnumConsumerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumConsumerCategoryFilter<$PrismaModel> | $Enums.ConsumerCategory
  }

  export type NestedEnumBillingCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleFilter<$PrismaModel> | $Enums.BillingCycle
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumIdTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdType | EnumIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IdType[] | ListEnumIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdType[] | ListEnumIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIdTypeWithAggregatesFilter<$PrismaModel> | $Enums.IdType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdTypeFilter<$PrismaModel>
    _max?: NestedEnumIdTypeFilter<$PrismaModel>
  }

  export type NestedEnumConnectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConnectionType | EnumConnectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConnectionType[] | ListEnumConnectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConnectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConnectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConnectionTypeFilter<$PrismaModel>
    _max?: NestedEnumConnectionTypeFilter<$PrismaModel>
  }

  export type NestedEnumConsumerCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsumerCategory | EnumConsumerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ConsumerCategory[] | ListEnumConsumerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsumerCategory[] | ListEnumConsumerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumConsumerCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ConsumerCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsumerCategoryFilter<$PrismaModel>
    _max?: NestedEnumConsumerCategoryFilter<$PrismaModel>
  }

  export type NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel> | $Enums.BillingCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingCycleFilter<$PrismaModel>
    _max?: NestedEnumBillingCycleFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumFaultTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultType | EnumFaultTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FaultType[] | ListEnumFaultTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultType[] | ListEnumFaultTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultTypeFilter<$PrismaModel> | $Enums.FaultType
  }

  export type NestedEnumFaultSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultSeverity | EnumFaultSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.FaultSeverity[] | ListEnumFaultSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultSeverity[] | ListEnumFaultSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultSeverityFilter<$PrismaModel> | $Enums.FaultSeverity
  }

  export type NestedEnumFaultStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultStatus | EnumFaultStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FaultStatus[] | ListEnumFaultStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultStatus[] | ListEnumFaultStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultStatusFilter<$PrismaModel> | $Enums.FaultStatus
  }

  export type NestedEnumFaultTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultType | EnumFaultTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FaultType[] | ListEnumFaultTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultType[] | ListEnumFaultTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultTypeWithAggregatesFilter<$PrismaModel> | $Enums.FaultType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFaultTypeFilter<$PrismaModel>
    _max?: NestedEnumFaultTypeFilter<$PrismaModel>
  }

  export type NestedEnumFaultSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultSeverity | EnumFaultSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.FaultSeverity[] | ListEnumFaultSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultSeverity[] | ListEnumFaultSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultSeverityWithAggregatesFilter<$PrismaModel> | $Enums.FaultSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFaultSeverityFilter<$PrismaModel>
    _max?: NestedEnumFaultSeverityFilter<$PrismaModel>
  }

  export type NestedEnumFaultStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FaultStatus | EnumFaultStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FaultStatus[] | ListEnumFaultStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FaultStatus[] | ListEnumFaultStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFaultStatusWithAggregatesFilter<$PrismaModel> | $Enums.FaultStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFaultStatusFilter<$PrismaModel>
    _max?: NestedEnumFaultStatusFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeFilter<$PrismaModel> | $Enums.MaintenanceType
  }

  export type NestedEnumMaintenanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusFilter<$PrismaModel> | $Enums.MaintenanceStatus
  }

  export type NestedEnumMaintenanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumDTRReadingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRReadingType | EnumDTRReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DTRReadingType[] | ListEnumDTRReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRReadingType[] | ListEnumDTRReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRReadingTypeFilter<$PrismaModel> | $Enums.DTRReadingType
  }

  export type NestedEnumDTRReadingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRReadingType | EnumDTRReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DTRReadingType[] | ListEnumDTRReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRReadingType[] | ListEnumDTRReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRReadingTypeWithAggregatesFilter<$PrismaModel> | $Enums.DTRReadingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDTRReadingTypeFilter<$PrismaModel>
    _max?: NestedEnumDTRReadingTypeFilter<$PrismaModel>
  }

  export type NestedEnumDTRTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRType | EnumDTRTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DTRType[] | ListEnumDTRTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRType[] | ListEnumDTRTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRTypeFilter<$PrismaModel> | $Enums.DTRType
  }

  export type NestedEnumCoolingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CoolingType | EnumCoolingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CoolingType[] | ListEnumCoolingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoolingType[] | ListEnumCoolingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCoolingTypeFilter<$PrismaModel> | $Enums.CoolingType
  }

  export type NestedEnumOilTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OilType | EnumOilTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OilType[] | ListEnumOilTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OilType[] | ListEnumOilTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOilTypeNullableFilter<$PrismaModel> | $Enums.OilType | null
  }

  export type NestedEnumDTRStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRStatus | EnumDTRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DTRStatus[] | ListEnumDTRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRStatus[] | ListEnumDTRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRStatusFilter<$PrismaModel> | $Enums.DTRStatus
  }

  export type NestedEnumDTRTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRType | EnumDTRTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DTRType[] | ListEnumDTRTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRType[] | ListEnumDTRTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRTypeWithAggregatesFilter<$PrismaModel> | $Enums.DTRType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDTRTypeFilter<$PrismaModel>
    _max?: NestedEnumDTRTypeFilter<$PrismaModel>
  }

  export type NestedEnumCoolingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoolingType | EnumCoolingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CoolingType[] | ListEnumCoolingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoolingType[] | ListEnumCoolingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCoolingTypeWithAggregatesFilter<$PrismaModel> | $Enums.CoolingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoolingTypeFilter<$PrismaModel>
    _max?: NestedEnumCoolingTypeFilter<$PrismaModel>
  }

  export type NestedEnumOilTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OilType | EnumOilTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OilType[] | ListEnumOilTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OilType[] | ListEnumOilTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOilTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OilType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOilTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOilTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumDTRStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DTRStatus | EnumDTRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DTRStatus[] | ListEnumDTRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DTRStatus[] | ListEnumDTRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDTRStatusWithAggregatesFilter<$PrismaModel> | $Enums.DTRStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDTRStatusFilter<$PrismaModel>
    _max?: NestedEnumDTRStatusFilter<$PrismaModel>
  }

  export type NestedEnumReadingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingType | EnumReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingTypeFilter<$PrismaModel> | $Enums.ReadingType
  }

  export type NestedEnumReadingSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingSource | EnumReadingSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingSource[] | ListEnumReadingSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingSource[] | ListEnumReadingSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingSourceFilter<$PrismaModel> | $Enums.ReadingSource
  }

  export type NestedEnumReadingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingType | EnumReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReadingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReadingTypeFilter<$PrismaModel>
    _max?: NestedEnumReadingTypeFilter<$PrismaModel>
  }

  export type NestedEnumReadingSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingSource | EnumReadingSourceFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingSource[] | ListEnumReadingSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingSource[] | ListEnumReadingSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingSourceWithAggregatesFilter<$PrismaModel> | $Enums.ReadingSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReadingSourceFilter<$PrismaModel>
    _max?: NestedEnumReadingSourceFilter<$PrismaModel>
  }

  export type NestedEnumMeterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MeterType | EnumMeterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MeterType[] | ListEnumMeterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeterType[] | ListEnumMeterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMeterTypeFilter<$PrismaModel> | $Enums.MeterType
  }

  export type NestedEnumMeterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MeterStatus | EnumMeterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeterStatus[] | ListEnumMeterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeterStatus[] | ListEnumMeterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeterStatusFilter<$PrismaModel> | $Enums.MeterStatus
  }

  export type NestedEnumMeterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeterType | EnumMeterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MeterType[] | ListEnumMeterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeterType[] | ListEnumMeterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMeterTypeWithAggregatesFilter<$PrismaModel> | $Enums.MeterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeterTypeFilter<$PrismaModel>
    _max?: NestedEnumMeterTypeFilter<$PrismaModel>
  }

  export type NestedEnumMeterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeterStatus | EnumMeterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeterStatus[] | ListEnumMeterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeterStatus[] | ListEnumMeterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeterStatusWithAggregatesFilter<$PrismaModel> | $Enums.MeterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeterStatusFilter<$PrismaModel>
    _max?: NestedEnumMeterStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type NestedEnumTicketTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeFilter<$PrismaModel> | $Enums.TicketType
  }

  export type NestedEnumTicketCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryFilter<$PrismaModel> | $Enums.TicketCategory
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel> | $Enums.TicketType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketTypeFilter<$PrismaModel>
    _max?: NestedEnumTicketTypeFilter<$PrismaModel>
  }

  export type NestedEnumTicketCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TicketCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketCategoryFilter<$PrismaModel>
    _max?: NestedEnumTicketCategoryFilter<$PrismaModel>
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumPrepaidAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidAlertType | EnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidAlertType[] | ListEnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidAlertType[] | ListEnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidAlertTypeFilter<$PrismaModel> | $Enums.PrepaidAlertType
  }

  export type NestedEnumPrepaidAlertLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidAlertLevel | EnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidAlertLevel[] | ListEnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidAlertLevel[] | ListEnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidAlertLevelFilter<$PrismaModel> | $Enums.PrepaidAlertLevel
  }

  export type NestedEnumPrepaidAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidAlertType | EnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidAlertType[] | ListEnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidAlertType[] | ListEnumPrepaidAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidAlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumPrepaidAlertTypeFilter<$PrismaModel>
  }

  export type NestedEnumPrepaidAlertLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidAlertLevel | EnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidAlertLevel[] | ListEnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidAlertLevel[] | ListEnumPrepaidAlertLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidAlertLevelWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidAlertLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidAlertLevelFilter<$PrismaModel>
    _max?: NestedEnumPrepaidAlertLevelFilter<$PrismaModel>
  }

  export type NestedEnumPrepaidRechargeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidRechargeType | EnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidRechargeType[] | ListEnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidRechargeType[] | ListEnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidRechargeTypeFilter<$PrismaModel> | $Enums.PrepaidRechargeType
  }

  export type NestedEnumPrepaidRechargeSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidRechargeSource | EnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidRechargeSource[] | ListEnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidRechargeSource[] | ListEnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidRechargeSourceFilter<$PrismaModel> | $Enums.PrepaidRechargeSource
  }

  export type NestedEnumPrepaidRechargeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidRechargeType | EnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidRechargeType[] | ListEnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidRechargeType[] | ListEnumPrepaidRechargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidRechargeTypeWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidRechargeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidRechargeTypeFilter<$PrismaModel>
    _max?: NestedEnumPrepaidRechargeTypeFilter<$PrismaModel>
  }

  export type NestedEnumPrepaidRechargeSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidRechargeSource | EnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidRechargeSource[] | ListEnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidRechargeSource[] | ListEnumPrepaidRechargeSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidRechargeSourceWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidRechargeSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidRechargeSourceFilter<$PrismaModel>
    _max?: NestedEnumPrepaidRechargeSourceFilter<$PrismaModel>
  }

  export type NestedEnumPrepaidTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidTransactionType | EnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidTransactionType[] | ListEnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidTransactionType[] | ListEnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidTransactionTypeFilter<$PrismaModel> | $Enums.PrepaidTransactionType
  }

  export type NestedEnumPrepaidTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidTransactionStatus | EnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidTransactionStatus[] | ListEnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidTransactionStatus[] | ListEnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidTransactionStatusFilter<$PrismaModel> | $Enums.PrepaidTransactionStatus
  }

  export type NestedEnumPrepaidTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidTransactionType | EnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidTransactionType[] | ListEnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidTransactionType[] | ListEnumPrepaidTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumPrepaidTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPrepaidTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrepaidTransactionStatus | EnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrepaidTransactionStatus[] | ListEnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrepaidTransactionStatus[] | ListEnumPrepaidTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrepaidTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PrepaidTransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrepaidTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumPrepaidTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumTamperTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TamperType | EnumTamperTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TamperType[] | ListEnumTamperTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TamperType[] | ListEnumTamperTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTamperTypeFilter<$PrismaModel> | $Enums.TamperType
  }

  export type NestedEnumTamperStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TamperStatus | EnumTamperStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TamperStatus[] | ListEnumTamperStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TamperStatus[] | ListEnumTamperStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTamperStatusFilter<$PrismaModel> | $Enums.TamperStatus
  }

  export type NestedEnumTamperTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TamperType | EnumTamperTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TamperType[] | ListEnumTamperTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TamperType[] | ListEnumTamperTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTamperTypeWithAggregatesFilter<$PrismaModel> | $Enums.TamperType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTamperTypeFilter<$PrismaModel>
    _max?: NestedEnumTamperTypeFilter<$PrismaModel>
  }

  export type NestedEnumTamperStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TamperStatus | EnumTamperStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TamperStatus[] | ListEnumTamperStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TamperStatus[] | ListEnumTamperStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTamperStatusWithAggregatesFilter<$PrismaModel> | $Enums.TamperStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTamperStatusFilter<$PrismaModel>
    _max?: NestedEnumTamperStatusFilter<$PrismaModel>
  }

  export type consumersCreateWithoutBillsInput = {
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumer_documents?: consumer_documentsCreateNestedManyWithoutConsumersInput
    locations: locationsCreateNestedOneWithoutConsumersInput
    notifications?: notificationsCreateNestedManyWithoutConsumersInput
    prepaid_accounts?: prepaid_accountsCreateNestedOneWithoutConsumersInput
  }

  export type consumersUncheckedCreateWithoutBillsInput = {
    id?: number
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    locationId: number
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumer_documents?: consumer_documentsUncheckedCreateNestedManyWithoutConsumersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutConsumersInput
    prepaid_accounts?: prepaid_accountsUncheckedCreateNestedOneWithoutConsumersInput
  }

  export type consumersCreateOrConnectWithoutBillsInput = {
    where: consumersWhereUniqueInput
    create: XOR<consumersCreateWithoutBillsInput, consumersUncheckedCreateWithoutBillsInput>
  }

  export type metersCreateWithoutBillsInput = {
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    current_transformers?: current_transformersCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsCreateNestedManyWithoutMetersInput
    dtrs?: dtrsCreateNestedOneWithoutMetersInput
    locations: locationsCreateNestedOneWithoutMetersInput
    potential_transformers?: potential_transformersCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsCreateNestedManyWithoutMetersInput
  }

  export type metersUncheckedCreateWithoutBillsInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    locationId: number
    dtrId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    current_transformers?: current_transformersUncheckedCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsUncheckedCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutMetersInput
    potential_transformers?: potential_transformersUncheckedCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsUncheckedCreateNestedManyWithoutMetersInput
  }

  export type metersCreateOrConnectWithoutBillsInput = {
    where: metersWhereUniqueInput
    create: XOR<metersCreateWithoutBillsInput, metersUncheckedCreateWithoutBillsInput>
  }

  export type meter_readingsCreateWithoutBillsInput = {
    readingDate: Date | string
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh?: number | null
    kVARh?: number | null
    powerFactor?: number | null
    averagePF?: number | null
    minimumPF?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    averageVoltage?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    averageCurrent?: number | null
    isValid?: boolean
    validatedBy?: string | null
    validatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    kVA?: number | null
    kW?: number | null
    bphPowerFactor?: number | null
    frequency?: number | null
    rphPowerFactor?: number | null
    yphPowerFactor?: number | null
    meters: metersCreateNestedOneWithoutMeter_readingsInput
    prepaid_transactions?: prepaid_transactionsCreateNestedManyWithoutMeter_readingsInput
  }

  export type meter_readingsUncheckedCreateWithoutBillsInput = {
    id?: number
    meterId: number
    readingDate: Date | string
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh?: number | null
    kVARh?: number | null
    powerFactor?: number | null
    averagePF?: number | null
    minimumPF?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    averageVoltage?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    averageCurrent?: number | null
    isValid?: boolean
    validatedBy?: string | null
    validatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    kVA?: number | null
    kW?: number | null
    bphPowerFactor?: number | null
    frequency?: number | null
    rphPowerFactor?: number | null
    yphPowerFactor?: number | null
    prepaid_transactions?: prepaid_transactionsUncheckedCreateNestedManyWithoutMeter_readingsInput
  }

  export type meter_readingsCreateOrConnectWithoutBillsInput = {
    where: meter_readingsWhereUniqueInput
    create: XOR<meter_readingsCreateWithoutBillsInput, meter_readingsUncheckedCreateWithoutBillsInput>
  }

  export type meter_readingsCreateManyBillsInputEnvelope = {
    data: meter_readingsCreateManyBillsInput | meter_readingsCreateManyBillsInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutBillsInput = {
    transactionId: string
    amount: number
    paymentMode: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type paymentsUncheckedCreateWithoutBillsInput = {
    id?: number
    transactionId: string
    amount: number
    paymentMode: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type paymentsCreateOrConnectWithoutBillsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutBillsInput, paymentsUncheckedCreateWithoutBillsInput>
  }

  export type paymentsCreateManyBillsInputEnvelope = {
    data: paymentsCreateManyBillsInput | paymentsCreateManyBillsInput[]
    skipDuplicates?: boolean
  }

  export type consumersUpsertWithoutBillsInput = {
    update: XOR<consumersUpdateWithoutBillsInput, consumersUncheckedUpdateWithoutBillsInput>
    create: XOR<consumersCreateWithoutBillsInput, consumersUncheckedCreateWithoutBillsInput>
    where?: consumersWhereInput
  }

  export type consumersUpdateToOneWithWhereWithoutBillsInput = {
    where?: consumersWhereInput
    data: XOR<consumersUpdateWithoutBillsInput, consumersUncheckedUpdateWithoutBillsInput>
  }

  export type consumersUpdateWithoutBillsInput = {
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumer_documents?: consumer_documentsUpdateManyWithoutConsumersNestedInput
    locations?: locationsUpdateOneRequiredWithoutConsumersNestedInput
    notifications?: notificationsUpdateManyWithoutConsumersNestedInput
    prepaid_accounts?: prepaid_accountsUpdateOneWithoutConsumersNestedInput
  }

  export type consumersUncheckedUpdateWithoutBillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumer_documents?: consumer_documentsUncheckedUpdateManyWithoutConsumersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutConsumersNestedInput
    prepaid_accounts?: prepaid_accountsUncheckedUpdateOneWithoutConsumersNestedInput
  }

  export type metersUpsertWithoutBillsInput = {
    update: XOR<metersUpdateWithoutBillsInput, metersUncheckedUpdateWithoutBillsInput>
    create: XOR<metersCreateWithoutBillsInput, metersUncheckedCreateWithoutBillsInput>
    where?: metersWhereInput
  }

  export type metersUpdateToOneWithWhereWithoutBillsInput = {
    where?: metersWhereInput
    data: XOR<metersUpdateWithoutBillsInput, metersUncheckedUpdateWithoutBillsInput>
  }

  export type metersUpdateWithoutBillsInput = {
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    current_transformers?: current_transformersUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutMetersNestedInput
    dtrs?: dtrsUpdateOneWithoutMetersNestedInput
    locations?: locationsUpdateOneRequiredWithoutMetersNestedInput
    potential_transformers?: potential_transformersUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUpdateManyWithoutMetersNestedInput
  }

  export type metersUncheckedUpdateWithoutBillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    current_transformers?: current_transformersUncheckedUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUncheckedUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutMetersNestedInput
    potential_transformers?: potential_transformersUncheckedUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUncheckedUpdateManyWithoutMetersNestedInput
  }

  export type meter_readingsUpsertWithWhereUniqueWithoutBillsInput = {
    where: meter_readingsWhereUniqueInput
    update: XOR<meter_readingsUpdateWithoutBillsInput, meter_readingsUncheckedUpdateWithoutBillsInput>
    create: XOR<meter_readingsCreateWithoutBillsInput, meter_readingsUncheckedCreateWithoutBillsInput>
  }

  export type meter_readingsUpdateWithWhereUniqueWithoutBillsInput = {
    where: meter_readingsWhereUniqueInput
    data: XOR<meter_readingsUpdateWithoutBillsInput, meter_readingsUncheckedUpdateWithoutBillsInput>
  }

  export type meter_readingsUpdateManyWithWhereWithoutBillsInput = {
    where: meter_readingsScalarWhereInput
    data: XOR<meter_readingsUpdateManyMutationInput, meter_readingsUncheckedUpdateManyWithoutBillsInput>
  }

  export type meter_readingsScalarWhereInput = {
    AND?: meter_readingsScalarWhereInput | meter_readingsScalarWhereInput[]
    OR?: meter_readingsScalarWhereInput[]
    NOT?: meter_readingsScalarWhereInput | meter_readingsScalarWhereInput[]
    id?: IntFilter<"meter_readings"> | number
    meterId?: IntFilter<"meter_readings"> | number
    readingDate?: DateTimeFilter<"meter_readings"> | Date | string
    readingType?: EnumReadingTypeFilter<"meter_readings"> | $Enums.ReadingType
    readingSource?: EnumReadingSourceFilter<"meter_readings"> | $Enums.ReadingSource
    currentReading?: FloatFilter<"meter_readings"> | number
    previousReading?: FloatFilter<"meter_readings"> | number
    consumption?: FloatFilter<"meter_readings"> | number
    kWh?: FloatFilter<"meter_readings"> | number
    kVAh?: FloatNullableFilter<"meter_readings"> | number | null
    kVARh?: FloatNullableFilter<"meter_readings"> | number | null
    powerFactor?: FloatNullableFilter<"meter_readings"> | number | null
    averagePF?: FloatNullableFilter<"meter_readings"> | number | null
    minimumPF?: FloatNullableFilter<"meter_readings"> | number | null
    voltageR?: FloatNullableFilter<"meter_readings"> | number | null
    voltageY?: FloatNullableFilter<"meter_readings"> | number | null
    voltageB?: FloatNullableFilter<"meter_readings"> | number | null
    averageVoltage?: FloatNullableFilter<"meter_readings"> | number | null
    currentR?: FloatNullableFilter<"meter_readings"> | number | null
    currentY?: FloatNullableFilter<"meter_readings"> | number | null
    currentB?: FloatNullableFilter<"meter_readings"> | number | null
    averageCurrent?: FloatNullableFilter<"meter_readings"> | number | null
    isValid?: BoolFilter<"meter_readings"> | boolean
    validatedBy?: StringNullableFilter<"meter_readings"> | string | null
    validatedAt?: DateTimeNullableFilter<"meter_readings"> | Date | string | null
    billId?: IntNullableFilter<"meter_readings"> | number | null
    createdAt?: DateTimeFilter<"meter_readings"> | Date | string
    updatedAt?: DateTimeFilter<"meter_readings"> | Date | string
    kVA?: FloatNullableFilter<"meter_readings"> | number | null
    kW?: FloatNullableFilter<"meter_readings"> | number | null
    bphPowerFactor?: FloatNullableFilter<"meter_readings"> | number | null
    frequency?: FloatNullableFilter<"meter_readings"> | number | null
    rphPowerFactor?: FloatNullableFilter<"meter_readings"> | number | null
    yphPowerFactor?: FloatNullableFilter<"meter_readings"> | number | null
  }

  export type paymentsUpsertWithWhereUniqueWithoutBillsInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutBillsInput, paymentsUncheckedUpdateWithoutBillsInput>
    create: XOR<paymentsCreateWithoutBillsInput, paymentsUncheckedCreateWithoutBillsInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutBillsInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutBillsInput, paymentsUncheckedUpdateWithoutBillsInput>
  }

  export type paymentsUpdateManyWithWhereWithoutBillsInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutBillsInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: IntFilter<"payments"> | number
    transactionId?: StringFilter<"payments"> | string
    billId?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    paymentMode?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    gatewayResponse?: JsonNullableFilter<"payments">
    receiptNumber?: StringNullableFilter<"payments"> | string | null
    createdAt?: DateTimeFilter<"payments"> | Date | string
    updatedAt?: DateTimeFilter<"payments"> | Date | string
  }

  export type consumersCreateWithoutConsumer_documentsInput = {
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutConsumersInput
    locations: locationsCreateNestedOneWithoutConsumersInput
    notifications?: notificationsCreateNestedManyWithoutConsumersInput
    prepaid_accounts?: prepaid_accountsCreateNestedOneWithoutConsumersInput
  }

  export type consumersUncheckedCreateWithoutConsumer_documentsInput = {
    id?: number
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    locationId: number
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutConsumersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutConsumersInput
    prepaid_accounts?: prepaid_accountsUncheckedCreateNestedOneWithoutConsumersInput
  }

  export type consumersCreateOrConnectWithoutConsumer_documentsInput = {
    where: consumersWhereUniqueInput
    create: XOR<consumersCreateWithoutConsumer_documentsInput, consumersUncheckedCreateWithoutConsumer_documentsInput>
  }

  export type consumersUpsertWithoutConsumer_documentsInput = {
    update: XOR<consumersUpdateWithoutConsumer_documentsInput, consumersUncheckedUpdateWithoutConsumer_documentsInput>
    create: XOR<consumersCreateWithoutConsumer_documentsInput, consumersUncheckedCreateWithoutConsumer_documentsInput>
    where?: consumersWhereInput
  }

  export type consumersUpdateToOneWithWhereWithoutConsumer_documentsInput = {
    where?: consumersWhereInput
    data: XOR<consumersUpdateWithoutConsumer_documentsInput, consumersUncheckedUpdateWithoutConsumer_documentsInput>
  }

  export type consumersUpdateWithoutConsumer_documentsInput = {
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutConsumersNestedInput
    locations?: locationsUpdateOneRequiredWithoutConsumersNestedInput
    notifications?: notificationsUpdateManyWithoutConsumersNestedInput
    prepaid_accounts?: prepaid_accountsUpdateOneWithoutConsumersNestedInput
  }

  export type consumersUncheckedUpdateWithoutConsumer_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutConsumersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutConsumersNestedInput
    prepaid_accounts?: prepaid_accountsUncheckedUpdateOneWithoutConsumersNestedInput
  }

  export type billsCreateWithoutConsumersInput = {
    billNumber: string
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
    meters: metersCreateNestedOneWithoutBillsInput
    meter_readings?: meter_readingsCreateNestedManyWithoutBillsInput
    payments?: paymentsCreateNestedManyWithoutBillsInput
  }

  export type billsUncheckedCreateWithoutConsumersInput = {
    id?: number
    billNumber: string
    meterId: number
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutBillsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBillsInput
  }

  export type billsCreateOrConnectWithoutConsumersInput = {
    where: billsWhereUniqueInput
    create: XOR<billsCreateWithoutConsumersInput, billsUncheckedCreateWithoutConsumersInput>
  }

  export type billsCreateManyConsumersInputEnvelope = {
    data: billsCreateManyConsumersInput | billsCreateManyConsumersInput[]
    skipDuplicates?: boolean
  }

  export type consumer_documentsCreateWithoutConsumersInput = {
    type: $Enums.DocumentType
    number: string
    fileUrl: string
    verificationStatus?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type consumer_documentsUncheckedCreateWithoutConsumersInput = {
    id?: number
    type: $Enums.DocumentType
    number: string
    fileUrl: string
    verificationStatus?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type consumer_documentsCreateOrConnectWithoutConsumersInput = {
    where: consumer_documentsWhereUniqueInput
    create: XOR<consumer_documentsCreateWithoutConsumersInput, consumer_documentsUncheckedCreateWithoutConsumersInput>
  }

  export type consumer_documentsCreateManyConsumersInputEnvelope = {
    data: consumer_documentsCreateManyConsumersInput | consumer_documentsCreateManyConsumersInput[]
    skipDuplicates?: boolean
  }

  export type locationsCreateWithoutConsumersInput = {
    name: string
    code: string
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtrs?: dtrsCreateNestedManyWithoutLocationsInput
    location_types: location_typesCreateNestedOneWithoutLocationsInput
    locations?: locationsCreateNestedOneWithoutOther_locationsInput
    other_locations?: locationsCreateNestedManyWithoutLocationsInput
    meters?: metersCreateNestedManyWithoutLocationsInput
    users?: usersCreateNestedManyWithoutLocationsInput
  }

  export type locationsUncheckedCreateWithoutConsumersInput = {
    id?: number
    name: string
    code: string
    locationTypeId: number
    parentId?: number | null
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtrs?: dtrsUncheckedCreateNestedManyWithoutLocationsInput
    other_locations?: locationsUncheckedCreateNestedManyWithoutLocationsInput
    meters?: metersUncheckedCreateNestedManyWithoutLocationsInput
    users?: usersUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type locationsCreateOrConnectWithoutConsumersInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutConsumersInput, locationsUncheckedCreateWithoutConsumersInput>
  }

  export type notificationsCreateWithoutConsumersInput = {
    type: $Enums.NotificationType
    title: string
    message: string
    priority: $Enums.NotificationPriority
    channels?: notificationsCreatechannelsInput | $Enums.NotificationChannel[]
    status?: $Enums.NotificationStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notificationsUncheckedCreateWithoutConsumersInput = {
    id?: number
    type: $Enums.NotificationType
    title: string
    message: string
    priority: $Enums.NotificationPriority
    channels?: notificationsCreatechannelsInput | $Enums.NotificationChannel[]
    status?: $Enums.NotificationStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notificationsCreateOrConnectWithoutConsumersInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutConsumersInput, notificationsUncheckedCreateWithoutConsumersInput>
  }

  export type notificationsCreateManyConsumersInputEnvelope = {
    data: notificationsCreateManyConsumersInput | notificationsCreateManyConsumersInput[]
    skipDuplicates?: boolean
  }

  export type prepaid_accountsCreateWithoutConsumersInput = {
    accountNumber: string
    currentBalance?: number
    totalRecharged?: number
    totalConsumed?: number
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: string | null
    blockedAt?: Date | string | null
    blockedBy?: number | null
    lowBalanceThreshold?: number
    emergencyThreshold?: number
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: number | null
    autoRechargeThreshold?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    prepaid_alerts?: prepaid_alertsCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_recharges?: prepaid_rechargesCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_transactions?: prepaid_transactionsCreateNestedManyWithoutPrepaid_accountsInput
  }

  export type prepaid_accountsUncheckedCreateWithoutConsumersInput = {
    id?: number
    accountNumber: string
    currentBalance?: number
    totalRecharged?: number
    totalConsumed?: number
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: string | null
    blockedAt?: Date | string | null
    blockedBy?: number | null
    lowBalanceThreshold?: number
    emergencyThreshold?: number
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: number | null
    autoRechargeThreshold?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    prepaid_alerts?: prepaid_alertsUncheckedCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_recharges?: prepaid_rechargesUncheckedCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_transactions?: prepaid_transactionsUncheckedCreateNestedManyWithoutPrepaid_accountsInput
  }

  export type prepaid_accountsCreateOrConnectWithoutConsumersInput = {
    where: prepaid_accountsWhereUniqueInput
    create: XOR<prepaid_accountsCreateWithoutConsumersInput, prepaid_accountsUncheckedCreateWithoutConsumersInput>
  }

  export type billsUpsertWithWhereUniqueWithoutConsumersInput = {
    where: billsWhereUniqueInput
    update: XOR<billsUpdateWithoutConsumersInput, billsUncheckedUpdateWithoutConsumersInput>
    create: XOR<billsCreateWithoutConsumersInput, billsUncheckedCreateWithoutConsumersInput>
  }

  export type billsUpdateWithWhereUniqueWithoutConsumersInput = {
    where: billsWhereUniqueInput
    data: XOR<billsUpdateWithoutConsumersInput, billsUncheckedUpdateWithoutConsumersInput>
  }

  export type billsUpdateManyWithWhereWithoutConsumersInput = {
    where: billsScalarWhereInput
    data: XOR<billsUpdateManyMutationInput, billsUncheckedUpdateManyWithoutConsumersInput>
  }

  export type billsScalarWhereInput = {
    AND?: billsScalarWhereInput | billsScalarWhereInput[]
    OR?: billsScalarWhereInput[]
    NOT?: billsScalarWhereInput | billsScalarWhereInput[]
    id?: IntFilter<"bills"> | number
    billNumber?: StringFilter<"bills"> | string
    meterId?: IntFilter<"bills"> | number
    consumerId?: IntFilter<"bills"> | number
    billMonth?: IntFilter<"bills"> | number
    billYear?: IntFilter<"bills"> | number
    fromDate?: DateTimeFilter<"bills"> | Date | string
    toDate?: DateTimeFilter<"bills"> | Date | string
    dueDate?: DateTimeFilter<"bills"> | Date | string
    previousReading?: FloatFilter<"bills"> | number
    currentReading?: FloatFilter<"bills"> | number
    unitsConsumed?: FloatFilter<"bills"> | number
    fixedCharge?: FloatFilter<"bills"> | number
    energyCharge?: FloatFilter<"bills"> | number
    powerFactorCharge?: FloatNullableFilter<"bills"> | number | null
    otherCharges?: JsonNullableFilter<"bills">
    subTotal?: FloatFilter<"bills"> | number
    taxes?: JsonFilter<"bills">
    totalAmount?: FloatFilter<"bills"> | number
    status?: EnumBillStatusFilter<"bills"> | $Enums.BillStatus
    isPaid?: BoolFilter<"bills"> | boolean
    paidAmount?: FloatFilter<"bills"> | number
    createdAt?: DateTimeFilter<"bills"> | Date | string
    updatedAt?: DateTimeFilter<"bills"> | Date | string
  }

  export type consumer_documentsUpsertWithWhereUniqueWithoutConsumersInput = {
    where: consumer_documentsWhereUniqueInput
    update: XOR<consumer_documentsUpdateWithoutConsumersInput, consumer_documentsUncheckedUpdateWithoutConsumersInput>
    create: XOR<consumer_documentsCreateWithoutConsumersInput, consumer_documentsUncheckedCreateWithoutConsumersInput>
  }

  export type consumer_documentsUpdateWithWhereUniqueWithoutConsumersInput = {
    where: consumer_documentsWhereUniqueInput
    data: XOR<consumer_documentsUpdateWithoutConsumersInput, consumer_documentsUncheckedUpdateWithoutConsumersInput>
  }

  export type consumer_documentsUpdateManyWithWhereWithoutConsumersInput = {
    where: consumer_documentsScalarWhereInput
    data: XOR<consumer_documentsUpdateManyMutationInput, consumer_documentsUncheckedUpdateManyWithoutConsumersInput>
  }

  export type consumer_documentsScalarWhereInput = {
    AND?: consumer_documentsScalarWhereInput | consumer_documentsScalarWhereInput[]
    OR?: consumer_documentsScalarWhereInput[]
    NOT?: consumer_documentsScalarWhereInput | consumer_documentsScalarWhereInput[]
    id?: IntFilter<"consumer_documents"> | number
    consumerId?: IntFilter<"consumer_documents"> | number
    type?: EnumDocumentTypeFilter<"consumer_documents"> | $Enums.DocumentType
    number?: StringFilter<"consumer_documents"> | string
    fileUrl?: StringFilter<"consumer_documents"> | string
    verificationStatus?: EnumVerificationStatusFilter<"consumer_documents"> | $Enums.VerificationStatus
    createdAt?: DateTimeFilter<"consumer_documents"> | Date | string
    updatedAt?: DateTimeFilter<"consumer_documents"> | Date | string
  }

  export type locationsUpsertWithoutConsumersInput = {
    update: XOR<locationsUpdateWithoutConsumersInput, locationsUncheckedUpdateWithoutConsumersInput>
    create: XOR<locationsCreateWithoutConsumersInput, locationsUncheckedCreateWithoutConsumersInput>
    where?: locationsWhereInput
  }

  export type locationsUpdateToOneWithWhereWithoutConsumersInput = {
    where?: locationsWhereInput
    data: XOR<locationsUpdateWithoutConsumersInput, locationsUncheckedUpdateWithoutConsumersInput>
  }

  export type locationsUpdateWithoutConsumersInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtrs?: dtrsUpdateManyWithoutLocationsNestedInput
    location_types?: location_typesUpdateOneRequiredWithoutLocationsNestedInput
    locations?: locationsUpdateOneWithoutOther_locationsNestedInput
    other_locations?: locationsUpdateManyWithoutLocationsNestedInput
    meters?: metersUpdateManyWithoutLocationsNestedInput
    users?: usersUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateWithoutConsumersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationTypeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtrs?: dtrsUncheckedUpdateManyWithoutLocationsNestedInput
    other_locations?: locationsUncheckedUpdateManyWithoutLocationsNestedInput
    meters?: metersUncheckedUpdateManyWithoutLocationsNestedInput
    users?: usersUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type notificationsUpsertWithWhereUniqueWithoutConsumersInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutConsumersInput, notificationsUncheckedUpdateWithoutConsumersInput>
    create: XOR<notificationsCreateWithoutConsumersInput, notificationsUncheckedCreateWithoutConsumersInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutConsumersInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutConsumersInput, notificationsUncheckedUpdateWithoutConsumersInput>
  }

  export type notificationsUpdateManyWithWhereWithoutConsumersInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutConsumersInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: IntFilter<"notifications"> | number
    consumerId?: IntFilter<"notifications"> | number
    type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    priority?: EnumNotificationPriorityFilter<"notifications"> | $Enums.NotificationPriority
    channels?: EnumNotificationChannelNullableListFilter<"notifications">
    status?: EnumNotificationStatusFilter<"notifications"> | $Enums.NotificationStatus
    readAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    updatedAt?: DateTimeFilter<"notifications"> | Date | string
  }

  export type prepaid_accountsUpsertWithoutConsumersInput = {
    update: XOR<prepaid_accountsUpdateWithoutConsumersInput, prepaid_accountsUncheckedUpdateWithoutConsumersInput>
    create: XOR<prepaid_accountsCreateWithoutConsumersInput, prepaid_accountsUncheckedCreateWithoutConsumersInput>
    where?: prepaid_accountsWhereInput
  }

  export type prepaid_accountsUpdateToOneWithWhereWithoutConsumersInput = {
    where?: prepaid_accountsWhereInput
    data: XOR<prepaid_accountsUpdateWithoutConsumersInput, prepaid_accountsUncheckedUpdateWithoutConsumersInput>
  }

  export type prepaid_accountsUpdateWithoutConsumersInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepaid_alerts?: prepaid_alertsUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_recharges?: prepaid_rechargesUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_transactions?: prepaid_transactionsUpdateManyWithoutPrepaid_accountsNestedInput
  }

  export type prepaid_accountsUncheckedUpdateWithoutConsumersInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepaid_alerts?: prepaid_alertsUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_recharges?: prepaid_rechargesUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_transactions?: prepaid_transactionsUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
  }

  export type metersCreateWithoutCurrent_transformersInput = {
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsCreateNestedManyWithoutMetersInput
    dtrs?: dtrsCreateNestedOneWithoutMetersInput
    locations: locationsCreateNestedOneWithoutMetersInput
    potential_transformers?: potential_transformersCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsCreateNestedManyWithoutMetersInput
  }

  export type metersUncheckedCreateWithoutCurrent_transformersInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    locationId: number
    dtrId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsUncheckedCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutMetersInput
    potential_transformers?: potential_transformersUncheckedCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsUncheckedCreateNestedManyWithoutMetersInput
  }

  export type metersCreateOrConnectWithoutCurrent_transformersInput = {
    where: metersWhereUniqueInput
    create: XOR<metersCreateWithoutCurrent_transformersInput, metersUncheckedCreateWithoutCurrent_transformersInput>
  }

  export type metersUpsertWithoutCurrent_transformersInput = {
    update: XOR<metersUpdateWithoutCurrent_transformersInput, metersUncheckedUpdateWithoutCurrent_transformersInput>
    create: XOR<metersCreateWithoutCurrent_transformersInput, metersUncheckedCreateWithoutCurrent_transformersInput>
    where?: metersWhereInput
  }

  export type metersUpdateToOneWithWhereWithoutCurrent_transformersInput = {
    where?: metersWhereInput
    data: XOR<metersUpdateWithoutCurrent_transformersInput, metersUncheckedUpdateWithoutCurrent_transformersInput>
  }

  export type metersUpdateWithoutCurrent_transformersInput = {
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutMetersNestedInput
    dtrs?: dtrsUpdateOneWithoutMetersNestedInput
    locations?: locationsUpdateOneRequiredWithoutMetersNestedInput
    potential_transformers?: potential_transformersUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUpdateManyWithoutMetersNestedInput
  }

  export type metersUncheckedUpdateWithoutCurrent_transformersInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUncheckedUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutMetersNestedInput
    potential_transformers?: potential_transformersUncheckedUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUncheckedUpdateManyWithoutMetersNestedInput
  }

  export type departmentsCreateWithoutChildrenInput = {
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    parent?: departmentsCreateNestedOneWithoutChildrenInput
    users?: usersCreateNestedManyWithoutDepartmentsInput
  }

  export type departmentsUncheckedCreateWithoutChildrenInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    users?: usersUncheckedCreateNestedManyWithoutDepartmentsInput
  }

  export type departmentsCreateOrConnectWithoutChildrenInput = {
    where: departmentsWhereUniqueInput
    create: XOR<departmentsCreateWithoutChildrenInput, departmentsUncheckedCreateWithoutChildrenInput>
  }

  export type departmentsCreateWithoutParentInput = {
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    children?: departmentsCreateNestedManyWithoutParentInput
    users?: usersCreateNestedManyWithoutDepartmentsInput
  }

  export type departmentsUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    children?: departmentsUncheckedCreateNestedManyWithoutParentInput
    users?: usersUncheckedCreateNestedManyWithoutDepartmentsInput
  }

  export type departmentsCreateOrConnectWithoutParentInput = {
    where: departmentsWhereUniqueInput
    create: XOR<departmentsCreateWithoutParentInput, departmentsUncheckedCreateWithoutParentInput>
  }

  export type departmentsCreateManyParentInputEnvelope = {
    data: departmentsCreateManyParentInput | departmentsCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutDepartmentsInput = {
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedOneWithoutUsersInput
    roles?: rolesCreateNestedOneWithoutUsersInput
    locations?: locationsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutDepartmentsInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    roleId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyUncheckedCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsUncheckedCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsUncheckedCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutDepartmentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutDepartmentsInput, usersUncheckedCreateWithoutDepartmentsInput>
  }

  export type usersCreateManyDepartmentsInputEnvelope = {
    data: usersCreateManyDepartmentsInput | usersCreateManyDepartmentsInput[]
    skipDuplicates?: boolean
  }

  export type departmentsUpsertWithoutChildrenInput = {
    update: XOR<departmentsUpdateWithoutChildrenInput, departmentsUncheckedUpdateWithoutChildrenInput>
    create: XOR<departmentsCreateWithoutChildrenInput, departmentsUncheckedCreateWithoutChildrenInput>
    where?: departmentsWhereInput
  }

  export type departmentsUpdateToOneWithWhereWithoutChildrenInput = {
    where?: departmentsWhereInput
    data: XOR<departmentsUpdateWithoutChildrenInput, departmentsUncheckedUpdateWithoutChildrenInput>
  }

  export type departmentsUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: departmentsUpdateOneWithoutChildrenNestedInput
    users?: usersUpdateManyWithoutDepartmentsNestedInput
  }

  export type departmentsUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUncheckedUpdateManyWithoutDepartmentsNestedInput
  }

  export type departmentsUpsertWithWhereUniqueWithoutParentInput = {
    where: departmentsWhereUniqueInput
    update: XOR<departmentsUpdateWithoutParentInput, departmentsUncheckedUpdateWithoutParentInput>
    create: XOR<departmentsCreateWithoutParentInput, departmentsUncheckedCreateWithoutParentInput>
  }

  export type departmentsUpdateWithWhereUniqueWithoutParentInput = {
    where: departmentsWhereUniqueInput
    data: XOR<departmentsUpdateWithoutParentInput, departmentsUncheckedUpdateWithoutParentInput>
  }

  export type departmentsUpdateManyWithWhereWithoutParentInput = {
    where: departmentsScalarWhereInput
    data: XOR<departmentsUpdateManyMutationInput, departmentsUncheckedUpdateManyWithoutParentInput>
  }

  export type departmentsScalarWhereInput = {
    AND?: departmentsScalarWhereInput | departmentsScalarWhereInput[]
    OR?: departmentsScalarWhereInput[]
    NOT?: departmentsScalarWhereInput | departmentsScalarWhereInput[]
    id?: IntFilter<"departments"> | number
    name?: StringFilter<"departments"> | string
    code?: StringFilter<"departments"> | string
    description?: StringNullableFilter<"departments"> | string | null
    parentId?: IntNullableFilter<"departments"> | number | null
    isActive?: BoolFilter<"departments"> | boolean
    createdAt?: DateTimeFilter<"departments"> | Date | string
    updatedAt?: DateTimeFilter<"departments"> | Date | string
  }

  export type usersUpsertWithWhereUniqueWithoutDepartmentsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutDepartmentsInput, usersUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<usersCreateWithoutDepartmentsInput, usersUncheckedCreateWithoutDepartmentsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutDepartmentsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutDepartmentsInput, usersUncheckedUpdateWithoutDepartmentsInput>
  }

  export type usersUpdateManyWithWhereWithoutDepartmentsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutDepartmentsInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: IntFilter<"users"> | number
    username?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    firstName?: StringFilter<"users"> | string
    lastName?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    profileImage?: StringNullableFilter<"users"> | string | null
    isActive?: BoolFilter<"users"> | boolean
    isLocked?: BoolFilter<"users"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"users"> | Date | string | null
    passwordChangedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    failedLoginAttempts?: IntFilter<"users"> | number
    lockoutUntil?: DateTimeNullableFilter<"users"> | Date | string | null
    departmentId?: IntNullableFilter<"users"> | number | null
    roleId?: IntNullableFilter<"users"> | number | null
    locationId?: IntNullableFilter<"users"> | number | null
    accessLevel?: EnumAccessLevelFilter<"users"> | $Enums.AccessLevel
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    createdBy?: IntNullableFilter<"users"> | number | null
    updatedBy?: IntNullableFilter<"users"> | number | null
  }

  export type dtrsCreateWithoutDtr_faultsInput = {
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_maintenance?: dtr_maintenanceCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsCreateNestedManyWithoutDtrsInput
    locations: locationsCreateNestedOneWithoutDtrsInput
    meters?: metersCreateNestedManyWithoutDtrsInput
    tickets?: ticketsCreateNestedManyWithoutDtrsInput
  }

  export type dtrsUncheckedCreateWithoutDtr_faultsInput = {
    id?: number
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    locationId: number
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_maintenance?: dtr_maintenanceUncheckedCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsUncheckedCreateNestedManyWithoutDtrsInput
    meters?: metersUncheckedCreateNestedManyWithoutDtrsInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutDtrsInput
  }

  export type dtrsCreateOrConnectWithoutDtr_faultsInput = {
    where: dtrsWhereUniqueInput
    create: XOR<dtrsCreateWithoutDtr_faultsInput, dtrsUncheckedCreateWithoutDtr_faultsInput>
  }

  export type dtrsUpsertWithoutDtr_faultsInput = {
    update: XOR<dtrsUpdateWithoutDtr_faultsInput, dtrsUncheckedUpdateWithoutDtr_faultsInput>
    create: XOR<dtrsCreateWithoutDtr_faultsInput, dtrsUncheckedCreateWithoutDtr_faultsInput>
    where?: dtrsWhereInput
  }

  export type dtrsUpdateToOneWithWhereWithoutDtr_faultsInput = {
    where?: dtrsWhereInput
    data: XOR<dtrsUpdateWithoutDtr_faultsInput, dtrsUncheckedUpdateWithoutDtr_faultsInput>
  }

  export type dtrsUpdateWithoutDtr_faultsInput = {
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_maintenance?: dtr_maintenanceUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUpdateManyWithoutDtrsNestedInput
    locations?: locationsUpdateOneRequiredWithoutDtrsNestedInput
    meters?: metersUpdateManyWithoutDtrsNestedInput
    tickets?: ticketsUpdateManyWithoutDtrsNestedInput
  }

  export type dtrsUncheckedUpdateWithoutDtr_faultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    locationId?: IntFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_maintenance?: dtr_maintenanceUncheckedUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUncheckedUpdateManyWithoutDtrsNestedInput
    meters?: metersUncheckedUpdateManyWithoutDtrsNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutDtrsNestedInput
  }

  export type dtrsCreateWithoutDtr_maintenanceInput = {
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsCreateNestedManyWithoutDtrsInput
    locations: locationsCreateNestedOneWithoutDtrsInput
    meters?: metersCreateNestedManyWithoutDtrsInput
    tickets?: ticketsCreateNestedManyWithoutDtrsInput
  }

  export type dtrsUncheckedCreateWithoutDtr_maintenanceInput = {
    id?: number
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    locationId: number
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsUncheckedCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsUncheckedCreateNestedManyWithoutDtrsInput
    meters?: metersUncheckedCreateNestedManyWithoutDtrsInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutDtrsInput
  }

  export type dtrsCreateOrConnectWithoutDtr_maintenanceInput = {
    where: dtrsWhereUniqueInput
    create: XOR<dtrsCreateWithoutDtr_maintenanceInput, dtrsUncheckedCreateWithoutDtr_maintenanceInput>
  }

  export type dtrsUpsertWithoutDtr_maintenanceInput = {
    update: XOR<dtrsUpdateWithoutDtr_maintenanceInput, dtrsUncheckedUpdateWithoutDtr_maintenanceInput>
    create: XOR<dtrsCreateWithoutDtr_maintenanceInput, dtrsUncheckedCreateWithoutDtr_maintenanceInput>
    where?: dtrsWhereInput
  }

  export type dtrsUpdateToOneWithWhereWithoutDtr_maintenanceInput = {
    where?: dtrsWhereInput
    data: XOR<dtrsUpdateWithoutDtr_maintenanceInput, dtrsUncheckedUpdateWithoutDtr_maintenanceInput>
  }

  export type dtrsUpdateWithoutDtr_maintenanceInput = {
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUpdateManyWithoutDtrsNestedInput
    locations?: locationsUpdateOneRequiredWithoutDtrsNestedInput
    meters?: metersUpdateManyWithoutDtrsNestedInput
    tickets?: ticketsUpdateManyWithoutDtrsNestedInput
  }

  export type dtrsUncheckedUpdateWithoutDtr_maintenanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    locationId?: IntFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUncheckedUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUncheckedUpdateManyWithoutDtrsNestedInput
    meters?: metersUncheckedUpdateManyWithoutDtrsNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutDtrsNestedInput
  }

  export type dtrsCreateWithoutDtr_readingsInput = {
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsCreateNestedManyWithoutDtrsInput
    dtr_maintenance?: dtr_maintenanceCreateNestedManyWithoutDtrsInput
    locations: locationsCreateNestedOneWithoutDtrsInput
    meters?: metersCreateNestedManyWithoutDtrsInput
    tickets?: ticketsCreateNestedManyWithoutDtrsInput
  }

  export type dtrsUncheckedCreateWithoutDtr_readingsInput = {
    id?: number
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    locationId: number
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsUncheckedCreateNestedManyWithoutDtrsInput
    dtr_maintenance?: dtr_maintenanceUncheckedCreateNestedManyWithoutDtrsInput
    meters?: metersUncheckedCreateNestedManyWithoutDtrsInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutDtrsInput
  }

  export type dtrsCreateOrConnectWithoutDtr_readingsInput = {
    where: dtrsWhereUniqueInput
    create: XOR<dtrsCreateWithoutDtr_readingsInput, dtrsUncheckedCreateWithoutDtr_readingsInput>
  }

  export type dtrsUpsertWithoutDtr_readingsInput = {
    update: XOR<dtrsUpdateWithoutDtr_readingsInput, dtrsUncheckedUpdateWithoutDtr_readingsInput>
    create: XOR<dtrsCreateWithoutDtr_readingsInput, dtrsUncheckedCreateWithoutDtr_readingsInput>
    where?: dtrsWhereInput
  }

  export type dtrsUpdateToOneWithWhereWithoutDtr_readingsInput = {
    where?: dtrsWhereInput
    data: XOR<dtrsUpdateWithoutDtr_readingsInput, dtrsUncheckedUpdateWithoutDtr_readingsInput>
  }

  export type dtrsUpdateWithoutDtr_readingsInput = {
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUpdateManyWithoutDtrsNestedInput
    dtr_maintenance?: dtr_maintenanceUpdateManyWithoutDtrsNestedInput
    locations?: locationsUpdateOneRequiredWithoutDtrsNestedInput
    meters?: metersUpdateManyWithoutDtrsNestedInput
    tickets?: ticketsUpdateManyWithoutDtrsNestedInput
  }

  export type dtrsUncheckedUpdateWithoutDtr_readingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    locationId?: IntFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUncheckedUpdateManyWithoutDtrsNestedInput
    dtr_maintenance?: dtr_maintenanceUncheckedUpdateManyWithoutDtrsNestedInput
    meters?: metersUncheckedUpdateManyWithoutDtrsNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutDtrsNestedInput
  }

  export type dtr_faultsCreateWithoutDtrsInput = {
    faultType: $Enums.FaultType
    severity: $Enums.FaultSeverity
    occuredAt: Date | string
    resolvedAt?: Date | string | null
    description: string
    rootCause?: string | null
    resolution?: string | null
    affectedMeters?: number | null
    outageMinutes?: number | null
    status?: $Enums.FaultStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_faultsUncheckedCreateWithoutDtrsInput = {
    id?: number
    faultType: $Enums.FaultType
    severity: $Enums.FaultSeverity
    occuredAt: Date | string
    resolvedAt?: Date | string | null
    description: string
    rootCause?: string | null
    resolution?: string | null
    affectedMeters?: number | null
    outageMinutes?: number | null
    status?: $Enums.FaultStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_faultsCreateOrConnectWithoutDtrsInput = {
    where: dtr_faultsWhereUniqueInput
    create: XOR<dtr_faultsCreateWithoutDtrsInput, dtr_faultsUncheckedCreateWithoutDtrsInput>
  }

  export type dtr_faultsCreateManyDtrsInputEnvelope = {
    data: dtr_faultsCreateManyDtrsInput | dtr_faultsCreateManyDtrsInput[]
    skipDuplicates?: boolean
  }

  export type dtr_maintenanceCreateWithoutDtrsInput = {
    maintenanceType: $Enums.MaintenanceType
    scheduledDate: Date | string
    completedDate?: Date | string | null
    workDone: string
    findings?: string | null
    recommendations?: string | null
    oilDielectricTest?: number | null
    oilAcidityTest?: number | null
    moistureContent?: number | null
    performedBy: string
    verifiedBy?: string | null
    status?: $Enums.MaintenanceStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_maintenanceUncheckedCreateWithoutDtrsInput = {
    id?: number
    maintenanceType: $Enums.MaintenanceType
    scheduledDate: Date | string
    completedDate?: Date | string | null
    workDone: string
    findings?: string | null
    recommendations?: string | null
    oilDielectricTest?: number | null
    oilAcidityTest?: number | null
    moistureContent?: number | null
    performedBy: string
    verifiedBy?: string | null
    status?: $Enums.MaintenanceStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_maintenanceCreateOrConnectWithoutDtrsInput = {
    where: dtr_maintenanceWhereUniqueInput
    create: XOR<dtr_maintenanceCreateWithoutDtrsInput, dtr_maintenanceUncheckedCreateWithoutDtrsInput>
  }

  export type dtr_maintenanceCreateManyDtrsInputEnvelope = {
    data: dtr_maintenanceCreateManyDtrsInput | dtr_maintenanceCreateManyDtrsInput[]
    skipDuplicates?: boolean
  }

  export type dtr_readingsCreateWithoutDtrsInput = {
    readingDate: Date | string
    readingType: $Enums.DTRReadingType
    loadKVA: number
    loadPercentage: number
    primaryVoltage: JsonNullValueInput | InputJsonValue
    secondaryVoltage: JsonNullValueInput | InputJsonValue
    primaryCurrent: JsonNullValueInput | InputJsonValue
    secondaryCurrent: JsonNullValueInput | InputJsonValue
    powerFactor?: number | null
    oilTemperature?: number | null
    windingTemperature?: number | null
    ambientTemperature?: number | null
    frequency?: number | null
    voltageUnbalance?: number | null
    currentUnbalance?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_readingsUncheckedCreateWithoutDtrsInput = {
    id?: number
    readingDate: Date | string
    readingType: $Enums.DTRReadingType
    loadKVA: number
    loadPercentage: number
    primaryVoltage: JsonNullValueInput | InputJsonValue
    secondaryVoltage: JsonNullValueInput | InputJsonValue
    primaryCurrent: JsonNullValueInput | InputJsonValue
    secondaryCurrent: JsonNullValueInput | InputJsonValue
    powerFactor?: number | null
    oilTemperature?: number | null
    windingTemperature?: number | null
    ambientTemperature?: number | null
    frequency?: number | null
    voltageUnbalance?: number | null
    currentUnbalance?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_readingsCreateOrConnectWithoutDtrsInput = {
    where: dtr_readingsWhereUniqueInput
    create: XOR<dtr_readingsCreateWithoutDtrsInput, dtr_readingsUncheckedCreateWithoutDtrsInput>
  }

  export type dtr_readingsCreateManyDtrsInputEnvelope = {
    data: dtr_readingsCreateManyDtrsInput | dtr_readingsCreateManyDtrsInput[]
    skipDuplicates?: boolean
  }

  export type locationsCreateWithoutDtrsInput = {
    name: string
    code: string
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersCreateNestedOneWithoutLocationsInput
    location_types: location_typesCreateNestedOneWithoutLocationsInput
    locations?: locationsCreateNestedOneWithoutOther_locationsInput
    other_locations?: locationsCreateNestedManyWithoutLocationsInput
    meters?: metersCreateNestedManyWithoutLocationsInput
    users?: usersCreateNestedManyWithoutLocationsInput
  }

  export type locationsUncheckedCreateWithoutDtrsInput = {
    id?: number
    name: string
    code: string
    locationTypeId: number
    parentId?: number | null
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersUncheckedCreateNestedOneWithoutLocationsInput
    other_locations?: locationsUncheckedCreateNestedManyWithoutLocationsInput
    meters?: metersUncheckedCreateNestedManyWithoutLocationsInput
    users?: usersUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type locationsCreateOrConnectWithoutDtrsInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutDtrsInput, locationsUncheckedCreateWithoutDtrsInput>
  }

  export type metersCreateWithoutDtrsInput = {
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsCreateNestedManyWithoutMetersInput
    locations: locationsCreateNestedOneWithoutMetersInput
    potential_transformers?: potential_transformersCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsCreateNestedManyWithoutMetersInput
  }

  export type metersUncheckedCreateWithoutDtrsInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    locationId: number
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersUncheckedCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsUncheckedCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutMetersInput
    potential_transformers?: potential_transformersUncheckedCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsUncheckedCreateNestedManyWithoutMetersInput
  }

  export type metersCreateOrConnectWithoutDtrsInput = {
    where: metersWhereUniqueInput
    create: XOR<metersCreateWithoutDtrsInput, metersUncheckedCreateWithoutDtrsInput>
  }

  export type metersCreateManyDtrsInputEnvelope = {
    data: metersCreateManyDtrsInput | metersCreateManyDtrsInput[]
    skipDuplicates?: boolean
  }

  export type ticketsCreateWithoutDtrsInput = {
    ticketNumber: string
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_tickets_assignedToIdTousers?: usersCreateNestedOneWithoutTickets_tickets_assignedToIdTousersInput
    users_tickets_raisedByIdTousers: usersCreateNestedOneWithoutTickets_tickets_raisedByIdTousersInput
  }

  export type ticketsUncheckedCreateWithoutDtrsInput = {
    id?: number
    ticketNumber: string
    raisedById: number
    assignedToId?: number | null
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ticketsCreateOrConnectWithoutDtrsInput = {
    where: ticketsWhereUniqueInput
    create: XOR<ticketsCreateWithoutDtrsInput, ticketsUncheckedCreateWithoutDtrsInput>
  }

  export type ticketsCreateManyDtrsInputEnvelope = {
    data: ticketsCreateManyDtrsInput | ticketsCreateManyDtrsInput[]
    skipDuplicates?: boolean
  }

  export type dtr_faultsUpsertWithWhereUniqueWithoutDtrsInput = {
    where: dtr_faultsWhereUniqueInput
    update: XOR<dtr_faultsUpdateWithoutDtrsInput, dtr_faultsUncheckedUpdateWithoutDtrsInput>
    create: XOR<dtr_faultsCreateWithoutDtrsInput, dtr_faultsUncheckedCreateWithoutDtrsInput>
  }

  export type dtr_faultsUpdateWithWhereUniqueWithoutDtrsInput = {
    where: dtr_faultsWhereUniqueInput
    data: XOR<dtr_faultsUpdateWithoutDtrsInput, dtr_faultsUncheckedUpdateWithoutDtrsInput>
  }

  export type dtr_faultsUpdateManyWithWhereWithoutDtrsInput = {
    where: dtr_faultsScalarWhereInput
    data: XOR<dtr_faultsUpdateManyMutationInput, dtr_faultsUncheckedUpdateManyWithoutDtrsInput>
  }

  export type dtr_faultsScalarWhereInput = {
    AND?: dtr_faultsScalarWhereInput | dtr_faultsScalarWhereInput[]
    OR?: dtr_faultsScalarWhereInput[]
    NOT?: dtr_faultsScalarWhereInput | dtr_faultsScalarWhereInput[]
    id?: IntFilter<"dtr_faults"> | number
    dtrId?: IntFilter<"dtr_faults"> | number
    faultType?: EnumFaultTypeFilter<"dtr_faults"> | $Enums.FaultType
    severity?: EnumFaultSeverityFilter<"dtr_faults"> | $Enums.FaultSeverity
    occuredAt?: DateTimeFilter<"dtr_faults"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"dtr_faults"> | Date | string | null
    description?: StringFilter<"dtr_faults"> | string
    rootCause?: StringNullableFilter<"dtr_faults"> | string | null
    resolution?: StringNullableFilter<"dtr_faults"> | string | null
    affectedMeters?: IntNullableFilter<"dtr_faults"> | number | null
    outageMinutes?: IntNullableFilter<"dtr_faults"> | number | null
    status?: EnumFaultStatusFilter<"dtr_faults"> | $Enums.FaultStatus
    createdAt?: DateTimeFilter<"dtr_faults"> | Date | string
    updatedAt?: DateTimeFilter<"dtr_faults"> | Date | string
  }

  export type dtr_maintenanceUpsertWithWhereUniqueWithoutDtrsInput = {
    where: dtr_maintenanceWhereUniqueInput
    update: XOR<dtr_maintenanceUpdateWithoutDtrsInput, dtr_maintenanceUncheckedUpdateWithoutDtrsInput>
    create: XOR<dtr_maintenanceCreateWithoutDtrsInput, dtr_maintenanceUncheckedCreateWithoutDtrsInput>
  }

  export type dtr_maintenanceUpdateWithWhereUniqueWithoutDtrsInput = {
    where: dtr_maintenanceWhereUniqueInput
    data: XOR<dtr_maintenanceUpdateWithoutDtrsInput, dtr_maintenanceUncheckedUpdateWithoutDtrsInput>
  }

  export type dtr_maintenanceUpdateManyWithWhereWithoutDtrsInput = {
    where: dtr_maintenanceScalarWhereInput
    data: XOR<dtr_maintenanceUpdateManyMutationInput, dtr_maintenanceUncheckedUpdateManyWithoutDtrsInput>
  }

  export type dtr_maintenanceScalarWhereInput = {
    AND?: dtr_maintenanceScalarWhereInput | dtr_maintenanceScalarWhereInput[]
    OR?: dtr_maintenanceScalarWhereInput[]
    NOT?: dtr_maintenanceScalarWhereInput | dtr_maintenanceScalarWhereInput[]
    id?: IntFilter<"dtr_maintenance"> | number
    dtrId?: IntFilter<"dtr_maintenance"> | number
    maintenanceType?: EnumMaintenanceTypeFilter<"dtr_maintenance"> | $Enums.MaintenanceType
    scheduledDate?: DateTimeFilter<"dtr_maintenance"> | Date | string
    completedDate?: DateTimeNullableFilter<"dtr_maintenance"> | Date | string | null
    workDone?: StringFilter<"dtr_maintenance"> | string
    findings?: StringNullableFilter<"dtr_maintenance"> | string | null
    recommendations?: StringNullableFilter<"dtr_maintenance"> | string | null
    oilDielectricTest?: FloatNullableFilter<"dtr_maintenance"> | number | null
    oilAcidityTest?: FloatNullableFilter<"dtr_maintenance"> | number | null
    moistureContent?: FloatNullableFilter<"dtr_maintenance"> | number | null
    performedBy?: StringFilter<"dtr_maintenance"> | string
    verifiedBy?: StringNullableFilter<"dtr_maintenance"> | string | null
    status?: EnumMaintenanceStatusFilter<"dtr_maintenance"> | $Enums.MaintenanceStatus
    createdAt?: DateTimeFilter<"dtr_maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"dtr_maintenance"> | Date | string
  }

  export type dtr_readingsUpsertWithWhereUniqueWithoutDtrsInput = {
    where: dtr_readingsWhereUniqueInput
    update: XOR<dtr_readingsUpdateWithoutDtrsInput, dtr_readingsUncheckedUpdateWithoutDtrsInput>
    create: XOR<dtr_readingsCreateWithoutDtrsInput, dtr_readingsUncheckedCreateWithoutDtrsInput>
  }

  export type dtr_readingsUpdateWithWhereUniqueWithoutDtrsInput = {
    where: dtr_readingsWhereUniqueInput
    data: XOR<dtr_readingsUpdateWithoutDtrsInput, dtr_readingsUncheckedUpdateWithoutDtrsInput>
  }

  export type dtr_readingsUpdateManyWithWhereWithoutDtrsInput = {
    where: dtr_readingsScalarWhereInput
    data: XOR<dtr_readingsUpdateManyMutationInput, dtr_readingsUncheckedUpdateManyWithoutDtrsInput>
  }

  export type dtr_readingsScalarWhereInput = {
    AND?: dtr_readingsScalarWhereInput | dtr_readingsScalarWhereInput[]
    OR?: dtr_readingsScalarWhereInput[]
    NOT?: dtr_readingsScalarWhereInput | dtr_readingsScalarWhereInput[]
    id?: IntFilter<"dtr_readings"> | number
    dtrId?: IntFilter<"dtr_readings"> | number
    readingDate?: DateTimeFilter<"dtr_readings"> | Date | string
    readingType?: EnumDTRReadingTypeFilter<"dtr_readings"> | $Enums.DTRReadingType
    loadKVA?: FloatFilter<"dtr_readings"> | number
    loadPercentage?: FloatFilter<"dtr_readings"> | number
    primaryVoltage?: JsonFilter<"dtr_readings">
    secondaryVoltage?: JsonFilter<"dtr_readings">
    primaryCurrent?: JsonFilter<"dtr_readings">
    secondaryCurrent?: JsonFilter<"dtr_readings">
    powerFactor?: FloatNullableFilter<"dtr_readings"> | number | null
    oilTemperature?: FloatNullableFilter<"dtr_readings"> | number | null
    windingTemperature?: FloatNullableFilter<"dtr_readings"> | number | null
    ambientTemperature?: FloatNullableFilter<"dtr_readings"> | number | null
    frequency?: FloatNullableFilter<"dtr_readings"> | number | null
    voltageUnbalance?: FloatNullableFilter<"dtr_readings"> | number | null
    currentUnbalance?: FloatNullableFilter<"dtr_readings"> | number | null
    createdAt?: DateTimeFilter<"dtr_readings"> | Date | string
    updatedAt?: DateTimeFilter<"dtr_readings"> | Date | string
  }

  export type locationsUpsertWithoutDtrsInput = {
    update: XOR<locationsUpdateWithoutDtrsInput, locationsUncheckedUpdateWithoutDtrsInput>
    create: XOR<locationsCreateWithoutDtrsInput, locationsUncheckedCreateWithoutDtrsInput>
    where?: locationsWhereInput
  }

  export type locationsUpdateToOneWithWhereWithoutDtrsInput = {
    where?: locationsWhereInput
    data: XOR<locationsUpdateWithoutDtrsInput, locationsUncheckedUpdateWithoutDtrsInput>
  }

  export type locationsUpdateWithoutDtrsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneWithoutLocationsNestedInput
    location_types?: location_typesUpdateOneRequiredWithoutLocationsNestedInput
    locations?: locationsUpdateOneWithoutOther_locationsNestedInput
    other_locations?: locationsUpdateManyWithoutLocationsNestedInput
    meters?: metersUpdateManyWithoutLocationsNestedInput
    users?: usersUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateWithoutDtrsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationTypeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUncheckedUpdateOneWithoutLocationsNestedInput
    other_locations?: locationsUncheckedUpdateManyWithoutLocationsNestedInput
    meters?: metersUncheckedUpdateManyWithoutLocationsNestedInput
    users?: usersUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type metersUpsertWithWhereUniqueWithoutDtrsInput = {
    where: metersWhereUniqueInput
    update: XOR<metersUpdateWithoutDtrsInput, metersUncheckedUpdateWithoutDtrsInput>
    create: XOR<metersCreateWithoutDtrsInput, metersUncheckedCreateWithoutDtrsInput>
  }

  export type metersUpdateWithWhereUniqueWithoutDtrsInput = {
    where: metersWhereUniqueInput
    data: XOR<metersUpdateWithoutDtrsInput, metersUncheckedUpdateWithoutDtrsInput>
  }

  export type metersUpdateManyWithWhereWithoutDtrsInput = {
    where: metersScalarWhereInput
    data: XOR<metersUpdateManyMutationInput, metersUncheckedUpdateManyWithoutDtrsInput>
  }

  export type metersScalarWhereInput = {
    AND?: metersScalarWhereInput | metersScalarWhereInput[]
    OR?: metersScalarWhereInput[]
    NOT?: metersScalarWhereInput | metersScalarWhereInput[]
    id?: IntFilter<"meters"> | number
    meterNumber?: StringFilter<"meters"> | string
    serialNumber?: StringFilter<"meters"> | string
    manufacturer?: StringFilter<"meters"> | string
    model?: StringFilter<"meters"> | string
    type?: EnumMeterTypeFilter<"meters"> | $Enums.MeterType
    phase?: IntFilter<"meters"> | number
    status?: EnumMeterStatusFilter<"meters"> | $Enums.MeterStatus
    isInUse?: BoolFilter<"meters"> | boolean
    installationDate?: DateTimeFilter<"meters"> | Date | string
    lastMaintenanceDate?: DateTimeNullableFilter<"meters"> | Date | string | null
    decommissionDate?: DateTimeNullableFilter<"meters"> | Date | string | null
    locationId?: IntFilter<"meters"> | number
    dtrId?: IntNullableFilter<"meters"> | number | null
    createdAt?: DateTimeFilter<"meters"> | Date | string
    updatedAt?: DateTimeFilter<"meters"> | Date | string
  }

  export type ticketsUpsertWithWhereUniqueWithoutDtrsInput = {
    where: ticketsWhereUniqueInput
    update: XOR<ticketsUpdateWithoutDtrsInput, ticketsUncheckedUpdateWithoutDtrsInput>
    create: XOR<ticketsCreateWithoutDtrsInput, ticketsUncheckedCreateWithoutDtrsInput>
  }

  export type ticketsUpdateWithWhereUniqueWithoutDtrsInput = {
    where: ticketsWhereUniqueInput
    data: XOR<ticketsUpdateWithoutDtrsInput, ticketsUncheckedUpdateWithoutDtrsInput>
  }

  export type ticketsUpdateManyWithWhereWithoutDtrsInput = {
    where: ticketsScalarWhereInput
    data: XOR<ticketsUpdateManyMutationInput, ticketsUncheckedUpdateManyWithoutDtrsInput>
  }

  export type ticketsScalarWhereInput = {
    AND?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
    OR?: ticketsScalarWhereInput[]
    NOT?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
    id?: IntFilter<"tickets"> | number
    ticketNumber?: StringFilter<"tickets"> | string
    dtrId?: IntNullableFilter<"tickets"> | number | null
    raisedById?: IntFilter<"tickets"> | number
    assignedToId?: IntNullableFilter<"tickets"> | number | null
    type?: EnumTicketTypeFilter<"tickets"> | $Enums.TicketType
    category?: EnumTicketCategoryFilter<"tickets"> | $Enums.TicketCategory
    priority?: EnumTicketPriorityFilter<"tickets"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"tickets"> | $Enums.TicketStatus
    subject?: StringFilter<"tickets"> | string
    description?: StringFilter<"tickets"> | string
    resolution?: StringNullableFilter<"tickets"> | string | null
    createdAt?: DateTimeFilter<"tickets"> | Date | string
    updatedAt?: DateTimeFilter<"tickets"> | Date | string
  }

  export type locationsCreateWithoutLocation_typesInput = {
    name: string
    code: string
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsCreateNestedManyWithoutLocationsInput
    locations?: locationsCreateNestedOneWithoutOther_locationsInput
    other_locations?: locationsCreateNestedManyWithoutLocationsInput
    meters?: metersCreateNestedManyWithoutLocationsInput
    users?: usersCreateNestedManyWithoutLocationsInput
  }

  export type locationsUncheckedCreateWithoutLocation_typesInput = {
    id?: number
    name: string
    code: string
    parentId?: number | null
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersUncheckedCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsUncheckedCreateNestedManyWithoutLocationsInput
    other_locations?: locationsUncheckedCreateNestedManyWithoutLocationsInput
    meters?: metersUncheckedCreateNestedManyWithoutLocationsInput
    users?: usersUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type locationsCreateOrConnectWithoutLocation_typesInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutLocation_typesInput, locationsUncheckedCreateWithoutLocation_typesInput>
  }

  export type locationsCreateManyLocation_typesInputEnvelope = {
    data: locationsCreateManyLocation_typesInput | locationsCreateManyLocation_typesInput[]
    skipDuplicates?: boolean
  }

  export type locationsUpsertWithWhereUniqueWithoutLocation_typesInput = {
    where: locationsWhereUniqueInput
    update: XOR<locationsUpdateWithoutLocation_typesInput, locationsUncheckedUpdateWithoutLocation_typesInput>
    create: XOR<locationsCreateWithoutLocation_typesInput, locationsUncheckedCreateWithoutLocation_typesInput>
  }

  export type locationsUpdateWithWhereUniqueWithoutLocation_typesInput = {
    where: locationsWhereUniqueInput
    data: XOR<locationsUpdateWithoutLocation_typesInput, locationsUncheckedUpdateWithoutLocation_typesInput>
  }

  export type locationsUpdateManyWithWhereWithoutLocation_typesInput = {
    where: locationsScalarWhereInput
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyWithoutLocation_typesInput>
  }

  export type locationsScalarWhereInput = {
    AND?: locationsScalarWhereInput | locationsScalarWhereInput[]
    OR?: locationsScalarWhereInput[]
    NOT?: locationsScalarWhereInput | locationsScalarWhereInput[]
    id?: IntFilter<"locations"> | number
    name?: StringFilter<"locations"> | string
    code?: StringFilter<"locations"> | string
    locationTypeId?: IntFilter<"locations"> | number
    parentId?: IntNullableFilter<"locations"> | number | null
    latitude?: FloatNullableFilter<"locations"> | number | null
    longitude?: FloatNullableFilter<"locations"> | number | null
    address?: StringNullableFilter<"locations"> | string | null
    pincode?: StringNullableFilter<"locations"> | string | null
    createdAt?: DateTimeFilter<"locations"> | Date | string
    updatedAt?: DateTimeFilter<"locations"> | Date | string
  }

  export type consumersCreateWithoutLocationsInput = {
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutConsumersInput
    consumer_documents?: consumer_documentsCreateNestedManyWithoutConsumersInput
    notifications?: notificationsCreateNestedManyWithoutConsumersInput
    prepaid_accounts?: prepaid_accountsCreateNestedOneWithoutConsumersInput
  }

  export type consumersUncheckedCreateWithoutLocationsInput = {
    id?: number
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutConsumersInput
    consumer_documents?: consumer_documentsUncheckedCreateNestedManyWithoutConsumersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutConsumersInput
    prepaid_accounts?: prepaid_accountsUncheckedCreateNestedOneWithoutConsumersInput
  }

  export type consumersCreateOrConnectWithoutLocationsInput = {
    where: consumersWhereUniqueInput
    create: XOR<consumersCreateWithoutLocationsInput, consumersUncheckedCreateWithoutLocationsInput>
  }

  export type dtrsCreateWithoutLocationsInput = {
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsCreateNestedManyWithoutDtrsInput
    dtr_maintenance?: dtr_maintenanceCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsCreateNestedManyWithoutDtrsInput
    meters?: metersCreateNestedManyWithoutDtrsInput
    tickets?: ticketsCreateNestedManyWithoutDtrsInput
  }

  export type dtrsUncheckedCreateWithoutLocationsInput = {
    id?: number
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsUncheckedCreateNestedManyWithoutDtrsInput
    dtr_maintenance?: dtr_maintenanceUncheckedCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsUncheckedCreateNestedManyWithoutDtrsInput
    meters?: metersUncheckedCreateNestedManyWithoutDtrsInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutDtrsInput
  }

  export type dtrsCreateOrConnectWithoutLocationsInput = {
    where: dtrsWhereUniqueInput
    create: XOR<dtrsCreateWithoutLocationsInput, dtrsUncheckedCreateWithoutLocationsInput>
  }

  export type dtrsCreateManyLocationsInputEnvelope = {
    data: dtrsCreateManyLocationsInput | dtrsCreateManyLocationsInput[]
    skipDuplicates?: boolean
  }

  export type location_typesCreateWithoutLocationsInput = {
    name: string
    level: number
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type location_typesUncheckedCreateWithoutLocationsInput = {
    id?: number
    name: string
    level: number
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type location_typesCreateOrConnectWithoutLocationsInput = {
    where: location_typesWhereUniqueInput
    create: XOR<location_typesCreateWithoutLocationsInput, location_typesUncheckedCreateWithoutLocationsInput>
  }

  export type locationsCreateWithoutOther_locationsInput = {
    name: string
    code: string
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsCreateNestedManyWithoutLocationsInput
    location_types: location_typesCreateNestedOneWithoutLocationsInput
    locations?: locationsCreateNestedOneWithoutOther_locationsInput
    meters?: metersCreateNestedManyWithoutLocationsInput
    users?: usersCreateNestedManyWithoutLocationsInput
  }

  export type locationsUncheckedCreateWithoutOther_locationsInput = {
    id?: number
    name: string
    code: string
    locationTypeId: number
    parentId?: number | null
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersUncheckedCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsUncheckedCreateNestedManyWithoutLocationsInput
    meters?: metersUncheckedCreateNestedManyWithoutLocationsInput
    users?: usersUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type locationsCreateOrConnectWithoutOther_locationsInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutOther_locationsInput, locationsUncheckedCreateWithoutOther_locationsInput>
  }

  export type locationsCreateWithoutLocationsInput = {
    name: string
    code: string
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsCreateNestedManyWithoutLocationsInput
    location_types: location_typesCreateNestedOneWithoutLocationsInput
    other_locations?: locationsCreateNestedManyWithoutLocationsInput
    meters?: metersCreateNestedManyWithoutLocationsInput
    users?: usersCreateNestedManyWithoutLocationsInput
  }

  export type locationsUncheckedCreateWithoutLocationsInput = {
    id?: number
    name: string
    code: string
    locationTypeId: number
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersUncheckedCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsUncheckedCreateNestedManyWithoutLocationsInput
    other_locations?: locationsUncheckedCreateNestedManyWithoutLocationsInput
    meters?: metersUncheckedCreateNestedManyWithoutLocationsInput
    users?: usersUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type locationsCreateOrConnectWithoutLocationsInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutLocationsInput, locationsUncheckedCreateWithoutLocationsInput>
  }

  export type locationsCreateManyLocationsInputEnvelope = {
    data: locationsCreateManyLocationsInput | locationsCreateManyLocationsInput[]
    skipDuplicates?: boolean
  }

  export type metersCreateWithoutLocationsInput = {
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsCreateNestedManyWithoutMetersInput
    dtrs?: dtrsCreateNestedOneWithoutMetersInput
    potential_transformers?: potential_transformersCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsCreateNestedManyWithoutMetersInput
  }

  export type metersUncheckedCreateWithoutLocationsInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    dtrId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersUncheckedCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsUncheckedCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutMetersInput
    potential_transformers?: potential_transformersUncheckedCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsUncheckedCreateNestedManyWithoutMetersInput
  }

  export type metersCreateOrConnectWithoutLocationsInput = {
    where: metersWhereUniqueInput
    create: XOR<metersCreateWithoutLocationsInput, metersUncheckedCreateWithoutLocationsInput>
  }

  export type metersCreateManyLocationsInputEnvelope = {
    data: metersCreateManyLocationsInput | metersCreateManyLocationsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutLocationsInput = {
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedOneWithoutUsersInput
    departments?: departmentsCreateNestedOneWithoutUsersInput
    roles?: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutLocationsInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    roleId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyUncheckedCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsUncheckedCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsUncheckedCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutLocationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLocationsInput, usersUncheckedCreateWithoutLocationsInput>
  }

  export type usersCreateManyLocationsInputEnvelope = {
    data: usersCreateManyLocationsInput | usersCreateManyLocationsInput[]
    skipDuplicates?: boolean
  }

  export type consumersUpsertWithoutLocationsInput = {
    update: XOR<consumersUpdateWithoutLocationsInput, consumersUncheckedUpdateWithoutLocationsInput>
    create: XOR<consumersCreateWithoutLocationsInput, consumersUncheckedCreateWithoutLocationsInput>
    where?: consumersWhereInput
  }

  export type consumersUpdateToOneWithWhereWithoutLocationsInput = {
    where?: consumersWhereInput
    data: XOR<consumersUpdateWithoutLocationsInput, consumersUncheckedUpdateWithoutLocationsInput>
  }

  export type consumersUpdateWithoutLocationsInput = {
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutConsumersNestedInput
    consumer_documents?: consumer_documentsUpdateManyWithoutConsumersNestedInput
    notifications?: notificationsUpdateManyWithoutConsumersNestedInput
    prepaid_accounts?: prepaid_accountsUpdateOneWithoutConsumersNestedInput
  }

  export type consumersUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutConsumersNestedInput
    consumer_documents?: consumer_documentsUncheckedUpdateManyWithoutConsumersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutConsumersNestedInput
    prepaid_accounts?: prepaid_accountsUncheckedUpdateOneWithoutConsumersNestedInput
  }

  export type dtrsUpsertWithWhereUniqueWithoutLocationsInput = {
    where: dtrsWhereUniqueInput
    update: XOR<dtrsUpdateWithoutLocationsInput, dtrsUncheckedUpdateWithoutLocationsInput>
    create: XOR<dtrsCreateWithoutLocationsInput, dtrsUncheckedCreateWithoutLocationsInput>
  }

  export type dtrsUpdateWithWhereUniqueWithoutLocationsInput = {
    where: dtrsWhereUniqueInput
    data: XOR<dtrsUpdateWithoutLocationsInput, dtrsUncheckedUpdateWithoutLocationsInput>
  }

  export type dtrsUpdateManyWithWhereWithoutLocationsInput = {
    where: dtrsScalarWhereInput
    data: XOR<dtrsUpdateManyMutationInput, dtrsUncheckedUpdateManyWithoutLocationsInput>
  }

  export type dtrsScalarWhereInput = {
    AND?: dtrsScalarWhereInput | dtrsScalarWhereInput[]
    OR?: dtrsScalarWhereInput[]
    NOT?: dtrsScalarWhereInput | dtrsScalarWhereInput[]
    id?: IntFilter<"dtrs"> | number
    dtrNumber?: StringFilter<"dtrs"> | string
    serialNumber?: StringFilter<"dtrs"> | string
    manufacturer?: StringFilter<"dtrs"> | string
    model?: StringFilter<"dtrs"> | string
    capacity?: FloatFilter<"dtrs"> | number
    type?: EnumDTRTypeFilter<"dtrs"> | $Enums.DTRType
    phase?: IntFilter<"dtrs"> | number
    primaryVoltage?: FloatFilter<"dtrs"> | number
    secondaryVoltage?: FloatFilter<"dtrs"> | number
    frequency?: FloatFilter<"dtrs"> | number
    impedance?: FloatNullableFilter<"dtrs"> | number | null
    coolingType?: EnumCoolingTypeFilter<"dtrs"> | $Enums.CoolingType
    oilType?: EnumOilTypeNullableFilter<"dtrs"> | $Enums.OilType | null
    oilCapacity?: FloatNullableFilter<"dtrs"> | number | null
    locationId?: IntFilter<"dtrs"> | number
    installationDate?: DateTimeFilter<"dtrs"> | Date | string
    commissionDate?: DateTimeNullableFilter<"dtrs"> | Date | string | null
    lastMaintenanceDate?: DateTimeNullableFilter<"dtrs"> | Date | string | null
    maxLoadLimit?: FloatNullableFilter<"dtrs"> | number | null
    alarmThreshold?: FloatNullableFilter<"dtrs"> | number | null
    tripThreshold?: FloatNullableFilter<"dtrs"> | number | null
    status?: EnumDTRStatusFilter<"dtrs"> | $Enums.DTRStatus
    healthIndex?: IntNullableFilter<"dtrs"> | number | null
    temperature?: FloatNullableFilter<"dtrs"> | number | null
    loadPercentage?: FloatNullableFilter<"dtrs"> | number | null
    createdAt?: DateTimeFilter<"dtrs"> | Date | string
    updatedAt?: DateTimeFilter<"dtrs"> | Date | string
  }

  export type location_typesUpsertWithoutLocationsInput = {
    update: XOR<location_typesUpdateWithoutLocationsInput, location_typesUncheckedUpdateWithoutLocationsInput>
    create: XOR<location_typesCreateWithoutLocationsInput, location_typesUncheckedCreateWithoutLocationsInput>
    where?: location_typesWhereInput
  }

  export type location_typesUpdateToOneWithWhereWithoutLocationsInput = {
    where?: location_typesWhereInput
    data: XOR<location_typesUpdateWithoutLocationsInput, location_typesUncheckedUpdateWithoutLocationsInput>
  }

  export type location_typesUpdateWithoutLocationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type location_typesUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationsUpsertWithoutOther_locationsInput = {
    update: XOR<locationsUpdateWithoutOther_locationsInput, locationsUncheckedUpdateWithoutOther_locationsInput>
    create: XOR<locationsCreateWithoutOther_locationsInput, locationsUncheckedCreateWithoutOther_locationsInput>
    where?: locationsWhereInput
  }

  export type locationsUpdateToOneWithWhereWithoutOther_locationsInput = {
    where?: locationsWhereInput
    data: XOR<locationsUpdateWithoutOther_locationsInput, locationsUncheckedUpdateWithoutOther_locationsInput>
  }

  export type locationsUpdateWithoutOther_locationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUpdateManyWithoutLocationsNestedInput
    location_types?: location_typesUpdateOneRequiredWithoutLocationsNestedInput
    locations?: locationsUpdateOneWithoutOther_locationsNestedInput
    meters?: metersUpdateManyWithoutLocationsNestedInput
    users?: usersUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateWithoutOther_locationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationTypeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUncheckedUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUncheckedUpdateManyWithoutLocationsNestedInput
    meters?: metersUncheckedUpdateManyWithoutLocationsNestedInput
    users?: usersUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUpsertWithWhereUniqueWithoutLocationsInput = {
    where: locationsWhereUniqueInput
    update: XOR<locationsUpdateWithoutLocationsInput, locationsUncheckedUpdateWithoutLocationsInput>
    create: XOR<locationsCreateWithoutLocationsInput, locationsUncheckedCreateWithoutLocationsInput>
  }

  export type locationsUpdateWithWhereUniqueWithoutLocationsInput = {
    where: locationsWhereUniqueInput
    data: XOR<locationsUpdateWithoutLocationsInput, locationsUncheckedUpdateWithoutLocationsInput>
  }

  export type locationsUpdateManyWithWhereWithoutLocationsInput = {
    where: locationsScalarWhereInput
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyWithoutLocationsInput>
  }

  export type metersUpsertWithWhereUniqueWithoutLocationsInput = {
    where: metersWhereUniqueInput
    update: XOR<metersUpdateWithoutLocationsInput, metersUncheckedUpdateWithoutLocationsInput>
    create: XOR<metersCreateWithoutLocationsInput, metersUncheckedCreateWithoutLocationsInput>
  }

  export type metersUpdateWithWhereUniqueWithoutLocationsInput = {
    where: metersWhereUniqueInput
    data: XOR<metersUpdateWithoutLocationsInput, metersUncheckedUpdateWithoutLocationsInput>
  }

  export type metersUpdateManyWithWhereWithoutLocationsInput = {
    where: metersScalarWhereInput
    data: XOR<metersUpdateManyMutationInput, metersUncheckedUpdateManyWithoutLocationsInput>
  }

  export type usersUpsertWithWhereUniqueWithoutLocationsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutLocationsInput, usersUncheckedUpdateWithoutLocationsInput>
    create: XOR<usersCreateWithoutLocationsInput, usersUncheckedCreateWithoutLocationsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutLocationsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutLocationsInput, usersUncheckedUpdateWithoutLocationsInput>
  }

  export type usersUpdateManyWithWhereWithoutLocationsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutLocationsInput>
  }

  export type usersCreateWithoutLogin_historyInput = {
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    tickets_tickets_assignedToIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedOneWithoutUsersInput
    departments?: departmentsCreateNestedOneWithoutUsersInput
    roles?: rolesCreateNestedOneWithoutUsersInput
    locations?: locationsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutLogin_historyInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    roleId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsUncheckedCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsUncheckedCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutLogin_historyInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLogin_historyInput, usersUncheckedCreateWithoutLogin_historyInput>
  }

  export type usersUpsertWithoutLogin_historyInput = {
    update: XOR<usersUpdateWithoutLogin_historyInput, usersUncheckedUpdateWithoutLogin_historyInput>
    create: XOR<usersCreateWithoutLogin_historyInput, usersUncheckedCreateWithoutLogin_historyInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLogin_historyInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLogin_historyInput, usersUncheckedUpdateWithoutLogin_historyInput>
  }

  export type usersUpdateWithoutLogin_historyInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    tickets_tickets_assignedToIdTousers?: ticketsUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateOneWithoutUsersNestedInput
    departments?: departmentsUpdateOneWithoutUsersNestedInput
    roles?: rolesUpdateOneWithoutUsersNestedInput
    locations?: locationsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutLogin_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type metersCreateWithoutMeter_configurationsInput = {
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersCreateNestedManyWithoutMetersInput
    meter_readings?: meter_readingsCreateNestedManyWithoutMetersInput
    dtrs?: dtrsCreateNestedOneWithoutMetersInput
    locations: locationsCreateNestedOneWithoutMetersInput
    potential_transformers?: potential_transformersCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsCreateNestedManyWithoutMetersInput
  }

  export type metersUncheckedCreateWithoutMeter_configurationsInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    locationId: number
    dtrId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersUncheckedCreateNestedManyWithoutMetersInput
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutMetersInput
    potential_transformers?: potential_transformersUncheckedCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsUncheckedCreateNestedManyWithoutMetersInput
  }

  export type metersCreateOrConnectWithoutMeter_configurationsInput = {
    where: metersWhereUniqueInput
    create: XOR<metersCreateWithoutMeter_configurationsInput, metersUncheckedCreateWithoutMeter_configurationsInput>
  }

  export type metersUpsertWithoutMeter_configurationsInput = {
    update: XOR<metersUpdateWithoutMeter_configurationsInput, metersUncheckedUpdateWithoutMeter_configurationsInput>
    create: XOR<metersCreateWithoutMeter_configurationsInput, metersUncheckedCreateWithoutMeter_configurationsInput>
    where?: metersWhereInput
  }

  export type metersUpdateToOneWithWhereWithoutMeter_configurationsInput = {
    where?: metersWhereInput
    data: XOR<metersUpdateWithoutMeter_configurationsInput, metersUncheckedUpdateWithoutMeter_configurationsInput>
  }

  export type metersUpdateWithoutMeter_configurationsInput = {
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUpdateManyWithoutMetersNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutMetersNestedInput
    dtrs?: dtrsUpdateOneWithoutMetersNestedInput
    locations?: locationsUpdateOneRequiredWithoutMetersNestedInput
    potential_transformers?: potential_transformersUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUpdateManyWithoutMetersNestedInput
  }

  export type metersUncheckedUpdateWithoutMeter_configurationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUncheckedUpdateManyWithoutMetersNestedInput
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutMetersNestedInput
    potential_transformers?: potential_transformersUncheckedUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUncheckedUpdateManyWithoutMetersNestedInput
  }

  export type billsCreateWithoutMeter_readingsInput = {
    billNumber: string
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
    consumers: consumersCreateNestedOneWithoutBillsInput
    meters: metersCreateNestedOneWithoutBillsInput
    payments?: paymentsCreateNestedManyWithoutBillsInput
  }

  export type billsUncheckedCreateWithoutMeter_readingsInput = {
    id?: number
    billNumber: string
    meterId: number
    consumerId: number
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
    payments?: paymentsUncheckedCreateNestedManyWithoutBillsInput
  }

  export type billsCreateOrConnectWithoutMeter_readingsInput = {
    where: billsWhereUniqueInput
    create: XOR<billsCreateWithoutMeter_readingsInput, billsUncheckedCreateWithoutMeter_readingsInput>
  }

  export type metersCreateWithoutMeter_readingsInput = {
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsCreateNestedOneWithoutMetersInput
    dtrs?: dtrsCreateNestedOneWithoutMetersInput
    locations: locationsCreateNestedOneWithoutMetersInput
    potential_transformers?: potential_transformersCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsCreateNestedManyWithoutMetersInput
  }

  export type metersUncheckedCreateWithoutMeter_readingsInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    locationId: number
    dtrId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersUncheckedCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsUncheckedCreateNestedOneWithoutMetersInput
    potential_transformers?: potential_transformersUncheckedCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsUncheckedCreateNestedManyWithoutMetersInput
  }

  export type metersCreateOrConnectWithoutMeter_readingsInput = {
    where: metersWhereUniqueInput
    create: XOR<metersCreateWithoutMeter_readingsInput, metersUncheckedCreateWithoutMeter_readingsInput>
  }

  export type prepaid_transactionsCreateWithoutMeter_readingsInput = {
    transactionId: string
    transactionType: $Enums.PrepaidTransactionType
    amount: number
    balanceBefore: number
    balanceAfter: number
    consumptionKWh?: number | null
    ratePerUnit?: number | null
    fixedCharges?: number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.PrepaidTransactionStatus
    failureReason?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    prepaid_accounts: prepaid_accountsCreateNestedOneWithoutPrepaid_transactionsInput
  }

  export type prepaid_transactionsUncheckedCreateWithoutMeter_readingsInput = {
    id?: number
    accountId: number
    transactionId: string
    transactionType: $Enums.PrepaidTransactionType
    amount: number
    balanceBefore: number
    balanceAfter: number
    consumptionKWh?: number | null
    ratePerUnit?: number | null
    fixedCharges?: number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.PrepaidTransactionStatus
    failureReason?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_transactionsCreateOrConnectWithoutMeter_readingsInput = {
    where: prepaid_transactionsWhereUniqueInput
    create: XOR<prepaid_transactionsCreateWithoutMeter_readingsInput, prepaid_transactionsUncheckedCreateWithoutMeter_readingsInput>
  }

  export type prepaid_transactionsCreateManyMeter_readingsInputEnvelope = {
    data: prepaid_transactionsCreateManyMeter_readingsInput | prepaid_transactionsCreateManyMeter_readingsInput[]
    skipDuplicates?: boolean
  }

  export type billsUpsertWithoutMeter_readingsInput = {
    update: XOR<billsUpdateWithoutMeter_readingsInput, billsUncheckedUpdateWithoutMeter_readingsInput>
    create: XOR<billsCreateWithoutMeter_readingsInput, billsUncheckedCreateWithoutMeter_readingsInput>
    where?: billsWhereInput
  }

  export type billsUpdateToOneWithWhereWithoutMeter_readingsInput = {
    where?: billsWhereInput
    data: XOR<billsUpdateWithoutMeter_readingsInput, billsUncheckedUpdateWithoutMeter_readingsInput>
  }

  export type billsUpdateWithoutMeter_readingsInput = {
    billNumber?: StringFieldUpdateOperationsInput | string
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneRequiredWithoutBillsNestedInput
    meters?: metersUpdateOneRequiredWithoutBillsNestedInput
    payments?: paymentsUpdateManyWithoutBillsNestedInput
  }

  export type billsUncheckedUpdateWithoutMeter_readingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNumber?: StringFieldUpdateOperationsInput | string
    meterId?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: paymentsUncheckedUpdateManyWithoutBillsNestedInput
  }

  export type metersUpsertWithoutMeter_readingsInput = {
    update: XOR<metersUpdateWithoutMeter_readingsInput, metersUncheckedUpdateWithoutMeter_readingsInput>
    create: XOR<metersCreateWithoutMeter_readingsInput, metersUncheckedCreateWithoutMeter_readingsInput>
    where?: metersWhereInput
  }

  export type metersUpdateToOneWithWhereWithoutMeter_readingsInput = {
    where?: metersWhereInput
    data: XOR<metersUpdateWithoutMeter_readingsInput, metersUncheckedUpdateWithoutMeter_readingsInput>
  }

  export type metersUpdateWithoutMeter_readingsInput = {
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUpdateOneWithoutMetersNestedInput
    dtrs?: dtrsUpdateOneWithoutMetersNestedInput
    locations?: locationsUpdateOneRequiredWithoutMetersNestedInput
    potential_transformers?: potential_transformersUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUpdateManyWithoutMetersNestedInput
  }

  export type metersUncheckedUpdateWithoutMeter_readingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUncheckedUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUncheckedUpdateOneWithoutMetersNestedInput
    potential_transformers?: potential_transformersUncheckedUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUncheckedUpdateManyWithoutMetersNestedInput
  }

  export type prepaid_transactionsUpsertWithWhereUniqueWithoutMeter_readingsInput = {
    where: prepaid_transactionsWhereUniqueInput
    update: XOR<prepaid_transactionsUpdateWithoutMeter_readingsInput, prepaid_transactionsUncheckedUpdateWithoutMeter_readingsInput>
    create: XOR<prepaid_transactionsCreateWithoutMeter_readingsInput, prepaid_transactionsUncheckedCreateWithoutMeter_readingsInput>
  }

  export type prepaid_transactionsUpdateWithWhereUniqueWithoutMeter_readingsInput = {
    where: prepaid_transactionsWhereUniqueInput
    data: XOR<prepaid_transactionsUpdateWithoutMeter_readingsInput, prepaid_transactionsUncheckedUpdateWithoutMeter_readingsInput>
  }

  export type prepaid_transactionsUpdateManyWithWhereWithoutMeter_readingsInput = {
    where: prepaid_transactionsScalarWhereInput
    data: XOR<prepaid_transactionsUpdateManyMutationInput, prepaid_transactionsUncheckedUpdateManyWithoutMeter_readingsInput>
  }

  export type prepaid_transactionsScalarWhereInput = {
    AND?: prepaid_transactionsScalarWhereInput | prepaid_transactionsScalarWhereInput[]
    OR?: prepaid_transactionsScalarWhereInput[]
    NOT?: prepaid_transactionsScalarWhereInput | prepaid_transactionsScalarWhereInput[]
    id?: IntFilter<"prepaid_transactions"> | number
    accountId?: IntFilter<"prepaid_transactions"> | number
    transactionId?: StringFilter<"prepaid_transactions"> | string
    transactionType?: EnumPrepaidTransactionTypeFilter<"prepaid_transactions"> | $Enums.PrepaidTransactionType
    amount?: FloatFilter<"prepaid_transactions"> | number
    balanceBefore?: FloatFilter<"prepaid_transactions"> | number
    balanceAfter?: FloatFilter<"prepaid_transactions"> | number
    consumptionKWh?: FloatNullableFilter<"prepaid_transactions"> | number | null
    ratePerUnit?: FloatNullableFilter<"prepaid_transactions"> | number | null
    fixedCharges?: FloatNullableFilter<"prepaid_transactions"> | number | null
    taxes?: JsonNullableFilter<"prepaid_transactions">
    readingId?: IntNullableFilter<"prepaid_transactions"> | number | null
    status?: EnumPrepaidTransactionStatusFilter<"prepaid_transactions"> | $Enums.PrepaidTransactionStatus
    failureReason?: StringNullableFilter<"prepaid_transactions"> | string | null
    description?: StringNullableFilter<"prepaid_transactions"> | string | null
    metadata?: JsonNullableFilter<"prepaid_transactions">
    createdAt?: DateTimeFilter<"prepaid_transactions"> | Date | string
    updatedAt?: DateTimeFilter<"prepaid_transactions"> | Date | string
  }

  export type billsCreateWithoutMetersInput = {
    billNumber: string
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
    consumers: consumersCreateNestedOneWithoutBillsInput
    meter_readings?: meter_readingsCreateNestedManyWithoutBillsInput
    payments?: paymentsCreateNestedManyWithoutBillsInput
  }

  export type billsUncheckedCreateWithoutMetersInput = {
    id?: number
    billNumber: string
    consumerId: number
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutBillsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBillsInput
  }

  export type billsCreateOrConnectWithoutMetersInput = {
    where: billsWhereUniqueInput
    create: XOR<billsCreateWithoutMetersInput, billsUncheckedCreateWithoutMetersInput>
  }

  export type billsCreateManyMetersInputEnvelope = {
    data: billsCreateManyMetersInput | billsCreateManyMetersInput[]
    skipDuplicates?: boolean
  }

  export type current_transformersCreateWithoutMetersInput = {
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type current_transformersUncheckedCreateWithoutMetersInput = {
    id?: number
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type current_transformersCreateOrConnectWithoutMetersInput = {
    where: current_transformersWhereUniqueInput
    create: XOR<current_transformersCreateWithoutMetersInput, current_transformersUncheckedCreateWithoutMetersInput>
  }

  export type current_transformersCreateManyMetersInputEnvelope = {
    data: current_transformersCreateManyMetersInput | current_transformersCreateManyMetersInput[]
    skipDuplicates?: boolean
  }

  export type meter_configurationsCreateWithoutMetersInput = {
    ctRatio: string
    ctRatioPrimary: number
    ctRatioSecondary: number
    adoptedCTRatio?: string | null
    ctAccuracyClass?: string | null
    ctBurden?: number | null
    ptRatio: string
    ptRatioPrimary: number
    ptRatioSecondary: number
    adoptedPTRatio?: string | null
    ptAccuracyClass?: string | null
    ptBurden?: number | null
    mf: number
    vmf: number
    cmf: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type meter_configurationsUncheckedCreateWithoutMetersInput = {
    id?: number
    ctRatio: string
    ctRatioPrimary: number
    ctRatioSecondary: number
    adoptedCTRatio?: string | null
    ctAccuracyClass?: string | null
    ctBurden?: number | null
    ptRatio: string
    ptRatioPrimary: number
    ptRatioSecondary: number
    adoptedPTRatio?: string | null
    ptAccuracyClass?: string | null
    ptBurden?: number | null
    mf: number
    vmf: number
    cmf: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type meter_configurationsCreateOrConnectWithoutMetersInput = {
    where: meter_configurationsWhereUniqueInput
    create: XOR<meter_configurationsCreateWithoutMetersInput, meter_configurationsUncheckedCreateWithoutMetersInput>
  }

  export type meter_readingsCreateWithoutMetersInput = {
    readingDate: Date | string
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh?: number | null
    kVARh?: number | null
    powerFactor?: number | null
    averagePF?: number | null
    minimumPF?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    averageVoltage?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    averageCurrent?: number | null
    isValid?: boolean
    validatedBy?: string | null
    validatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    kVA?: number | null
    kW?: number | null
    bphPowerFactor?: number | null
    frequency?: number | null
    rphPowerFactor?: number | null
    yphPowerFactor?: number | null
    bills?: billsCreateNestedOneWithoutMeter_readingsInput
    prepaid_transactions?: prepaid_transactionsCreateNestedManyWithoutMeter_readingsInput
  }

  export type meter_readingsUncheckedCreateWithoutMetersInput = {
    id?: number
    readingDate: Date | string
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh?: number | null
    kVARh?: number | null
    powerFactor?: number | null
    averagePF?: number | null
    minimumPF?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    averageVoltage?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    averageCurrent?: number | null
    isValid?: boolean
    validatedBy?: string | null
    validatedAt?: Date | string | null
    billId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    kVA?: number | null
    kW?: number | null
    bphPowerFactor?: number | null
    frequency?: number | null
    rphPowerFactor?: number | null
    yphPowerFactor?: number | null
    prepaid_transactions?: prepaid_transactionsUncheckedCreateNestedManyWithoutMeter_readingsInput
  }

  export type meter_readingsCreateOrConnectWithoutMetersInput = {
    where: meter_readingsWhereUniqueInput
    create: XOR<meter_readingsCreateWithoutMetersInput, meter_readingsUncheckedCreateWithoutMetersInput>
  }

  export type meter_readingsCreateManyMetersInputEnvelope = {
    data: meter_readingsCreateManyMetersInput | meter_readingsCreateManyMetersInput[]
    skipDuplicates?: boolean
  }

  export type dtrsCreateWithoutMetersInput = {
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsCreateNestedManyWithoutDtrsInput
    dtr_maintenance?: dtr_maintenanceCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsCreateNestedManyWithoutDtrsInput
    locations: locationsCreateNestedOneWithoutDtrsInput
    tickets?: ticketsCreateNestedManyWithoutDtrsInput
  }

  export type dtrsUncheckedCreateWithoutMetersInput = {
    id?: number
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    locationId: number
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsUncheckedCreateNestedManyWithoutDtrsInput
    dtr_maintenance?: dtr_maintenanceUncheckedCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsUncheckedCreateNestedManyWithoutDtrsInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutDtrsInput
  }

  export type dtrsCreateOrConnectWithoutMetersInput = {
    where: dtrsWhereUniqueInput
    create: XOR<dtrsCreateWithoutMetersInput, dtrsUncheckedCreateWithoutMetersInput>
  }

  export type locationsCreateWithoutMetersInput = {
    name: string
    code: string
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsCreateNestedManyWithoutLocationsInput
    location_types: location_typesCreateNestedOneWithoutLocationsInput
    locations?: locationsCreateNestedOneWithoutOther_locationsInput
    other_locations?: locationsCreateNestedManyWithoutLocationsInput
    users?: usersCreateNestedManyWithoutLocationsInput
  }

  export type locationsUncheckedCreateWithoutMetersInput = {
    id?: number
    name: string
    code: string
    locationTypeId: number
    parentId?: number | null
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersUncheckedCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsUncheckedCreateNestedManyWithoutLocationsInput
    other_locations?: locationsUncheckedCreateNestedManyWithoutLocationsInput
    users?: usersUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type locationsCreateOrConnectWithoutMetersInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutMetersInput, locationsUncheckedCreateWithoutMetersInput>
  }

  export type potential_transformersCreateWithoutMetersInput = {
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type potential_transformersUncheckedCreateWithoutMetersInput = {
    id?: number
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type potential_transformersCreateOrConnectWithoutMetersInput = {
    where: potential_transformersWhereUniqueInput
    create: XOR<potential_transformersCreateWithoutMetersInput, potential_transformersUncheckedCreateWithoutMetersInput>
  }

  export type potential_transformersCreateManyMetersInputEnvelope = {
    data: potential_transformersCreateManyMetersInput | potential_transformersCreateManyMetersInput[]
    skipDuplicates?: boolean
  }

  export type tamper_eventsCreateWithoutMetersInput = {
    tamperDatetime?: Date | string
    tamperType: $Enums.TamperType
    tamperStatus: $Enums.TamperStatus
    avgCurrent?: number | null
    avgVoltage?: number | null
    avgPowerFactor?: number | null
    frequency?: number | null
    kwh?: number | null
    kwhExport?: number | null
    kwhImport?: number | null
    kwhNet?: number | null
    kwhTotal?: number | null
    kwExport?: number | null
    kwImport?: number | null
    kvaExport?: number | null
    kvaImport?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    powerFactorR?: number | null
    powerFactorY?: number | null
    powerFactorB?: number | null
    tamperCount?: number | null
    param1?: number | null
    param2?: number | null
    param3?: number | null
    param4?: number | null
    param5?: number | null
    isProcessed?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type tamper_eventsUncheckedCreateWithoutMetersInput = {
    id?: number
    tamperDatetime?: Date | string
    tamperType: $Enums.TamperType
    tamperStatus: $Enums.TamperStatus
    avgCurrent?: number | null
    avgVoltage?: number | null
    avgPowerFactor?: number | null
    frequency?: number | null
    kwh?: number | null
    kwhExport?: number | null
    kwhImport?: number | null
    kwhNet?: number | null
    kwhTotal?: number | null
    kwExport?: number | null
    kwImport?: number | null
    kvaExport?: number | null
    kvaImport?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    powerFactorR?: number | null
    powerFactorY?: number | null
    powerFactorB?: number | null
    tamperCount?: number | null
    param1?: number | null
    param2?: number | null
    param3?: number | null
    param4?: number | null
    param5?: number | null
    isProcessed?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type tamper_eventsCreateOrConnectWithoutMetersInput = {
    where: tamper_eventsWhereUniqueInput
    create: XOR<tamper_eventsCreateWithoutMetersInput, tamper_eventsUncheckedCreateWithoutMetersInput>
  }

  export type tamper_eventsCreateManyMetersInputEnvelope = {
    data: tamper_eventsCreateManyMetersInput | tamper_eventsCreateManyMetersInput[]
    skipDuplicates?: boolean
  }

  export type billsUpsertWithWhereUniqueWithoutMetersInput = {
    where: billsWhereUniqueInput
    update: XOR<billsUpdateWithoutMetersInput, billsUncheckedUpdateWithoutMetersInput>
    create: XOR<billsCreateWithoutMetersInput, billsUncheckedCreateWithoutMetersInput>
  }

  export type billsUpdateWithWhereUniqueWithoutMetersInput = {
    where: billsWhereUniqueInput
    data: XOR<billsUpdateWithoutMetersInput, billsUncheckedUpdateWithoutMetersInput>
  }

  export type billsUpdateManyWithWhereWithoutMetersInput = {
    where: billsScalarWhereInput
    data: XOR<billsUpdateManyMutationInput, billsUncheckedUpdateManyWithoutMetersInput>
  }

  export type current_transformersUpsertWithWhereUniqueWithoutMetersInput = {
    where: current_transformersWhereUniqueInput
    update: XOR<current_transformersUpdateWithoutMetersInput, current_transformersUncheckedUpdateWithoutMetersInput>
    create: XOR<current_transformersCreateWithoutMetersInput, current_transformersUncheckedCreateWithoutMetersInput>
  }

  export type current_transformersUpdateWithWhereUniqueWithoutMetersInput = {
    where: current_transformersWhereUniqueInput
    data: XOR<current_transformersUpdateWithoutMetersInput, current_transformersUncheckedUpdateWithoutMetersInput>
  }

  export type current_transformersUpdateManyWithWhereWithoutMetersInput = {
    where: current_transformersScalarWhereInput
    data: XOR<current_transformersUpdateManyMutationInput, current_transformersUncheckedUpdateManyWithoutMetersInput>
  }

  export type current_transformersScalarWhereInput = {
    AND?: current_transformersScalarWhereInput | current_transformersScalarWhereInput[]
    OR?: current_transformersScalarWhereInput[]
    NOT?: current_transformersScalarWhereInput | current_transformersScalarWhereInput[]
    id?: IntFilter<"current_transformers"> | number
    meterId?: IntFilter<"current_transformers"> | number
    serialNumber?: StringFilter<"current_transformers"> | string
    manufacturer?: StringFilter<"current_transformers"> | string
    model?: StringFilter<"current_transformers"> | string
    ratedPrimary?: FloatFilter<"current_transformers"> | number
    ratedSecondary?: FloatFilter<"current_transformers"> | number
    accuracyClass?: StringFilter<"current_transformers"> | string
    burden?: FloatFilter<"current_transformers"> | number
    installationDate?: DateTimeFilter<"current_transformers"> | Date | string
    lastTestedDate?: DateTimeNullableFilter<"current_transformers"> | Date | string | null
    nextTestDue?: DateTimeNullableFilter<"current_transformers"> | Date | string | null
    createdAt?: DateTimeFilter<"current_transformers"> | Date | string
    updatedAt?: DateTimeFilter<"current_transformers"> | Date | string
  }

  export type meter_configurationsUpsertWithoutMetersInput = {
    update: XOR<meter_configurationsUpdateWithoutMetersInput, meter_configurationsUncheckedUpdateWithoutMetersInput>
    create: XOR<meter_configurationsCreateWithoutMetersInput, meter_configurationsUncheckedCreateWithoutMetersInput>
    where?: meter_configurationsWhereInput
  }

  export type meter_configurationsUpdateToOneWithWhereWithoutMetersInput = {
    where?: meter_configurationsWhereInput
    data: XOR<meter_configurationsUpdateWithoutMetersInput, meter_configurationsUncheckedUpdateWithoutMetersInput>
  }

  export type meter_configurationsUpdateWithoutMetersInput = {
    ctRatio?: StringFieldUpdateOperationsInput | string
    ctRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ctRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedCTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ctAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ctBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    ptRatio?: StringFieldUpdateOperationsInput | string
    ptRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ptRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedPTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ptAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ptBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    mf?: FloatFieldUpdateOperationsInput | number
    vmf?: FloatFieldUpdateOperationsInput | number
    cmf?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_configurationsUncheckedUpdateWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    ctRatio?: StringFieldUpdateOperationsInput | string
    ctRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ctRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedCTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ctAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ctBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    ptRatio?: StringFieldUpdateOperationsInput | string
    ptRatioPrimary?: FloatFieldUpdateOperationsInput | number
    ptRatioSecondary?: FloatFieldUpdateOperationsInput | number
    adoptedPTRatio?: NullableStringFieldUpdateOperationsInput | string | null
    ptAccuracyClass?: NullableStringFieldUpdateOperationsInput | string | null
    ptBurden?: NullableFloatFieldUpdateOperationsInput | number | null
    mf?: FloatFieldUpdateOperationsInput | number
    vmf?: FloatFieldUpdateOperationsInput | number
    cmf?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_readingsUpsertWithWhereUniqueWithoutMetersInput = {
    where: meter_readingsWhereUniqueInput
    update: XOR<meter_readingsUpdateWithoutMetersInput, meter_readingsUncheckedUpdateWithoutMetersInput>
    create: XOR<meter_readingsCreateWithoutMetersInput, meter_readingsUncheckedCreateWithoutMetersInput>
  }

  export type meter_readingsUpdateWithWhereUniqueWithoutMetersInput = {
    where: meter_readingsWhereUniqueInput
    data: XOR<meter_readingsUpdateWithoutMetersInput, meter_readingsUncheckedUpdateWithoutMetersInput>
  }

  export type meter_readingsUpdateManyWithWhereWithoutMetersInput = {
    where: meter_readingsScalarWhereInput
    data: XOR<meter_readingsUpdateManyMutationInput, meter_readingsUncheckedUpdateManyWithoutMetersInput>
  }

  export type dtrsUpsertWithoutMetersInput = {
    update: XOR<dtrsUpdateWithoutMetersInput, dtrsUncheckedUpdateWithoutMetersInput>
    create: XOR<dtrsCreateWithoutMetersInput, dtrsUncheckedCreateWithoutMetersInput>
    where?: dtrsWhereInput
  }

  export type dtrsUpdateToOneWithWhereWithoutMetersInput = {
    where?: dtrsWhereInput
    data: XOR<dtrsUpdateWithoutMetersInput, dtrsUncheckedUpdateWithoutMetersInput>
  }

  export type dtrsUpdateWithoutMetersInput = {
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUpdateManyWithoutDtrsNestedInput
    dtr_maintenance?: dtr_maintenanceUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUpdateManyWithoutDtrsNestedInput
    locations?: locationsUpdateOneRequiredWithoutDtrsNestedInput
    tickets?: ticketsUpdateManyWithoutDtrsNestedInput
  }

  export type dtrsUncheckedUpdateWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    locationId?: IntFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUncheckedUpdateManyWithoutDtrsNestedInput
    dtr_maintenance?: dtr_maintenanceUncheckedUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUncheckedUpdateManyWithoutDtrsNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutDtrsNestedInput
  }

  export type locationsUpsertWithoutMetersInput = {
    update: XOR<locationsUpdateWithoutMetersInput, locationsUncheckedUpdateWithoutMetersInput>
    create: XOR<locationsCreateWithoutMetersInput, locationsUncheckedCreateWithoutMetersInput>
    where?: locationsWhereInput
  }

  export type locationsUpdateToOneWithWhereWithoutMetersInput = {
    where?: locationsWhereInput
    data: XOR<locationsUpdateWithoutMetersInput, locationsUncheckedUpdateWithoutMetersInput>
  }

  export type locationsUpdateWithoutMetersInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUpdateManyWithoutLocationsNestedInput
    location_types?: location_typesUpdateOneRequiredWithoutLocationsNestedInput
    locations?: locationsUpdateOneWithoutOther_locationsNestedInput
    other_locations?: locationsUpdateManyWithoutLocationsNestedInput
    users?: usersUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationTypeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUncheckedUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUncheckedUpdateManyWithoutLocationsNestedInput
    other_locations?: locationsUncheckedUpdateManyWithoutLocationsNestedInput
    users?: usersUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type potential_transformersUpsertWithWhereUniqueWithoutMetersInput = {
    where: potential_transformersWhereUniqueInput
    update: XOR<potential_transformersUpdateWithoutMetersInput, potential_transformersUncheckedUpdateWithoutMetersInput>
    create: XOR<potential_transformersCreateWithoutMetersInput, potential_transformersUncheckedCreateWithoutMetersInput>
  }

  export type potential_transformersUpdateWithWhereUniqueWithoutMetersInput = {
    where: potential_transformersWhereUniqueInput
    data: XOR<potential_transformersUpdateWithoutMetersInput, potential_transformersUncheckedUpdateWithoutMetersInput>
  }

  export type potential_transformersUpdateManyWithWhereWithoutMetersInput = {
    where: potential_transformersScalarWhereInput
    data: XOR<potential_transformersUpdateManyMutationInput, potential_transformersUncheckedUpdateManyWithoutMetersInput>
  }

  export type potential_transformersScalarWhereInput = {
    AND?: potential_transformersScalarWhereInput | potential_transformersScalarWhereInput[]
    OR?: potential_transformersScalarWhereInput[]
    NOT?: potential_transformersScalarWhereInput | potential_transformersScalarWhereInput[]
    id?: IntFilter<"potential_transformers"> | number
    meterId?: IntFilter<"potential_transformers"> | number
    serialNumber?: StringFilter<"potential_transformers"> | string
    manufacturer?: StringFilter<"potential_transformers"> | string
    model?: StringFilter<"potential_transformers"> | string
    ratedPrimary?: FloatFilter<"potential_transformers"> | number
    ratedSecondary?: FloatFilter<"potential_transformers"> | number
    accuracyClass?: StringFilter<"potential_transformers"> | string
    burden?: FloatFilter<"potential_transformers"> | number
    installationDate?: DateTimeFilter<"potential_transformers"> | Date | string
    lastTestedDate?: DateTimeNullableFilter<"potential_transformers"> | Date | string | null
    nextTestDue?: DateTimeNullableFilter<"potential_transformers"> | Date | string | null
    createdAt?: DateTimeFilter<"potential_transformers"> | Date | string
    updatedAt?: DateTimeFilter<"potential_transformers"> | Date | string
  }

  export type tamper_eventsUpsertWithWhereUniqueWithoutMetersInput = {
    where: tamper_eventsWhereUniqueInput
    update: XOR<tamper_eventsUpdateWithoutMetersInput, tamper_eventsUncheckedUpdateWithoutMetersInput>
    create: XOR<tamper_eventsCreateWithoutMetersInput, tamper_eventsUncheckedCreateWithoutMetersInput>
  }

  export type tamper_eventsUpdateWithWhereUniqueWithoutMetersInput = {
    where: tamper_eventsWhereUniqueInput
    data: XOR<tamper_eventsUpdateWithoutMetersInput, tamper_eventsUncheckedUpdateWithoutMetersInput>
  }

  export type tamper_eventsUpdateManyWithWhereWithoutMetersInput = {
    where: tamper_eventsScalarWhereInput
    data: XOR<tamper_eventsUpdateManyMutationInput, tamper_eventsUncheckedUpdateManyWithoutMetersInput>
  }

  export type tamper_eventsScalarWhereInput = {
    AND?: tamper_eventsScalarWhereInput | tamper_eventsScalarWhereInput[]
    OR?: tamper_eventsScalarWhereInput[]
    NOT?: tamper_eventsScalarWhereInput | tamper_eventsScalarWhereInput[]
    id?: IntFilter<"tamper_events"> | number
    meterId?: IntFilter<"tamper_events"> | number
    tamperDatetime?: DateTimeFilter<"tamper_events"> | Date | string
    tamperType?: EnumTamperTypeFilter<"tamper_events"> | $Enums.TamperType
    tamperStatus?: EnumTamperStatusFilter<"tamper_events"> | $Enums.TamperStatus
    avgCurrent?: FloatNullableFilter<"tamper_events"> | number | null
    avgVoltage?: FloatNullableFilter<"tamper_events"> | number | null
    avgPowerFactor?: FloatNullableFilter<"tamper_events"> | number | null
    frequency?: FloatNullableFilter<"tamper_events"> | number | null
    kwh?: FloatNullableFilter<"tamper_events"> | number | null
    kwhExport?: FloatNullableFilter<"tamper_events"> | number | null
    kwhImport?: FloatNullableFilter<"tamper_events"> | number | null
    kwhNet?: FloatNullableFilter<"tamper_events"> | number | null
    kwhTotal?: FloatNullableFilter<"tamper_events"> | number | null
    kwExport?: FloatNullableFilter<"tamper_events"> | number | null
    kwImport?: FloatNullableFilter<"tamper_events"> | number | null
    kvaExport?: FloatNullableFilter<"tamper_events"> | number | null
    kvaImport?: FloatNullableFilter<"tamper_events"> | number | null
    voltageR?: FloatNullableFilter<"tamper_events"> | number | null
    voltageY?: FloatNullableFilter<"tamper_events"> | number | null
    voltageB?: FloatNullableFilter<"tamper_events"> | number | null
    currentR?: FloatNullableFilter<"tamper_events"> | number | null
    currentY?: FloatNullableFilter<"tamper_events"> | number | null
    currentB?: FloatNullableFilter<"tamper_events"> | number | null
    powerFactorR?: FloatNullableFilter<"tamper_events"> | number | null
    powerFactorY?: FloatNullableFilter<"tamper_events"> | number | null
    powerFactorB?: FloatNullableFilter<"tamper_events"> | number | null
    tamperCount?: IntNullableFilter<"tamper_events"> | number | null
    param1?: FloatNullableFilter<"tamper_events"> | number | null
    param2?: FloatNullableFilter<"tamper_events"> | number | null
    param3?: FloatNullableFilter<"tamper_events"> | number | null
    param4?: FloatNullableFilter<"tamper_events"> | number | null
    param5?: FloatNullableFilter<"tamper_events"> | number | null
    isProcessed?: BoolFilter<"tamper_events"> | boolean
    createdAt?: DateTimeFilter<"tamper_events"> | Date | string
    updatedAt?: DateTimeFilter<"tamper_events"> | Date | string
  }

  export type consumersCreateWithoutNotificationsInput = {
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutConsumersInput
    consumer_documents?: consumer_documentsCreateNestedManyWithoutConsumersInput
    locations: locationsCreateNestedOneWithoutConsumersInput
    prepaid_accounts?: prepaid_accountsCreateNestedOneWithoutConsumersInput
  }

  export type consumersUncheckedCreateWithoutNotificationsInput = {
    id?: number
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    locationId: number
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutConsumersInput
    consumer_documents?: consumer_documentsUncheckedCreateNestedManyWithoutConsumersInput
    prepaid_accounts?: prepaid_accountsUncheckedCreateNestedOneWithoutConsumersInput
  }

  export type consumersCreateOrConnectWithoutNotificationsInput = {
    where: consumersWhereUniqueInput
    create: XOR<consumersCreateWithoutNotificationsInput, consumersUncheckedCreateWithoutNotificationsInput>
  }

  export type consumersUpsertWithoutNotificationsInput = {
    update: XOR<consumersUpdateWithoutNotificationsInput, consumersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<consumersCreateWithoutNotificationsInput, consumersUncheckedCreateWithoutNotificationsInput>
    where?: consumersWhereInput
  }

  export type consumersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: consumersWhereInput
    data: XOR<consumersUpdateWithoutNotificationsInput, consumersUncheckedUpdateWithoutNotificationsInput>
  }

  export type consumersUpdateWithoutNotificationsInput = {
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutConsumersNestedInput
    consumer_documents?: consumer_documentsUpdateManyWithoutConsumersNestedInput
    locations?: locationsUpdateOneRequiredWithoutConsumersNestedInput
    prepaid_accounts?: prepaid_accountsUpdateOneWithoutConsumersNestedInput
  }

  export type consumersUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutConsumersNestedInput
    consumer_documents?: consumer_documentsUncheckedUpdateManyWithoutConsumersNestedInput
    prepaid_accounts?: prepaid_accountsUncheckedUpdateOneWithoutConsumersNestedInput
  }

  export type billsCreateWithoutPaymentsInput = {
    billNumber: string
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
    consumers: consumersCreateNestedOneWithoutBillsInput
    meters: metersCreateNestedOneWithoutBillsInput
    meter_readings?: meter_readingsCreateNestedManyWithoutBillsInput
  }

  export type billsUncheckedCreateWithoutPaymentsInput = {
    id?: number
    billNumber: string
    meterId: number
    consumerId: number
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutBillsInput
  }

  export type billsCreateOrConnectWithoutPaymentsInput = {
    where: billsWhereUniqueInput
    create: XOR<billsCreateWithoutPaymentsInput, billsUncheckedCreateWithoutPaymentsInput>
  }

  export type billsUpsertWithoutPaymentsInput = {
    update: XOR<billsUpdateWithoutPaymentsInput, billsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<billsCreateWithoutPaymentsInput, billsUncheckedCreateWithoutPaymentsInput>
    where?: billsWhereInput
  }

  export type billsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: billsWhereInput
    data: XOR<billsUpdateWithoutPaymentsInput, billsUncheckedUpdateWithoutPaymentsInput>
  }

  export type billsUpdateWithoutPaymentsInput = {
    billNumber?: StringFieldUpdateOperationsInput | string
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneRequiredWithoutBillsNestedInput
    meters?: metersUpdateOneRequiredWithoutBillsNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutBillsNestedInput
  }

  export type billsUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNumber?: StringFieldUpdateOperationsInput | string
    meterId?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutBillsNestedInput
  }

  export type user_permissionsCreateWithoutPermissionsInput = {
    isGranted?: boolean
    reason?: string | null
    validFrom?: Date | string
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutUser_permissionsInput
  }

  export type user_permissionsUncheckedCreateWithoutPermissionsInput = {
    id?: number
    userId: number
    isGranted?: boolean
    reason?: string | null
    validFrom?: Date | string
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_permissionsCreateOrConnectWithoutPermissionsInput = {
    where: user_permissionsWhereUniqueInput
    create: XOR<user_permissionsCreateWithoutPermissionsInput, user_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type user_permissionsCreateManyPermissionsInputEnvelope = {
    data: user_permissionsCreateManyPermissionsInput | user_permissionsCreateManyPermissionsInput[]
    skipDuplicates?: boolean
  }

  export type user_permissionsUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: user_permissionsWhereUniqueInput
    update: XOR<user_permissionsUpdateWithoutPermissionsInput, user_permissionsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<user_permissionsCreateWithoutPermissionsInput, user_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type user_permissionsUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: user_permissionsWhereUniqueInput
    data: XOR<user_permissionsUpdateWithoutPermissionsInput, user_permissionsUncheckedUpdateWithoutPermissionsInput>
  }

  export type user_permissionsUpdateManyWithWhereWithoutPermissionsInput = {
    where: user_permissionsScalarWhereInput
    data: XOR<user_permissionsUpdateManyMutationInput, user_permissionsUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type user_permissionsScalarWhereInput = {
    AND?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
    OR?: user_permissionsScalarWhereInput[]
    NOT?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
    id?: IntFilter<"user_permissions"> | number
    userId?: IntFilter<"user_permissions"> | number
    permissionId?: IntFilter<"user_permissions"> | number
    isGranted?: BoolFilter<"user_permissions"> | boolean
    reason?: StringNullableFilter<"user_permissions"> | string | null
    validFrom?: DateTimeFilter<"user_permissions"> | Date | string
    validUntil?: DateTimeNullableFilter<"user_permissions"> | Date | string | null
    createdAt?: DateTimeFilter<"user_permissions"> | Date | string
    updatedAt?: DateTimeFilter<"user_permissions"> | Date | string
  }

  export type metersCreateWithoutPotential_transformersInput = {
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsCreateNestedManyWithoutMetersInput
    dtrs?: dtrsCreateNestedOneWithoutMetersInput
    locations: locationsCreateNestedOneWithoutMetersInput
    tamper_events?: tamper_eventsCreateNestedManyWithoutMetersInput
  }

  export type metersUncheckedCreateWithoutPotential_transformersInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    locationId: number
    dtrId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersUncheckedCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsUncheckedCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutMetersInput
    tamper_events?: tamper_eventsUncheckedCreateNestedManyWithoutMetersInput
  }

  export type metersCreateOrConnectWithoutPotential_transformersInput = {
    where: metersWhereUniqueInput
    create: XOR<metersCreateWithoutPotential_transformersInput, metersUncheckedCreateWithoutPotential_transformersInput>
  }

  export type metersUpsertWithoutPotential_transformersInput = {
    update: XOR<metersUpdateWithoutPotential_transformersInput, metersUncheckedUpdateWithoutPotential_transformersInput>
    create: XOR<metersCreateWithoutPotential_transformersInput, metersUncheckedCreateWithoutPotential_transformersInput>
    where?: metersWhereInput
  }

  export type metersUpdateToOneWithWhereWithoutPotential_transformersInput = {
    where?: metersWhereInput
    data: XOR<metersUpdateWithoutPotential_transformersInput, metersUncheckedUpdateWithoutPotential_transformersInput>
  }

  export type metersUpdateWithoutPotential_transformersInput = {
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutMetersNestedInput
    dtrs?: dtrsUpdateOneWithoutMetersNestedInput
    locations?: locationsUpdateOneRequiredWithoutMetersNestedInput
    tamper_events?: tamper_eventsUpdateManyWithoutMetersNestedInput
  }

  export type metersUncheckedUpdateWithoutPotential_transformersInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUncheckedUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUncheckedUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUncheckedUpdateManyWithoutMetersNestedInput
  }

  export type rolesCreateWithoutRole_permissionsInput = {
    name: string
    description?: string | null
    level: number
    isSystem?: boolean
    isActive?: boolean
    accessLevel: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    users?: usersCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutRole_permissionsInput = {
    id?: number
    name: string
    description?: string | null
    level: number
    isSystem?: boolean
    isActive?: boolean
    accessLevel: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    users?: usersUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutRole_permissionsInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
  }

  export type rolesUpsertWithoutRole_permissionsInput = {
    update: XOR<rolesUpdateWithoutRole_permissionsInput, rolesUncheckedUpdateWithoutRole_permissionsInput>
    create: XOR<rolesCreateWithoutRole_permissionsInput, rolesUncheckedCreateWithoutRole_permissionsInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutRole_permissionsInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutRole_permissionsInput, rolesUncheckedUpdateWithoutRole_permissionsInput>
  }

  export type rolesUpdateWithoutRole_permissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutRole_permissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type role_permissionsCreateWithoutRolesInput = {
    permissionId: JsonNullValueInput | InputJsonValue
    isGranted?: boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type role_permissionsUncheckedCreateWithoutRolesInput = {
    id?: number
    permissionId: JsonNullValueInput | InputJsonValue
    isGranted?: boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type role_permissionsCreateOrConnectWithoutRolesInput = {
    where: role_permissionsWhereUniqueInput
    create: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput>
  }

  export type role_permissionsCreateManyRolesInputEnvelope = {
    data: role_permissionsCreateManyRolesInput | role_permissionsCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutRolesInput = {
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedOneWithoutUsersInput
    departments?: departmentsCreateNestedOneWithoutUsersInput
    locations?: locationsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutRolesInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyUncheckedCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsUncheckedCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsUncheckedCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutRolesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
  }

  export type usersCreateManyRolesInputEnvelope = {
    data: usersCreateManyRolesInput | usersCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type role_permissionsUpsertWithWhereUniqueWithoutRolesInput = {
    where: role_permissionsWhereUniqueInput
    update: XOR<role_permissionsUpdateWithoutRolesInput, role_permissionsUncheckedUpdateWithoutRolesInput>
    create: XOR<role_permissionsCreateWithoutRolesInput, role_permissionsUncheckedCreateWithoutRolesInput>
  }

  export type role_permissionsUpdateWithWhereUniqueWithoutRolesInput = {
    where: role_permissionsWhereUniqueInput
    data: XOR<role_permissionsUpdateWithoutRolesInput, role_permissionsUncheckedUpdateWithoutRolesInput>
  }

  export type role_permissionsUpdateManyWithWhereWithoutRolesInput = {
    where: role_permissionsScalarWhereInput
    data: XOR<role_permissionsUpdateManyMutationInput, role_permissionsUncheckedUpdateManyWithoutRolesInput>
  }

  export type role_permissionsScalarWhereInput = {
    AND?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
    OR?: role_permissionsScalarWhereInput[]
    NOT?: role_permissionsScalarWhereInput | role_permissionsScalarWhereInput[]
    id?: IntFilter<"role_permissions"> | number
    roleId?: IntFilter<"role_permissions"> | number
    permissionId?: JsonFilter<"role_permissions">
    isGranted?: BoolFilter<"role_permissions"> | boolean
    restrictions?: JsonNullableFilter<"role_permissions">
    createdAt?: DateTimeFilter<"role_permissions"> | Date | string
    updatedAt?: DateTimeFilter<"role_permissions"> | Date | string
  }

  export type usersUpsertWithWhereUniqueWithoutRolesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutRolesInput, usersUncheckedUpdateWithoutRolesInput>
    create: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutRolesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutRolesInput, usersUncheckedUpdateWithoutRolesInput>
  }

  export type usersUpdateManyWithWhereWithoutRolesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutRolesInput>
  }

  export type usersCreateWithoutTickets_tickets_assignedToIdTousersInput = {
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyCreateNestedManyWithoutUsersInput
    tickets_tickets_raisedByIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedOneWithoutUsersInput
    departments?: departmentsCreateNestedOneWithoutUsersInput
    roles?: rolesCreateNestedOneWithoutUsersInput
    locations?: locationsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTickets_tickets_assignedToIdTousersInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    roleId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyUncheckedCreateNestedManyWithoutUsersInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsUncheckedCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsUncheckedCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTickets_tickets_assignedToIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTickets_tickets_assignedToIdTousersInput, usersUncheckedCreateWithoutTickets_tickets_assignedToIdTousersInput>
  }

  export type dtrsCreateWithoutTicketsInput = {
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsCreateNestedManyWithoutDtrsInput
    dtr_maintenance?: dtr_maintenanceCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsCreateNestedManyWithoutDtrsInput
    locations: locationsCreateNestedOneWithoutDtrsInput
    meters?: metersCreateNestedManyWithoutDtrsInput
  }

  export type dtrsUncheckedCreateWithoutTicketsInput = {
    id?: number
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    locationId: number
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtr_faults?: dtr_faultsUncheckedCreateNestedManyWithoutDtrsInput
    dtr_maintenance?: dtr_maintenanceUncheckedCreateNestedManyWithoutDtrsInput
    dtr_readings?: dtr_readingsUncheckedCreateNestedManyWithoutDtrsInput
    meters?: metersUncheckedCreateNestedManyWithoutDtrsInput
  }

  export type dtrsCreateOrConnectWithoutTicketsInput = {
    where: dtrsWhereUniqueInput
    create: XOR<dtrsCreateWithoutTicketsInput, dtrsUncheckedCreateWithoutTicketsInput>
  }

  export type usersCreateWithoutTickets_tickets_raisedByIdTousersInput = {
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    user_activity_logs?: user_activity_logsCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedOneWithoutUsersInput
    departments?: departmentsCreateNestedOneWithoutUsersInput
    roles?: rolesCreateNestedOneWithoutUsersInput
    locations?: locationsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTickets_tickets_raisedByIdTousersInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    roleId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyUncheckedCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    user_activity_logs?: user_activity_logsUncheckedCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsUncheckedCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTickets_tickets_raisedByIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTickets_tickets_raisedByIdTousersInput, usersUncheckedCreateWithoutTickets_tickets_raisedByIdTousersInput>
  }

  export type usersUpsertWithoutTickets_tickets_assignedToIdTousersInput = {
    update: XOR<usersUpdateWithoutTickets_tickets_assignedToIdTousersInput, usersUncheckedUpdateWithoutTickets_tickets_assignedToIdTousersInput>
    create: XOR<usersCreateWithoutTickets_tickets_assignedToIdTousersInput, usersUncheckedCreateWithoutTickets_tickets_assignedToIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTickets_tickets_assignedToIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTickets_tickets_assignedToIdTousersInput, usersUncheckedUpdateWithoutTickets_tickets_assignedToIdTousersInput>
  }

  export type usersUpdateWithoutTickets_tickets_assignedToIdTousersInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUpdateManyWithoutUsersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateOneWithoutUsersNestedInput
    departments?: departmentsUpdateOneWithoutUsersNestedInput
    roles?: rolesUpdateOneWithoutUsersNestedInput
    locations?: locationsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTickets_tickets_assignedToIdTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUncheckedUpdateManyWithoutUsersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type dtrsUpsertWithoutTicketsInput = {
    update: XOR<dtrsUpdateWithoutTicketsInput, dtrsUncheckedUpdateWithoutTicketsInput>
    create: XOR<dtrsCreateWithoutTicketsInput, dtrsUncheckedCreateWithoutTicketsInput>
    where?: dtrsWhereInput
  }

  export type dtrsUpdateToOneWithWhereWithoutTicketsInput = {
    where?: dtrsWhereInput
    data: XOR<dtrsUpdateWithoutTicketsInput, dtrsUncheckedUpdateWithoutTicketsInput>
  }

  export type dtrsUpdateWithoutTicketsInput = {
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUpdateManyWithoutDtrsNestedInput
    dtr_maintenance?: dtr_maintenanceUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUpdateManyWithoutDtrsNestedInput
    locations?: locationsUpdateOneRequiredWithoutDtrsNestedInput
    meters?: metersUpdateManyWithoutDtrsNestedInput
  }

  export type dtrsUncheckedUpdateWithoutTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    locationId?: IntFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUncheckedUpdateManyWithoutDtrsNestedInput
    dtr_maintenance?: dtr_maintenanceUncheckedUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUncheckedUpdateManyWithoutDtrsNestedInput
    meters?: metersUncheckedUpdateManyWithoutDtrsNestedInput
  }

  export type usersUpsertWithoutTickets_tickets_raisedByIdTousersInput = {
    update: XOR<usersUpdateWithoutTickets_tickets_raisedByIdTousersInput, usersUncheckedUpdateWithoutTickets_tickets_raisedByIdTousersInput>
    create: XOR<usersCreateWithoutTickets_tickets_raisedByIdTousersInput, usersUncheckedCreateWithoutTickets_tickets_raisedByIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTickets_tickets_raisedByIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTickets_tickets_raisedByIdTousersInput, usersUncheckedUpdateWithoutTickets_tickets_raisedByIdTousersInput>
  }

  export type usersUpdateWithoutTickets_tickets_raisedByIdTousersInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    user_activity_logs?: user_activity_logsUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateOneWithoutUsersNestedInput
    departments?: departmentsUpdateOneWithoutUsersNestedInput
    roles?: rolesUpdateOneWithoutUsersNestedInput
    locations?: locationsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTickets_tickets_raisedByIdTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUncheckedUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    user_activity_logs?: user_activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutUser_activity_logsInput = {
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedOneWithoutUsersInput
    departments?: departmentsCreateNestedOneWithoutUsersInput
    roles?: rolesCreateNestedOneWithoutUsersInput
    locations?: locationsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_activity_logsInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    roleId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyUncheckedCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsUncheckedCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_activity_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_activity_logsInput, usersUncheckedCreateWithoutUser_activity_logsInput>
  }

  export type usersUpsertWithoutUser_activity_logsInput = {
    update: XOR<usersUpdateWithoutUser_activity_logsInput, usersUncheckedUpdateWithoutUser_activity_logsInput>
    create: XOR<usersCreateWithoutUser_activity_logsInput, usersUncheckedCreateWithoutUser_activity_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_activity_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_activity_logsInput, usersUncheckedUpdateWithoutUser_activity_logsInput>
  }

  export type usersUpdateWithoutUser_activity_logsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateOneWithoutUsersNestedInput
    departments?: departmentsUpdateOneWithoutUsersNestedInput
    roles?: rolesUpdateOneWithoutUsersNestedInput
    locations?: locationsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_activity_logsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUncheckedUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type permissionsCreateWithoutUser_permissionsInput = {
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type permissionsUncheckedCreateWithoutUser_permissionsInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type permissionsCreateOrConnectWithoutUser_permissionsInput = {
    where: permissionsWhereUniqueInput
    create: XOR<permissionsCreateWithoutUser_permissionsInput, permissionsUncheckedCreateWithoutUser_permissionsInput>
  }

  export type usersCreateWithoutUser_permissionsInput = {
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedOneWithoutUsersInput
    departments?: departmentsCreateNestedOneWithoutUsersInput
    roles?: rolesCreateNestedOneWithoutUsersInput
    locations?: locationsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_permissionsInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    roleId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyUncheckedCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsUncheckedCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsUncheckedCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_permissionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_permissionsInput, usersUncheckedCreateWithoutUser_permissionsInput>
  }

  export type permissionsUpsertWithoutUser_permissionsInput = {
    update: XOR<permissionsUpdateWithoutUser_permissionsInput, permissionsUncheckedUpdateWithoutUser_permissionsInput>
    create: XOR<permissionsCreateWithoutUser_permissionsInput, permissionsUncheckedCreateWithoutUser_permissionsInput>
    where?: permissionsWhereInput
  }

  export type permissionsUpdateToOneWithWhereWithoutUser_permissionsInput = {
    where?: permissionsWhereInput
    data: XOR<permissionsUpdateWithoutUser_permissionsInput, permissionsUncheckedUpdateWithoutUser_permissionsInput>
  }

  export type permissionsUpdateWithoutUser_permissionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionsUncheckedUpdateWithoutUser_permissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutUser_permissionsInput = {
    update: XOR<usersUpdateWithoutUser_permissionsInput, usersUncheckedUpdateWithoutUser_permissionsInput>
    create: XOR<usersCreateWithoutUser_permissionsInput, usersUncheckedCreateWithoutUser_permissionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_permissionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_permissionsInput, usersUncheckedUpdateWithoutUser_permissionsInput>
  }

  export type usersUpdateWithoutUser_permissionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateOneWithoutUsersNestedInput
    departments?: departmentsUpdateOneWithoutUsersNestedInput
    roles?: rolesUpdateOneWithoutUsersNestedInput
    locations?: locationsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_permissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUncheckedUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutUser_sessionsInput = {
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensCreateNestedOneWithoutUsersInput
    departments?: departmentsCreateNestedOneWithoutUsersInput
    roles?: rolesCreateNestedOneWithoutUsersInput
    locations?: locationsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_sessionsInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    roleId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyUncheckedCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsUncheckedCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUsersInput
    refresh_tokens?: refresh_tokensUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_sessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_sessionsInput, usersUncheckedCreateWithoutUser_sessionsInput>
  }

  export type usersUpsertWithoutUser_sessionsInput = {
    update: XOR<usersUpdateWithoutUser_sessionsInput, usersUncheckedUpdateWithoutUser_sessionsInput>
    create: XOR<usersCreateWithoutUser_sessionsInput, usersUncheckedCreateWithoutUser_sessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_sessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_sessionsInput, usersUncheckedUpdateWithoutUser_sessionsInput>
  }

  export type usersUpdateWithoutUser_sessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateOneWithoutUsersNestedInput
    departments?: departmentsUpdateOneWithoutUsersNestedInput
    roles?: rolesUpdateOneWithoutUsersNestedInput
    locations?: locationsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_sessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUncheckedUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutRefresh_tokensInput = {
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsCreateNestedManyWithoutUsersInput
    departments?: departmentsCreateNestedOneWithoutUsersInput
    roles?: rolesCreateNestedOneWithoutUsersInput
    locations?: locationsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutRefresh_tokensInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    roleId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
    login_history?: login_historyUncheckedCreateNestedManyWithoutUsersInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_assignedToIdTousersInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedCreateNestedManyWithoutUsers_tickets_raisedByIdTousersInput
    user_activity_logs?: user_activity_logsUncheckedCreateNestedManyWithoutUsersInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUsersInput
    user_sessions?: user_sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutRefresh_tokensInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRefresh_tokensInput, usersUncheckedCreateWithoutRefresh_tokensInput>
  }

  export type usersUpsertWithoutRefresh_tokensInput = {
    update: XOR<usersUpdateWithoutRefresh_tokensInput, usersUncheckedUpdateWithoutRefresh_tokensInput>
    create: XOR<usersCreateWithoutRefresh_tokensInput, usersUncheckedCreateWithoutRefresh_tokensInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRefresh_tokensInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRefresh_tokensInput, usersUncheckedUpdateWithoutRefresh_tokensInput>
  }

  export type usersUpdateWithoutRefresh_tokensInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUpdateManyWithoutUsersNestedInput
    departments?: departmentsUpdateOneWithoutUsersNestedInput
    roles?: rolesUpdateOneWithoutUsersNestedInput
    locations?: locationsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutRefresh_tokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUncheckedUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type login_historyCreateWithoutUsersInput = {
    status: string
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type login_historyUncheckedCreateWithoutUsersInput = {
    id?: number
    status: string
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type login_historyCreateOrConnectWithoutUsersInput = {
    where: login_historyWhereUniqueInput
    create: XOR<login_historyCreateWithoutUsersInput, login_historyUncheckedCreateWithoutUsersInput>
  }

  export type login_historyCreateManyUsersInputEnvelope = {
    data: login_historyCreateManyUsersInput | login_historyCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ticketsCreateWithoutUsers_tickets_assignedToIdTousersInput = {
    ticketNumber: string
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dtrs?: dtrsCreateNestedOneWithoutTicketsInput
    users_tickets_raisedByIdTousers: usersCreateNestedOneWithoutTickets_tickets_raisedByIdTousersInput
  }

  export type ticketsUncheckedCreateWithoutUsers_tickets_assignedToIdTousersInput = {
    id?: number
    ticketNumber: string
    dtrId?: number | null
    raisedById: number
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ticketsCreateOrConnectWithoutUsers_tickets_assignedToIdTousersInput = {
    where: ticketsWhereUniqueInput
    create: XOR<ticketsCreateWithoutUsers_tickets_assignedToIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_assignedToIdTousersInput>
  }

  export type ticketsCreateManyUsers_tickets_assignedToIdTousersInputEnvelope = {
    data: ticketsCreateManyUsers_tickets_assignedToIdTousersInput | ticketsCreateManyUsers_tickets_assignedToIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type ticketsCreateWithoutUsers_tickets_raisedByIdTousersInput = {
    ticketNumber: string
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_tickets_assignedToIdTousers?: usersCreateNestedOneWithoutTickets_tickets_assignedToIdTousersInput
    dtrs?: dtrsCreateNestedOneWithoutTicketsInput
  }

  export type ticketsUncheckedCreateWithoutUsers_tickets_raisedByIdTousersInput = {
    id?: number
    ticketNumber: string
    dtrId?: number | null
    assignedToId?: number | null
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ticketsCreateOrConnectWithoutUsers_tickets_raisedByIdTousersInput = {
    where: ticketsWhereUniqueInput
    create: XOR<ticketsCreateWithoutUsers_tickets_raisedByIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_raisedByIdTousersInput>
  }

  export type ticketsCreateManyUsers_tickets_raisedByIdTousersInputEnvelope = {
    data: ticketsCreateManyUsers_tickets_raisedByIdTousersInput | ticketsCreateManyUsers_tickets_raisedByIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type user_activity_logsCreateWithoutUsersInput = {
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type user_activity_logsUncheckedCreateWithoutUsersInput = {
    id?: number
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type user_activity_logsCreateOrConnectWithoutUsersInput = {
    where: user_activity_logsWhereUniqueInput
    create: XOR<user_activity_logsCreateWithoutUsersInput, user_activity_logsUncheckedCreateWithoutUsersInput>
  }

  export type user_activity_logsCreateManyUsersInputEnvelope = {
    data: user_activity_logsCreateManyUsersInput | user_activity_logsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_permissionsCreateWithoutUsersInput = {
    isGranted?: boolean
    reason?: string | null
    validFrom?: Date | string
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    permissions: permissionsCreateNestedOneWithoutUser_permissionsInput
  }

  export type user_permissionsUncheckedCreateWithoutUsersInput = {
    id?: number
    permissionId: number
    isGranted?: boolean
    reason?: string | null
    validFrom?: Date | string
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_permissionsCreateOrConnectWithoutUsersInput = {
    where: user_permissionsWhereUniqueInput
    create: XOR<user_permissionsCreateWithoutUsersInput, user_permissionsUncheckedCreateWithoutUsersInput>
  }

  export type user_permissionsCreateManyUsersInputEnvelope = {
    data: user_permissionsCreateManyUsersInput | user_permissionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_sessionsCreateWithoutUsersInput = {
    sessionToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    location?: string | null
    isActive?: boolean
    lastActivityAt?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_sessionsUncheckedCreateWithoutUsersInput = {
    id?: number
    sessionToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    location?: string | null
    isActive?: boolean
    lastActivityAt?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_sessionsCreateOrConnectWithoutUsersInput = {
    where: user_sessionsWhereUniqueInput
    create: XOR<user_sessionsCreateWithoutUsersInput, user_sessionsUncheckedCreateWithoutUsersInput>
  }

  export type user_sessionsCreateManyUsersInputEnvelope = {
    data: user_sessionsCreateManyUsersInput | user_sessionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type refresh_tokensCreateWithoutUsersInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type refresh_tokensUncheckedCreateWithoutUsersInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type refresh_tokensCreateOrConnectWithoutUsersInput = {
    where: refresh_tokensWhereUniqueInput
    create: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput>
  }

  export type departmentsCreateWithoutUsersInput = {
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    parent?: departmentsCreateNestedOneWithoutChildrenInput
    children?: departmentsCreateNestedManyWithoutParentInput
  }

  export type departmentsUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    parentId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    children?: departmentsUncheckedCreateNestedManyWithoutParentInput
  }

  export type departmentsCreateOrConnectWithoutUsersInput = {
    where: departmentsWhereUniqueInput
    create: XOR<departmentsCreateWithoutUsersInput, departmentsUncheckedCreateWithoutUsersInput>
  }

  export type rolesCreateWithoutUsersInput = {
    name: string
    description?: string | null
    level: number
    isSystem?: boolean
    isActive?: boolean
    accessLevel: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    role_permissions?: role_permissionsCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    level: number
    isSystem?: boolean
    isActive?: boolean
    accessLevel: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    role_permissions?: role_permissionsUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutUsersInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
  }

  export type locationsCreateWithoutUsersInput = {
    name: string
    code: string
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsCreateNestedManyWithoutLocationsInput
    location_types: location_typesCreateNestedOneWithoutLocationsInput
    locations?: locationsCreateNestedOneWithoutOther_locationsInput
    other_locations?: locationsCreateNestedManyWithoutLocationsInput
    meters?: metersCreateNestedManyWithoutLocationsInput
  }

  export type locationsUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    code: string
    locationTypeId: number
    parentId?: number | null
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers?: consumersUncheckedCreateNestedOneWithoutLocationsInput
    dtrs?: dtrsUncheckedCreateNestedManyWithoutLocationsInput
    other_locations?: locationsUncheckedCreateNestedManyWithoutLocationsInput
    meters?: metersUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type locationsCreateOrConnectWithoutUsersInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutUsersInput, locationsUncheckedCreateWithoutUsersInput>
  }

  export type login_historyUpsertWithWhereUniqueWithoutUsersInput = {
    where: login_historyWhereUniqueInput
    update: XOR<login_historyUpdateWithoutUsersInput, login_historyUncheckedUpdateWithoutUsersInput>
    create: XOR<login_historyCreateWithoutUsersInput, login_historyUncheckedCreateWithoutUsersInput>
  }

  export type login_historyUpdateWithWhereUniqueWithoutUsersInput = {
    where: login_historyWhereUniqueInput
    data: XOR<login_historyUpdateWithoutUsersInput, login_historyUncheckedUpdateWithoutUsersInput>
  }

  export type login_historyUpdateManyWithWhereWithoutUsersInput = {
    where: login_historyScalarWhereInput
    data: XOR<login_historyUpdateManyMutationInput, login_historyUncheckedUpdateManyWithoutUsersInput>
  }

  export type login_historyScalarWhereInput = {
    AND?: login_historyScalarWhereInput | login_historyScalarWhereInput[]
    OR?: login_historyScalarWhereInput[]
    NOT?: login_historyScalarWhereInput | login_historyScalarWhereInput[]
    id?: IntFilter<"login_history"> | number
    userId?: IntFilter<"login_history"> | number
    status?: StringFilter<"login_history"> | string
    ipAddress?: StringNullableFilter<"login_history"> | string | null
    deviceInfo?: JsonNullableFilter<"login_history">
    location?: StringNullableFilter<"login_history"> | string | null
    failureReason?: StringNullableFilter<"login_history"> | string | null
    createdAt?: DateTimeFilter<"login_history"> | Date | string
  }

  export type ticketsUpsertWithWhereUniqueWithoutUsers_tickets_assignedToIdTousersInput = {
    where: ticketsWhereUniqueInput
    update: XOR<ticketsUpdateWithoutUsers_tickets_assignedToIdTousersInput, ticketsUncheckedUpdateWithoutUsers_tickets_assignedToIdTousersInput>
    create: XOR<ticketsCreateWithoutUsers_tickets_assignedToIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_assignedToIdTousersInput>
  }

  export type ticketsUpdateWithWhereUniqueWithoutUsers_tickets_assignedToIdTousersInput = {
    where: ticketsWhereUniqueInput
    data: XOR<ticketsUpdateWithoutUsers_tickets_assignedToIdTousersInput, ticketsUncheckedUpdateWithoutUsers_tickets_assignedToIdTousersInput>
  }

  export type ticketsUpdateManyWithWhereWithoutUsers_tickets_assignedToIdTousersInput = {
    where: ticketsScalarWhereInput
    data: XOR<ticketsUpdateManyMutationInput, ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersInput>
  }

  export type ticketsUpsertWithWhereUniqueWithoutUsers_tickets_raisedByIdTousersInput = {
    where: ticketsWhereUniqueInput
    update: XOR<ticketsUpdateWithoutUsers_tickets_raisedByIdTousersInput, ticketsUncheckedUpdateWithoutUsers_tickets_raisedByIdTousersInput>
    create: XOR<ticketsCreateWithoutUsers_tickets_raisedByIdTousersInput, ticketsUncheckedCreateWithoutUsers_tickets_raisedByIdTousersInput>
  }

  export type ticketsUpdateWithWhereUniqueWithoutUsers_tickets_raisedByIdTousersInput = {
    where: ticketsWhereUniqueInput
    data: XOR<ticketsUpdateWithoutUsers_tickets_raisedByIdTousersInput, ticketsUncheckedUpdateWithoutUsers_tickets_raisedByIdTousersInput>
  }

  export type ticketsUpdateManyWithWhereWithoutUsers_tickets_raisedByIdTousersInput = {
    where: ticketsScalarWhereInput
    data: XOR<ticketsUpdateManyMutationInput, ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersInput>
  }

  export type user_activity_logsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_activity_logsWhereUniqueInput
    update: XOR<user_activity_logsUpdateWithoutUsersInput, user_activity_logsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_activity_logsCreateWithoutUsersInput, user_activity_logsUncheckedCreateWithoutUsersInput>
  }

  export type user_activity_logsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_activity_logsWhereUniqueInput
    data: XOR<user_activity_logsUpdateWithoutUsersInput, user_activity_logsUncheckedUpdateWithoutUsersInput>
  }

  export type user_activity_logsUpdateManyWithWhereWithoutUsersInput = {
    where: user_activity_logsScalarWhereInput
    data: XOR<user_activity_logsUpdateManyMutationInput, user_activity_logsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_activity_logsScalarWhereInput = {
    AND?: user_activity_logsScalarWhereInput | user_activity_logsScalarWhereInput[]
    OR?: user_activity_logsScalarWhereInput[]
    NOT?: user_activity_logsScalarWhereInput | user_activity_logsScalarWhereInput[]
    id?: IntFilter<"user_activity_logs"> | number
    userId?: IntFilter<"user_activity_logs"> | number
    action?: StringFilter<"user_activity_logs"> | string
    details?: JsonNullableFilter<"user_activity_logs">
    ipAddress?: StringNullableFilter<"user_activity_logs"> | string | null
    createdAt?: DateTimeFilter<"user_activity_logs"> | Date | string
  }

  export type user_permissionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_permissionsWhereUniqueInput
    update: XOR<user_permissionsUpdateWithoutUsersInput, user_permissionsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_permissionsCreateWithoutUsersInput, user_permissionsUncheckedCreateWithoutUsersInput>
  }

  export type user_permissionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_permissionsWhereUniqueInput
    data: XOR<user_permissionsUpdateWithoutUsersInput, user_permissionsUncheckedUpdateWithoutUsersInput>
  }

  export type user_permissionsUpdateManyWithWhereWithoutUsersInput = {
    where: user_permissionsScalarWhereInput
    data: XOR<user_permissionsUpdateManyMutationInput, user_permissionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_sessionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_sessionsWhereUniqueInput
    update: XOR<user_sessionsUpdateWithoutUsersInput, user_sessionsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_sessionsCreateWithoutUsersInput, user_sessionsUncheckedCreateWithoutUsersInput>
  }

  export type user_sessionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_sessionsWhereUniqueInput
    data: XOR<user_sessionsUpdateWithoutUsersInput, user_sessionsUncheckedUpdateWithoutUsersInput>
  }

  export type user_sessionsUpdateManyWithWhereWithoutUsersInput = {
    where: user_sessionsScalarWhereInput
    data: XOR<user_sessionsUpdateManyMutationInput, user_sessionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_sessionsScalarWhereInput = {
    AND?: user_sessionsScalarWhereInput | user_sessionsScalarWhereInput[]
    OR?: user_sessionsScalarWhereInput[]
    NOT?: user_sessionsScalarWhereInput | user_sessionsScalarWhereInput[]
    id?: IntFilter<"user_sessions"> | number
    userId?: IntFilter<"user_sessions"> | number
    sessionToken?: StringFilter<"user_sessions"> | string
    deviceInfo?: JsonNullableFilter<"user_sessions">
    ipAddress?: StringNullableFilter<"user_sessions"> | string | null
    location?: StringNullableFilter<"user_sessions"> | string | null
    isActive?: BoolFilter<"user_sessions"> | boolean
    lastActivityAt?: DateTimeFilter<"user_sessions"> | Date | string
    expiresAt?: DateTimeFilter<"user_sessions"> | Date | string
    createdAt?: DateTimeFilter<"user_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"user_sessions"> | Date | string
  }

  export type refresh_tokensUpsertWithoutUsersInput = {
    update: XOR<refresh_tokensUpdateWithoutUsersInput, refresh_tokensUncheckedUpdateWithoutUsersInput>
    create: XOR<refresh_tokensCreateWithoutUsersInput, refresh_tokensUncheckedCreateWithoutUsersInput>
    where?: refresh_tokensWhereInput
  }

  export type refresh_tokensUpdateToOneWithWhereWithoutUsersInput = {
    where?: refresh_tokensWhereInput
    data: XOR<refresh_tokensUpdateWithoutUsersInput, refresh_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type refresh_tokensUpdateWithoutUsersInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refresh_tokensUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentsUpsertWithoutUsersInput = {
    update: XOR<departmentsUpdateWithoutUsersInput, departmentsUncheckedUpdateWithoutUsersInput>
    create: XOR<departmentsCreateWithoutUsersInput, departmentsUncheckedCreateWithoutUsersInput>
    where?: departmentsWhereInput
  }

  export type departmentsUpdateToOneWithWhereWithoutUsersInput = {
    where?: departmentsWhereInput
    data: XOR<departmentsUpdateWithoutUsersInput, departmentsUncheckedUpdateWithoutUsersInput>
  }

  export type departmentsUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: departmentsUpdateOneWithoutChildrenNestedInput
    children?: departmentsUpdateManyWithoutParentNestedInput
  }

  export type departmentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: departmentsUncheckedUpdateManyWithoutParentNestedInput
  }

  export type rolesUpsertWithoutUsersInput = {
    update: XOR<rolesUpdateWithoutUsersInput, rolesUncheckedUpdateWithoutUsersInput>
    create: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutUsersInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutUsersInput, rolesUncheckedUpdateWithoutUsersInput>
  }

  export type rolesUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role_permissions?: role_permissionsUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role_permissions?: role_permissionsUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type locationsUpsertWithoutUsersInput = {
    update: XOR<locationsUpdateWithoutUsersInput, locationsUncheckedUpdateWithoutUsersInput>
    create: XOR<locationsCreateWithoutUsersInput, locationsUncheckedCreateWithoutUsersInput>
    where?: locationsWhereInput
  }

  export type locationsUpdateToOneWithWhereWithoutUsersInput = {
    where?: locationsWhereInput
    data: XOR<locationsUpdateWithoutUsersInput, locationsUncheckedUpdateWithoutUsersInput>
  }

  export type locationsUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUpdateManyWithoutLocationsNestedInput
    location_types?: location_typesUpdateOneRequiredWithoutLocationsNestedInput
    locations?: locationsUpdateOneWithoutOther_locationsNestedInput
    other_locations?: locationsUpdateManyWithoutLocationsNestedInput
    meters?: metersUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationTypeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUncheckedUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUncheckedUpdateManyWithoutLocationsNestedInput
    other_locations?: locationsUncheckedUpdateManyWithoutLocationsNestedInput
    meters?: metersUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type consumersCreateWithoutPrepaid_accountsInput = {
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutConsumersInput
    consumer_documents?: consumer_documentsCreateNestedManyWithoutConsumersInput
    locations: locationsCreateNestedOneWithoutConsumersInput
    notifications?: notificationsCreateNestedManyWithoutConsumersInput
  }

  export type consumersUncheckedCreateWithoutPrepaid_accountsInput = {
    id?: number
    consumerNumber: string
    name: string
    email?: string | null
    primaryPhone: string
    alternatePhone?: string | null
    idType: $Enums.IdType
    idNumber: string
    connectionType: $Enums.ConnectionType
    category: $Enums.ConsumerCategory
    sanctionedLoad: number
    connectionDate: Date | string
    locationId: number
    billingCycle: $Enums.BillingCycle
    billDeliveryMode?: consumersCreatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: $Enums.PaymentMethod | null
    creditScore?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutConsumersInput
    consumer_documents?: consumer_documentsUncheckedCreateNestedManyWithoutConsumersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutConsumersInput
  }

  export type consumersCreateOrConnectWithoutPrepaid_accountsInput = {
    where: consumersWhereUniqueInput
    create: XOR<consumersCreateWithoutPrepaid_accountsInput, consumersUncheckedCreateWithoutPrepaid_accountsInput>
  }

  export type prepaid_alertsCreateWithoutPrepaid_accountsInput = {
    alertType: $Enums.PrepaidAlertType
    alertLevel: $Enums.PrepaidAlertLevel
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    balanceAtAlert?: number | null
    consumptionAtAlert?: number | null
    thresholdValue?: number | null
    createdAt?: Date | string
  }

  export type prepaid_alertsUncheckedCreateWithoutPrepaid_accountsInput = {
    id?: number
    alertType: $Enums.PrepaidAlertType
    alertLevel: $Enums.PrepaidAlertLevel
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    balanceAtAlert?: number | null
    consumptionAtAlert?: number | null
    thresholdValue?: number | null
    createdAt?: Date | string
  }

  export type prepaid_alertsCreateOrConnectWithoutPrepaid_accountsInput = {
    where: prepaid_alertsWhereUniqueInput
    create: XOR<prepaid_alertsCreateWithoutPrepaid_accountsInput, prepaid_alertsUncheckedCreateWithoutPrepaid_accountsInput>
  }

  export type prepaid_alertsCreateManyPrepaid_accountsInputEnvelope = {
    data: prepaid_alertsCreateManyPrepaid_accountsInput | prepaid_alertsCreateManyPrepaid_accountsInput[]
    skipDuplicates?: boolean
  }

  export type prepaid_rechargesCreateWithoutPrepaid_accountsInput = {
    rechargeId: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayName?: string | null
    gatewayTransactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: $Enums.PrepaidRechargeType
    rechargeSource?: $Enums.PrepaidRechargeSource
    isPromotional?: boolean
    promotionalCode?: string | null
    discountAmount?: number
    bonusAmount?: number
    receiptNumber?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_rechargesUncheckedCreateWithoutPrepaid_accountsInput = {
    id?: number
    rechargeId: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayName?: string | null
    gatewayTransactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: $Enums.PrepaidRechargeType
    rechargeSource?: $Enums.PrepaidRechargeSource
    isPromotional?: boolean
    promotionalCode?: string | null
    discountAmount?: number
    bonusAmount?: number
    receiptNumber?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_rechargesCreateOrConnectWithoutPrepaid_accountsInput = {
    where: prepaid_rechargesWhereUniqueInput
    create: XOR<prepaid_rechargesCreateWithoutPrepaid_accountsInput, prepaid_rechargesUncheckedCreateWithoutPrepaid_accountsInput>
  }

  export type prepaid_rechargesCreateManyPrepaid_accountsInputEnvelope = {
    data: prepaid_rechargesCreateManyPrepaid_accountsInput | prepaid_rechargesCreateManyPrepaid_accountsInput[]
    skipDuplicates?: boolean
  }

  export type prepaid_transactionsCreateWithoutPrepaid_accountsInput = {
    transactionId: string
    transactionType: $Enums.PrepaidTransactionType
    amount: number
    balanceBefore: number
    balanceAfter: number
    consumptionKWh?: number | null
    ratePerUnit?: number | null
    fixedCharges?: number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.PrepaidTransactionStatus
    failureReason?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    meter_readings?: meter_readingsCreateNestedOneWithoutPrepaid_transactionsInput
  }

  export type prepaid_transactionsUncheckedCreateWithoutPrepaid_accountsInput = {
    id?: number
    transactionId: string
    transactionType: $Enums.PrepaidTransactionType
    amount: number
    balanceBefore: number
    balanceAfter: number
    consumptionKWh?: number | null
    ratePerUnit?: number | null
    fixedCharges?: number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    readingId?: number | null
    status?: $Enums.PrepaidTransactionStatus
    failureReason?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_transactionsCreateOrConnectWithoutPrepaid_accountsInput = {
    where: prepaid_transactionsWhereUniqueInput
    create: XOR<prepaid_transactionsCreateWithoutPrepaid_accountsInput, prepaid_transactionsUncheckedCreateWithoutPrepaid_accountsInput>
  }

  export type prepaid_transactionsCreateManyPrepaid_accountsInputEnvelope = {
    data: prepaid_transactionsCreateManyPrepaid_accountsInput | prepaid_transactionsCreateManyPrepaid_accountsInput[]
    skipDuplicates?: boolean
  }

  export type consumersUpsertWithoutPrepaid_accountsInput = {
    update: XOR<consumersUpdateWithoutPrepaid_accountsInput, consumersUncheckedUpdateWithoutPrepaid_accountsInput>
    create: XOR<consumersCreateWithoutPrepaid_accountsInput, consumersUncheckedCreateWithoutPrepaid_accountsInput>
    where?: consumersWhereInput
  }

  export type consumersUpdateToOneWithWhereWithoutPrepaid_accountsInput = {
    where?: consumersWhereInput
    data: XOR<consumersUpdateWithoutPrepaid_accountsInput, consumersUncheckedUpdateWithoutPrepaid_accountsInput>
  }

  export type consumersUpdateWithoutPrepaid_accountsInput = {
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutConsumersNestedInput
    consumer_documents?: consumer_documentsUpdateManyWithoutConsumersNestedInput
    locations?: locationsUpdateOneRequiredWithoutConsumersNestedInput
    notifications?: notificationsUpdateManyWithoutConsumersNestedInput
  }

  export type consumersUncheckedUpdateWithoutPrepaid_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primaryPhone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: EnumIdTypeFieldUpdateOperationsInput | $Enums.IdType
    idNumber?: StringFieldUpdateOperationsInput | string
    connectionType?: EnumConnectionTypeFieldUpdateOperationsInput | $Enums.ConnectionType
    category?: EnumConsumerCategoryFieldUpdateOperationsInput | $Enums.ConsumerCategory
    sanctionedLoad?: FloatFieldUpdateOperationsInput | number
    connectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    billDeliveryMode?: consumersUpdatebillDeliveryModeInput | $Enums.BillDeliveryMode[]
    defaultPaymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    creditScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutConsumersNestedInput
    consumer_documents?: consumer_documentsUncheckedUpdateManyWithoutConsumersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutConsumersNestedInput
  }

  export type prepaid_alertsUpsertWithWhereUniqueWithoutPrepaid_accountsInput = {
    where: prepaid_alertsWhereUniqueInput
    update: XOR<prepaid_alertsUpdateWithoutPrepaid_accountsInput, prepaid_alertsUncheckedUpdateWithoutPrepaid_accountsInput>
    create: XOR<prepaid_alertsCreateWithoutPrepaid_accountsInput, prepaid_alertsUncheckedCreateWithoutPrepaid_accountsInput>
  }

  export type prepaid_alertsUpdateWithWhereUniqueWithoutPrepaid_accountsInput = {
    where: prepaid_alertsWhereUniqueInput
    data: XOR<prepaid_alertsUpdateWithoutPrepaid_accountsInput, prepaid_alertsUncheckedUpdateWithoutPrepaid_accountsInput>
  }

  export type prepaid_alertsUpdateManyWithWhereWithoutPrepaid_accountsInput = {
    where: prepaid_alertsScalarWhereInput
    data: XOR<prepaid_alertsUpdateManyMutationInput, prepaid_alertsUncheckedUpdateManyWithoutPrepaid_accountsInput>
  }

  export type prepaid_alertsScalarWhereInput = {
    AND?: prepaid_alertsScalarWhereInput | prepaid_alertsScalarWhereInput[]
    OR?: prepaid_alertsScalarWhereInput[]
    NOT?: prepaid_alertsScalarWhereInput | prepaid_alertsScalarWhereInput[]
    id?: IntFilter<"prepaid_alerts"> | number
    accountId?: IntFilter<"prepaid_alerts"> | number
    alertType?: EnumPrepaidAlertTypeFilter<"prepaid_alerts"> | $Enums.PrepaidAlertType
    alertLevel?: EnumPrepaidAlertLevelFilter<"prepaid_alerts"> | $Enums.PrepaidAlertLevel
    message?: StringFilter<"prepaid_alerts"> | string
    isRead?: BoolFilter<"prepaid_alerts"> | boolean
    readAt?: DateTimeNullableFilter<"prepaid_alerts"> | Date | string | null
    balanceAtAlert?: FloatNullableFilter<"prepaid_alerts"> | number | null
    consumptionAtAlert?: FloatNullableFilter<"prepaid_alerts"> | number | null
    thresholdValue?: FloatNullableFilter<"prepaid_alerts"> | number | null
    createdAt?: DateTimeFilter<"prepaid_alerts"> | Date | string
  }

  export type prepaid_rechargesUpsertWithWhereUniqueWithoutPrepaid_accountsInput = {
    where: prepaid_rechargesWhereUniqueInput
    update: XOR<prepaid_rechargesUpdateWithoutPrepaid_accountsInput, prepaid_rechargesUncheckedUpdateWithoutPrepaid_accountsInput>
    create: XOR<prepaid_rechargesCreateWithoutPrepaid_accountsInput, prepaid_rechargesUncheckedCreateWithoutPrepaid_accountsInput>
  }

  export type prepaid_rechargesUpdateWithWhereUniqueWithoutPrepaid_accountsInput = {
    where: prepaid_rechargesWhereUniqueInput
    data: XOR<prepaid_rechargesUpdateWithoutPrepaid_accountsInput, prepaid_rechargesUncheckedUpdateWithoutPrepaid_accountsInput>
  }

  export type prepaid_rechargesUpdateManyWithWhereWithoutPrepaid_accountsInput = {
    where: prepaid_rechargesScalarWhereInput
    data: XOR<prepaid_rechargesUpdateManyMutationInput, prepaid_rechargesUncheckedUpdateManyWithoutPrepaid_accountsInput>
  }

  export type prepaid_rechargesScalarWhereInput = {
    AND?: prepaid_rechargesScalarWhereInput | prepaid_rechargesScalarWhereInput[]
    OR?: prepaid_rechargesScalarWhereInput[]
    NOT?: prepaid_rechargesScalarWhereInput | prepaid_rechargesScalarWhereInput[]
    id?: IntFilter<"prepaid_recharges"> | number
    accountId?: IntFilter<"prepaid_recharges"> | number
    rechargeId?: StringFilter<"prepaid_recharges"> | string
    amount?: FloatFilter<"prepaid_recharges"> | number
    paymentMethod?: EnumPaymentMethodFilter<"prepaid_recharges"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"prepaid_recharges"> | $Enums.PaymentStatus
    gatewayName?: StringNullableFilter<"prepaid_recharges"> | string | null
    gatewayTransactionId?: StringNullableFilter<"prepaid_recharges"> | string | null
    gatewayResponse?: JsonNullableFilter<"prepaid_recharges">
    rechargeType?: EnumPrepaidRechargeTypeFilter<"prepaid_recharges"> | $Enums.PrepaidRechargeType
    rechargeSource?: EnumPrepaidRechargeSourceFilter<"prepaid_recharges"> | $Enums.PrepaidRechargeSource
    isPromotional?: BoolFilter<"prepaid_recharges"> | boolean
    promotionalCode?: StringNullableFilter<"prepaid_recharges"> | string | null
    discountAmount?: FloatFilter<"prepaid_recharges"> | number
    bonusAmount?: FloatFilter<"prepaid_recharges"> | number
    receiptNumber?: StringNullableFilter<"prepaid_recharges"> | string | null
    receiptUrl?: StringNullableFilter<"prepaid_recharges"> | string | null
    createdAt?: DateTimeFilter<"prepaid_recharges"> | Date | string
    updatedAt?: DateTimeFilter<"prepaid_recharges"> | Date | string
  }

  export type prepaid_transactionsUpsertWithWhereUniqueWithoutPrepaid_accountsInput = {
    where: prepaid_transactionsWhereUniqueInput
    update: XOR<prepaid_transactionsUpdateWithoutPrepaid_accountsInput, prepaid_transactionsUncheckedUpdateWithoutPrepaid_accountsInput>
    create: XOR<prepaid_transactionsCreateWithoutPrepaid_accountsInput, prepaid_transactionsUncheckedCreateWithoutPrepaid_accountsInput>
  }

  export type prepaid_transactionsUpdateWithWhereUniqueWithoutPrepaid_accountsInput = {
    where: prepaid_transactionsWhereUniqueInput
    data: XOR<prepaid_transactionsUpdateWithoutPrepaid_accountsInput, prepaid_transactionsUncheckedUpdateWithoutPrepaid_accountsInput>
  }

  export type prepaid_transactionsUpdateManyWithWhereWithoutPrepaid_accountsInput = {
    where: prepaid_transactionsScalarWhereInput
    data: XOR<prepaid_transactionsUpdateManyMutationInput, prepaid_transactionsUncheckedUpdateManyWithoutPrepaid_accountsInput>
  }

  export type prepaid_accountsCreateWithoutPrepaid_alertsInput = {
    accountNumber: string
    currentBalance?: number
    totalRecharged?: number
    totalConsumed?: number
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: string | null
    blockedAt?: Date | string | null
    blockedBy?: number | null
    lowBalanceThreshold?: number
    emergencyThreshold?: number
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: number | null
    autoRechargeThreshold?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers: consumersCreateNestedOneWithoutPrepaid_accountsInput
    prepaid_recharges?: prepaid_rechargesCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_transactions?: prepaid_transactionsCreateNestedManyWithoutPrepaid_accountsInput
  }

  export type prepaid_accountsUncheckedCreateWithoutPrepaid_alertsInput = {
    id?: number
    consumerId: number
    accountNumber: string
    currentBalance?: number
    totalRecharged?: number
    totalConsumed?: number
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: string | null
    blockedAt?: Date | string | null
    blockedBy?: number | null
    lowBalanceThreshold?: number
    emergencyThreshold?: number
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: number | null
    autoRechargeThreshold?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    prepaid_recharges?: prepaid_rechargesUncheckedCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_transactions?: prepaid_transactionsUncheckedCreateNestedManyWithoutPrepaid_accountsInput
  }

  export type prepaid_accountsCreateOrConnectWithoutPrepaid_alertsInput = {
    where: prepaid_accountsWhereUniqueInput
    create: XOR<prepaid_accountsCreateWithoutPrepaid_alertsInput, prepaid_accountsUncheckedCreateWithoutPrepaid_alertsInput>
  }

  export type prepaid_accountsUpsertWithoutPrepaid_alertsInput = {
    update: XOR<prepaid_accountsUpdateWithoutPrepaid_alertsInput, prepaid_accountsUncheckedUpdateWithoutPrepaid_alertsInput>
    create: XOR<prepaid_accountsCreateWithoutPrepaid_alertsInput, prepaid_accountsUncheckedCreateWithoutPrepaid_alertsInput>
    where?: prepaid_accountsWhereInput
  }

  export type prepaid_accountsUpdateToOneWithWhereWithoutPrepaid_alertsInput = {
    where?: prepaid_accountsWhereInput
    data: XOR<prepaid_accountsUpdateWithoutPrepaid_alertsInput, prepaid_accountsUncheckedUpdateWithoutPrepaid_alertsInput>
  }

  export type prepaid_accountsUpdateWithoutPrepaid_alertsInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneRequiredWithoutPrepaid_accountsNestedInput
    prepaid_recharges?: prepaid_rechargesUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_transactions?: prepaid_transactionsUpdateManyWithoutPrepaid_accountsNestedInput
  }

  export type prepaid_accountsUncheckedUpdateWithoutPrepaid_alertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepaid_recharges?: prepaid_rechargesUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_transactions?: prepaid_transactionsUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
  }

  export type prepaid_accountsCreateWithoutPrepaid_rechargesInput = {
    accountNumber: string
    currentBalance?: number
    totalRecharged?: number
    totalConsumed?: number
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: string | null
    blockedAt?: Date | string | null
    blockedBy?: number | null
    lowBalanceThreshold?: number
    emergencyThreshold?: number
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: number | null
    autoRechargeThreshold?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers: consumersCreateNestedOneWithoutPrepaid_accountsInput
    prepaid_alerts?: prepaid_alertsCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_transactions?: prepaid_transactionsCreateNestedManyWithoutPrepaid_accountsInput
  }

  export type prepaid_accountsUncheckedCreateWithoutPrepaid_rechargesInput = {
    id?: number
    consumerId: number
    accountNumber: string
    currentBalance?: number
    totalRecharged?: number
    totalConsumed?: number
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: string | null
    blockedAt?: Date | string | null
    blockedBy?: number | null
    lowBalanceThreshold?: number
    emergencyThreshold?: number
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: number | null
    autoRechargeThreshold?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    prepaid_alerts?: prepaid_alertsUncheckedCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_transactions?: prepaid_transactionsUncheckedCreateNestedManyWithoutPrepaid_accountsInput
  }

  export type prepaid_accountsCreateOrConnectWithoutPrepaid_rechargesInput = {
    where: prepaid_accountsWhereUniqueInput
    create: XOR<prepaid_accountsCreateWithoutPrepaid_rechargesInput, prepaid_accountsUncheckedCreateWithoutPrepaid_rechargesInput>
  }

  export type prepaid_accountsUpsertWithoutPrepaid_rechargesInput = {
    update: XOR<prepaid_accountsUpdateWithoutPrepaid_rechargesInput, prepaid_accountsUncheckedUpdateWithoutPrepaid_rechargesInput>
    create: XOR<prepaid_accountsCreateWithoutPrepaid_rechargesInput, prepaid_accountsUncheckedCreateWithoutPrepaid_rechargesInput>
    where?: prepaid_accountsWhereInput
  }

  export type prepaid_accountsUpdateToOneWithWhereWithoutPrepaid_rechargesInput = {
    where?: prepaid_accountsWhereInput
    data: XOR<prepaid_accountsUpdateWithoutPrepaid_rechargesInput, prepaid_accountsUncheckedUpdateWithoutPrepaid_rechargesInput>
  }

  export type prepaid_accountsUpdateWithoutPrepaid_rechargesInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneRequiredWithoutPrepaid_accountsNestedInput
    prepaid_alerts?: prepaid_alertsUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_transactions?: prepaid_transactionsUpdateManyWithoutPrepaid_accountsNestedInput
  }

  export type prepaid_accountsUncheckedUpdateWithoutPrepaid_rechargesInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepaid_alerts?: prepaid_alertsUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_transactions?: prepaid_transactionsUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
  }

  export type prepaid_accountsCreateWithoutPrepaid_transactionsInput = {
    accountNumber: string
    currentBalance?: number
    totalRecharged?: number
    totalConsumed?: number
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: string | null
    blockedAt?: Date | string | null
    blockedBy?: number | null
    lowBalanceThreshold?: number
    emergencyThreshold?: number
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: number | null
    autoRechargeThreshold?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    consumers: consumersCreateNestedOneWithoutPrepaid_accountsInput
    prepaid_alerts?: prepaid_alertsCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_recharges?: prepaid_rechargesCreateNestedManyWithoutPrepaid_accountsInput
  }

  export type prepaid_accountsUncheckedCreateWithoutPrepaid_transactionsInput = {
    id?: number
    consumerId: number
    accountNumber: string
    currentBalance?: number
    totalRecharged?: number
    totalConsumed?: number
    isActive?: boolean
    isBlocked?: boolean
    blockReason?: string | null
    blockedAt?: Date | string | null
    blockedBy?: number | null
    lowBalanceThreshold?: number
    emergencyThreshold?: number
    autoRechargeEnabled?: boolean
    autoRechargeAmount?: number | null
    autoRechargeThreshold?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    prepaid_alerts?: prepaid_alertsUncheckedCreateNestedManyWithoutPrepaid_accountsInput
    prepaid_recharges?: prepaid_rechargesUncheckedCreateNestedManyWithoutPrepaid_accountsInput
  }

  export type prepaid_accountsCreateOrConnectWithoutPrepaid_transactionsInput = {
    where: prepaid_accountsWhereUniqueInput
    create: XOR<prepaid_accountsCreateWithoutPrepaid_transactionsInput, prepaid_accountsUncheckedCreateWithoutPrepaid_transactionsInput>
  }

  export type meter_readingsCreateWithoutPrepaid_transactionsInput = {
    readingDate: Date | string
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh?: number | null
    kVARh?: number | null
    powerFactor?: number | null
    averagePF?: number | null
    minimumPF?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    averageVoltage?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    averageCurrent?: number | null
    isValid?: boolean
    validatedBy?: string | null
    validatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    kVA?: number | null
    kW?: number | null
    bphPowerFactor?: number | null
    frequency?: number | null
    rphPowerFactor?: number | null
    yphPowerFactor?: number | null
    bills?: billsCreateNestedOneWithoutMeter_readingsInput
    meters: metersCreateNestedOneWithoutMeter_readingsInput
  }

  export type meter_readingsUncheckedCreateWithoutPrepaid_transactionsInput = {
    id?: number
    meterId: number
    readingDate: Date | string
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh?: number | null
    kVARh?: number | null
    powerFactor?: number | null
    averagePF?: number | null
    minimumPF?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    averageVoltage?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    averageCurrent?: number | null
    isValid?: boolean
    validatedBy?: string | null
    validatedAt?: Date | string | null
    billId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    kVA?: number | null
    kW?: number | null
    bphPowerFactor?: number | null
    frequency?: number | null
    rphPowerFactor?: number | null
    yphPowerFactor?: number | null
  }

  export type meter_readingsCreateOrConnectWithoutPrepaid_transactionsInput = {
    where: meter_readingsWhereUniqueInput
    create: XOR<meter_readingsCreateWithoutPrepaid_transactionsInput, meter_readingsUncheckedCreateWithoutPrepaid_transactionsInput>
  }

  export type prepaid_accountsUpsertWithoutPrepaid_transactionsInput = {
    update: XOR<prepaid_accountsUpdateWithoutPrepaid_transactionsInput, prepaid_accountsUncheckedUpdateWithoutPrepaid_transactionsInput>
    create: XOR<prepaid_accountsCreateWithoutPrepaid_transactionsInput, prepaid_accountsUncheckedCreateWithoutPrepaid_transactionsInput>
    where?: prepaid_accountsWhereInput
  }

  export type prepaid_accountsUpdateToOneWithWhereWithoutPrepaid_transactionsInput = {
    where?: prepaid_accountsWhereInput
    data: XOR<prepaid_accountsUpdateWithoutPrepaid_transactionsInput, prepaid_accountsUncheckedUpdateWithoutPrepaid_transactionsInput>
  }

  export type prepaid_accountsUpdateWithoutPrepaid_transactionsInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneRequiredWithoutPrepaid_accountsNestedInput
    prepaid_alerts?: prepaid_alertsUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_recharges?: prepaid_rechargesUpdateManyWithoutPrepaid_accountsNestedInput
  }

  export type prepaid_accountsUncheckedUpdateWithoutPrepaid_transactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    consumerId?: IntFieldUpdateOperationsInput | number
    accountNumber?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    totalRecharged?: FloatFieldUpdateOperationsInput | number
    totalConsumed?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    blockReason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedBy?: NullableIntFieldUpdateOperationsInput | number | null
    lowBalanceThreshold?: FloatFieldUpdateOperationsInput | number
    emergencyThreshold?: FloatFieldUpdateOperationsInput | number
    autoRechargeEnabled?: BoolFieldUpdateOperationsInput | boolean
    autoRechargeAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    autoRechargeThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepaid_alerts?: prepaid_alertsUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
    prepaid_recharges?: prepaid_rechargesUncheckedUpdateManyWithoutPrepaid_accountsNestedInput
  }

  export type meter_readingsUpsertWithoutPrepaid_transactionsInput = {
    update: XOR<meter_readingsUpdateWithoutPrepaid_transactionsInput, meter_readingsUncheckedUpdateWithoutPrepaid_transactionsInput>
    create: XOR<meter_readingsCreateWithoutPrepaid_transactionsInput, meter_readingsUncheckedCreateWithoutPrepaid_transactionsInput>
    where?: meter_readingsWhereInput
  }

  export type meter_readingsUpdateToOneWithWhereWithoutPrepaid_transactionsInput = {
    where?: meter_readingsWhereInput
    data: XOR<meter_readingsUpdateWithoutPrepaid_transactionsInput, meter_readingsUncheckedUpdateWithoutPrepaid_transactionsInput>
  }

  export type meter_readingsUpdateWithoutPrepaid_transactionsInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    bills?: billsUpdateOneWithoutMeter_readingsNestedInput
    meters?: metersUpdateOneRequiredWithoutMeter_readingsNestedInput
  }

  export type meter_readingsUncheckedUpdateWithoutPrepaid_transactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type metersCreateWithoutTamper_eventsInput = {
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsCreateNestedManyWithoutMetersInput
    dtrs?: dtrsCreateNestedOneWithoutMetersInput
    locations: locationsCreateNestedOneWithoutMetersInput
    potential_transformers?: potential_transformersCreateNestedManyWithoutMetersInput
  }

  export type metersUncheckedCreateWithoutTamper_eventsInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    locationId: number
    dtrId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    bills?: billsUncheckedCreateNestedManyWithoutMetersInput
    current_transformers?: current_transformersUncheckedCreateNestedManyWithoutMetersInput
    meter_configurations?: meter_configurationsUncheckedCreateNestedOneWithoutMetersInput
    meter_readings?: meter_readingsUncheckedCreateNestedManyWithoutMetersInput
    potential_transformers?: potential_transformersUncheckedCreateNestedManyWithoutMetersInput
  }

  export type metersCreateOrConnectWithoutTamper_eventsInput = {
    where: metersWhereUniqueInput
    create: XOR<metersCreateWithoutTamper_eventsInput, metersUncheckedCreateWithoutTamper_eventsInput>
  }

  export type metersUpsertWithoutTamper_eventsInput = {
    update: XOR<metersUpdateWithoutTamper_eventsInput, metersUncheckedUpdateWithoutTamper_eventsInput>
    create: XOR<metersCreateWithoutTamper_eventsInput, metersUncheckedCreateWithoutTamper_eventsInput>
    where?: metersWhereInput
  }

  export type metersUpdateToOneWithWhereWithoutTamper_eventsInput = {
    where?: metersWhereInput
    data: XOR<metersUpdateWithoutTamper_eventsInput, metersUncheckedUpdateWithoutTamper_eventsInput>
  }

  export type metersUpdateWithoutTamper_eventsInput = {
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutMetersNestedInput
    dtrs?: dtrsUpdateOneWithoutMetersNestedInput
    locations?: locationsUpdateOneRequiredWithoutMetersNestedInput
    potential_transformers?: potential_transformersUpdateManyWithoutMetersNestedInput
  }

  export type metersUncheckedUpdateWithoutTamper_eventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUncheckedUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUncheckedUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutMetersNestedInput
    potential_transformers?: potential_transformersUncheckedUpdateManyWithoutMetersNestedInput
  }

  export type tariff_slabsCreateWithoutTariffInput = {
    slab_order: number
    unit_limit: number
    unit_rate: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tariff_slabsUncheckedCreateWithoutTariffInput = {
    id?: number
    slab_order: number
    unit_limit: number
    unit_rate: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tariff_slabsCreateOrConnectWithoutTariffInput = {
    where: tariff_slabsWhereUniqueInput
    create: XOR<tariff_slabsCreateWithoutTariffInput, tariff_slabsUncheckedCreateWithoutTariffInput>
  }

  export type tariff_slabsCreateManyTariffInputEnvelope = {
    data: tariff_slabsCreateManyTariffInput | tariff_slabsCreateManyTariffInput[]
    skipDuplicates?: boolean
  }

  export type tariff_slabsUpsertWithWhereUniqueWithoutTariffInput = {
    where: tariff_slabsWhereUniqueInput
    update: XOR<tariff_slabsUpdateWithoutTariffInput, tariff_slabsUncheckedUpdateWithoutTariffInput>
    create: XOR<tariff_slabsCreateWithoutTariffInput, tariff_slabsUncheckedCreateWithoutTariffInput>
  }

  export type tariff_slabsUpdateWithWhereUniqueWithoutTariffInput = {
    where: tariff_slabsWhereUniqueInput
    data: XOR<tariff_slabsUpdateWithoutTariffInput, tariff_slabsUncheckedUpdateWithoutTariffInput>
  }

  export type tariff_slabsUpdateManyWithWhereWithoutTariffInput = {
    where: tariff_slabsScalarWhereInput
    data: XOR<tariff_slabsUpdateManyMutationInput, tariff_slabsUncheckedUpdateManyWithoutTariffInput>
  }

  export type tariff_slabsScalarWhereInput = {
    AND?: tariff_slabsScalarWhereInput | tariff_slabsScalarWhereInput[]
    OR?: tariff_slabsScalarWhereInput[]
    NOT?: tariff_slabsScalarWhereInput | tariff_slabsScalarWhereInput[]
    id?: IntFilter<"tariff_slabs"> | number
    tariff_id?: IntFilter<"tariff_slabs"> | number
    slab_order?: IntFilter<"tariff_slabs"> | number
    unit_limit?: IntFilter<"tariff_slabs"> | number
    unit_rate?: FloatFilter<"tariff_slabs"> | number
    created_at?: DateTimeFilter<"tariff_slabs"> | Date | string
    updated_at?: DateTimeFilter<"tariff_slabs"> | Date | string
  }

  export type tariffCreateWithoutTariff_slabsInput = {
    client_id: number
    category: number
    tariff_name: string
    type: string
    device: string
    min_demand?: number | null
    min_demand_unit_rate?: number | null
    min_demand_excess_unit_rate?: number | null
    base_unit_rate: number
    elec_duty_unit_rate?: number | null
    ims?: number | null
    gst?: number | null
    valid_from: Date | string
    valid_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tariffUncheckedCreateWithoutTariff_slabsInput = {
    id?: number
    client_id: number
    category: number
    tariff_name: string
    type: string
    device: string
    min_demand?: number | null
    min_demand_unit_rate?: number | null
    min_demand_excess_unit_rate?: number | null
    base_unit_rate: number
    elec_duty_unit_rate?: number | null
    ims?: number | null
    gst?: number | null
    valid_from: Date | string
    valid_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tariffCreateOrConnectWithoutTariff_slabsInput = {
    where: tariffWhereUniqueInput
    create: XOR<tariffCreateWithoutTariff_slabsInput, tariffUncheckedCreateWithoutTariff_slabsInput>
  }

  export type tariffUpsertWithoutTariff_slabsInput = {
    update: XOR<tariffUpdateWithoutTariff_slabsInput, tariffUncheckedUpdateWithoutTariff_slabsInput>
    create: XOR<tariffCreateWithoutTariff_slabsInput, tariffUncheckedCreateWithoutTariff_slabsInput>
    where?: tariffWhereInput
  }

  export type tariffUpdateToOneWithWhereWithoutTariff_slabsInput = {
    where?: tariffWhereInput
    data: XOR<tariffUpdateWithoutTariff_slabsInput, tariffUncheckedUpdateWithoutTariff_slabsInput>
  }

  export type tariffUpdateWithoutTariff_slabsInput = {
    client_id?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    tariff_name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    min_demand?: NullableIntFieldUpdateOperationsInput | number | null
    min_demand_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    min_demand_excess_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    base_unit_rate?: FloatFieldUpdateOperationsInput | number
    elec_duty_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    ims?: NullableFloatFieldUpdateOperationsInput | number | null
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tariffUncheckedUpdateWithoutTariff_slabsInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    tariff_name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    min_demand?: NullableIntFieldUpdateOperationsInput | number | null
    min_demand_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    min_demand_excess_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    base_unit_rate?: FloatFieldUpdateOperationsInput | number
    elec_duty_unit_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    ims?: NullableFloatFieldUpdateOperationsInput | number | null
    gst?: NullableFloatFieldUpdateOperationsInput | number | null
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_readingsCreateManyBillsInput = {
    id?: number
    meterId: number
    readingDate: Date | string
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh?: number | null
    kVARh?: number | null
    powerFactor?: number | null
    averagePF?: number | null
    minimumPF?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    averageVoltage?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    averageCurrent?: number | null
    isValid?: boolean
    validatedBy?: string | null
    validatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    kVA?: number | null
    kW?: number | null
    bphPowerFactor?: number | null
    frequency?: number | null
    rphPowerFactor?: number | null
    yphPowerFactor?: number | null
  }

  export type paymentsCreateManyBillsInput = {
    id?: number
    transactionId: string
    amount: number
    paymentMode: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type meter_readingsUpdateWithoutBillsInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    meters?: metersUpdateOneRequiredWithoutMeter_readingsNestedInput
    prepaid_transactions?: prepaid_transactionsUpdateManyWithoutMeter_readingsNestedInput
  }

  export type meter_readingsUncheckedUpdateWithoutBillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    prepaid_transactions?: prepaid_transactionsUncheckedUpdateManyWithoutMeter_readingsNestedInput
  }

  export type meter_readingsUncheckedUpdateManyWithoutBillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterId?: IntFieldUpdateOperationsInput | number
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type paymentsUpdateWithoutBillsInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUncheckedUpdateWithoutBillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUncheckedUpdateManyWithoutBillsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billsCreateManyConsumersInput = {
    id?: number
    billNumber: string
    meterId: number
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type consumer_documentsCreateManyConsumersInput = {
    id?: number
    type: $Enums.DocumentType
    number: string
    fileUrl: string
    verificationStatus?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notificationsCreateManyConsumersInput = {
    id?: number
    type: $Enums.NotificationType
    title: string
    message: string
    priority: $Enums.NotificationPriority
    channels?: notificationsCreatechannelsInput | $Enums.NotificationChannel[]
    status?: $Enums.NotificationStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type billsUpdateWithoutConsumersInput = {
    billNumber?: StringFieldUpdateOperationsInput | string
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meters?: metersUpdateOneRequiredWithoutBillsNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutBillsNestedInput
    payments?: paymentsUpdateManyWithoutBillsNestedInput
  }

  export type billsUncheckedUpdateWithoutConsumersInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNumber?: StringFieldUpdateOperationsInput | string
    meterId?: IntFieldUpdateOperationsInput | number
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutBillsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBillsNestedInput
  }

  export type billsUncheckedUpdateManyWithoutConsumersInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNumber?: StringFieldUpdateOperationsInput | string
    meterId?: IntFieldUpdateOperationsInput | number
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consumer_documentsUpdateWithoutConsumersInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consumer_documentsUncheckedUpdateWithoutConsumersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consumer_documentsUncheckedUpdateManyWithoutConsumersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUpdateWithoutConsumersInput = {
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    channels?: notificationsUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateWithoutConsumersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    channels?: notificationsUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyWithoutConsumersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    channels?: notificationsUpdatechannelsInput | $Enums.NotificationChannel[]
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentsCreateManyParentInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type usersCreateManyDepartmentsInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    roleId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
  }

  export type departmentsUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: departmentsUpdateManyWithoutParentNestedInput
    users?: usersUpdateManyWithoutDepartmentsNestedInput
  }

  export type departmentsUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: departmentsUncheckedUpdateManyWithoutParentNestedInput
    users?: usersUncheckedUpdateManyWithoutDepartmentsNestedInput
  }

  export type departmentsUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutDepartmentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateOneWithoutUsersNestedInput
    roles?: rolesUpdateOneWithoutUsersNestedInput
    locations?: locationsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutDepartmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUncheckedUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutDepartmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type dtr_faultsCreateManyDtrsInput = {
    id?: number
    faultType: $Enums.FaultType
    severity: $Enums.FaultSeverity
    occuredAt: Date | string
    resolvedAt?: Date | string | null
    description: string
    rootCause?: string | null
    resolution?: string | null
    affectedMeters?: number | null
    outageMinutes?: number | null
    status?: $Enums.FaultStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_maintenanceCreateManyDtrsInput = {
    id?: number
    maintenanceType: $Enums.MaintenanceType
    scheduledDate: Date | string
    completedDate?: Date | string | null
    workDone: string
    findings?: string | null
    recommendations?: string | null
    oilDielectricTest?: number | null
    oilAcidityTest?: number | null
    moistureContent?: number | null
    performedBy: string
    verifiedBy?: string | null
    status?: $Enums.MaintenanceStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_readingsCreateManyDtrsInput = {
    id?: number
    readingDate: Date | string
    readingType: $Enums.DTRReadingType
    loadKVA: number
    loadPercentage: number
    primaryVoltage: JsonNullValueInput | InputJsonValue
    secondaryVoltage: JsonNullValueInput | InputJsonValue
    primaryCurrent: JsonNullValueInput | InputJsonValue
    secondaryCurrent: JsonNullValueInput | InputJsonValue
    powerFactor?: number | null
    oilTemperature?: number | null
    windingTemperature?: number | null
    ambientTemperature?: number | null
    frequency?: number | null
    voltageUnbalance?: number | null
    currentUnbalance?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type metersCreateManyDtrsInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    locationId: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ticketsCreateManyDtrsInput = {
    id?: number
    ticketNumber: string
    raisedById: number
    assignedToId?: number | null
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type dtr_faultsUpdateWithoutDtrsInput = {
    faultType?: EnumFaultTypeFieldUpdateOperationsInput | $Enums.FaultType
    severity?: EnumFaultSeverityFieldUpdateOperationsInput | $Enums.FaultSeverity
    occuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedMeters?: NullableIntFieldUpdateOperationsInput | number | null
    outageMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFaultStatusFieldUpdateOperationsInput | $Enums.FaultStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_faultsUncheckedUpdateWithoutDtrsInput = {
    id?: IntFieldUpdateOperationsInput | number
    faultType?: EnumFaultTypeFieldUpdateOperationsInput | $Enums.FaultType
    severity?: EnumFaultSeverityFieldUpdateOperationsInput | $Enums.FaultSeverity
    occuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedMeters?: NullableIntFieldUpdateOperationsInput | number | null
    outageMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFaultStatusFieldUpdateOperationsInput | $Enums.FaultStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_faultsUncheckedUpdateManyWithoutDtrsInput = {
    id?: IntFieldUpdateOperationsInput | number
    faultType?: EnumFaultTypeFieldUpdateOperationsInput | $Enums.FaultType
    severity?: EnumFaultSeverityFieldUpdateOperationsInput | $Enums.FaultSeverity
    occuredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedMeters?: NullableIntFieldUpdateOperationsInput | number | null
    outageMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumFaultStatusFieldUpdateOperationsInput | $Enums.FaultStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_maintenanceUpdateWithoutDtrsInput = {
    maintenanceType?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workDone?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    oilDielectricTest?: NullableFloatFieldUpdateOperationsInput | number | null
    oilAcidityTest?: NullableFloatFieldUpdateOperationsInput | number | null
    moistureContent?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_maintenanceUncheckedUpdateWithoutDtrsInput = {
    id?: IntFieldUpdateOperationsInput | number
    maintenanceType?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workDone?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    oilDielectricTest?: NullableFloatFieldUpdateOperationsInput | number | null
    oilAcidityTest?: NullableFloatFieldUpdateOperationsInput | number | null
    moistureContent?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_maintenanceUncheckedUpdateManyWithoutDtrsInput = {
    id?: IntFieldUpdateOperationsInput | number
    maintenanceType?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workDone?: StringFieldUpdateOperationsInput | string
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    oilDielectricTest?: NullableFloatFieldUpdateOperationsInput | number | null
    oilAcidityTest?: NullableFloatFieldUpdateOperationsInput | number | null
    moistureContent?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_readingsUpdateWithoutDtrsInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumDTRReadingTypeFieldUpdateOperationsInput | $Enums.DTRReadingType
    loadKVA?: FloatFieldUpdateOperationsInput | number
    loadPercentage?: FloatFieldUpdateOperationsInput | number
    primaryVoltage?: JsonNullValueInput | InputJsonValue
    secondaryVoltage?: JsonNullValueInput | InputJsonValue
    primaryCurrent?: JsonNullValueInput | InputJsonValue
    secondaryCurrent?: JsonNullValueInput | InputJsonValue
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    windingTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    currentUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_readingsUncheckedUpdateWithoutDtrsInput = {
    id?: IntFieldUpdateOperationsInput | number
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumDTRReadingTypeFieldUpdateOperationsInput | $Enums.DTRReadingType
    loadKVA?: FloatFieldUpdateOperationsInput | number
    loadPercentage?: FloatFieldUpdateOperationsInput | number
    primaryVoltage?: JsonNullValueInput | InputJsonValue
    secondaryVoltage?: JsonNullValueInput | InputJsonValue
    primaryCurrent?: JsonNullValueInput | InputJsonValue
    secondaryCurrent?: JsonNullValueInput | InputJsonValue
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    windingTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    currentUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtr_readingsUncheckedUpdateManyWithoutDtrsInput = {
    id?: IntFieldUpdateOperationsInput | number
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumDTRReadingTypeFieldUpdateOperationsInput | $Enums.DTRReadingType
    loadKVA?: FloatFieldUpdateOperationsInput | number
    loadPercentage?: FloatFieldUpdateOperationsInput | number
    primaryVoltage?: JsonNullValueInput | InputJsonValue
    secondaryVoltage?: JsonNullValueInput | InputJsonValue
    primaryCurrent?: JsonNullValueInput | InputJsonValue
    secondaryCurrent?: JsonNullValueInput | InputJsonValue
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    windingTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    ambientTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    currentUnbalance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type metersUpdateWithoutDtrsInput = {
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutMetersNestedInput
    locations?: locationsUpdateOneRequiredWithoutMetersNestedInput
    potential_transformers?: potential_transformersUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUpdateManyWithoutMetersNestedInput
  }

  export type metersUncheckedUpdateWithoutDtrsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUncheckedUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUncheckedUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutMetersNestedInput
    potential_transformers?: potential_transformersUncheckedUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUncheckedUpdateManyWithoutMetersNestedInput
  }

  export type metersUncheckedUpdateManyWithoutDtrsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsUpdateWithoutDtrsInput = {
    ticketNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_tickets_assignedToIdTousers?: usersUpdateOneWithoutTickets_tickets_assignedToIdTousersNestedInput
    users_tickets_raisedByIdTousers?: usersUpdateOneRequiredWithoutTickets_tickets_raisedByIdTousersNestedInput
  }

  export type ticketsUncheckedUpdateWithoutDtrsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketNumber?: StringFieldUpdateOperationsInput | string
    raisedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsUncheckedUpdateManyWithoutDtrsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketNumber?: StringFieldUpdateOperationsInput | string
    raisedById?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationsCreateManyLocation_typesInput = {
    id?: number
    name: string
    code: string
    parentId?: number | null
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type locationsUpdateWithoutLocation_typesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUpdateManyWithoutLocationsNestedInput
    locations?: locationsUpdateOneWithoutOther_locationsNestedInput
    other_locations?: locationsUpdateManyWithoutLocationsNestedInput
    meters?: metersUpdateManyWithoutLocationsNestedInput
    users?: usersUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateWithoutLocation_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUncheckedUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUncheckedUpdateManyWithoutLocationsNestedInput
    other_locations?: locationsUncheckedUpdateManyWithoutLocationsNestedInput
    meters?: metersUncheckedUpdateManyWithoutLocationsNestedInput
    users?: usersUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateManyWithoutLocation_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dtrsCreateManyLocationsInput = {
    id?: number
    dtrNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    capacity: number
    type: $Enums.DTRType
    phase: number
    primaryVoltage: number
    secondaryVoltage: number
    frequency?: number
    impedance?: number | null
    coolingType: $Enums.CoolingType
    oilType?: $Enums.OilType | null
    oilCapacity?: number | null
    installationDate: Date | string
    commissionDate?: Date | string | null
    lastMaintenanceDate?: Date | string | null
    maxLoadLimit?: number | null
    alarmThreshold?: number | null
    tripThreshold?: number | null
    status?: $Enums.DTRStatus
    healthIndex?: number | null
    temperature?: number | null
    loadPercentage?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type locationsCreateManyLocationsInput = {
    id?: number
    name: string
    code: string
    locationTypeId: number
    latitude?: number | null
    longitude?: number | null
    address?: string | null
    pincode?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type metersCreateManyLocationsInput = {
    id?: number
    meterNumber: string
    serialNumber: string
    manufacturer: string
    model: string
    type: $Enums.MeterType
    phase: number
    status?: $Enums.MeterStatus
    isInUse?: boolean
    installationDate: Date | string
    lastMaintenanceDate?: Date | string | null
    decommissionDate?: Date | string | null
    dtrId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type usersCreateManyLocationsInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    roleId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
  }

  export type dtrsUpdateWithoutLocationsInput = {
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUpdateManyWithoutDtrsNestedInput
    dtr_maintenance?: dtr_maintenanceUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUpdateManyWithoutDtrsNestedInput
    meters?: metersUpdateManyWithoutDtrsNestedInput
    tickets?: ticketsUpdateManyWithoutDtrsNestedInput
  }

  export type dtrsUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtr_faults?: dtr_faultsUncheckedUpdateManyWithoutDtrsNestedInput
    dtr_maintenance?: dtr_maintenanceUncheckedUpdateManyWithoutDtrsNestedInput
    dtr_readings?: dtr_readingsUncheckedUpdateManyWithoutDtrsNestedInput
    meters?: metersUncheckedUpdateManyWithoutDtrsNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutDtrsNestedInput
  }

  export type dtrsUncheckedUpdateManyWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    dtrNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    type?: EnumDTRTypeFieldUpdateOperationsInput | $Enums.DTRType
    phase?: IntFieldUpdateOperationsInput | number
    primaryVoltage?: FloatFieldUpdateOperationsInput | number
    secondaryVoltage?: FloatFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    impedance?: NullableFloatFieldUpdateOperationsInput | number | null
    coolingType?: EnumCoolingTypeFieldUpdateOperationsInput | $Enums.CoolingType
    oilType?: NullableEnumOilTypeFieldUpdateOperationsInput | $Enums.OilType | null
    oilCapacity?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    commissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxLoadLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    alarmThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    tripThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumDTRStatusFieldUpdateOperationsInput | $Enums.DTRStatus
    healthIndex?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    loadPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationsUpdateWithoutLocationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUpdateManyWithoutLocationsNestedInput
    location_types?: location_typesUpdateOneRequiredWithoutLocationsNestedInput
    other_locations?: locationsUpdateManyWithoutLocationsNestedInput
    meters?: metersUpdateManyWithoutLocationsNestedInput
    users?: usersUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationTypeId?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUncheckedUpdateOneWithoutLocationsNestedInput
    dtrs?: dtrsUncheckedUpdateManyWithoutLocationsNestedInput
    other_locations?: locationsUncheckedUpdateManyWithoutLocationsNestedInput
    meters?: metersUncheckedUpdateManyWithoutLocationsNestedInput
    users?: usersUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateManyWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    locationTypeId?: IntFieldUpdateOperationsInput | number
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type metersUpdateWithoutLocationsInput = {
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutMetersNestedInput
    dtrs?: dtrsUpdateOneWithoutMetersNestedInput
    potential_transformers?: potential_transformersUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUpdateManyWithoutMetersNestedInput
  }

  export type metersUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: billsUncheckedUpdateManyWithoutMetersNestedInput
    current_transformers?: current_transformersUncheckedUpdateManyWithoutMetersNestedInput
    meter_configurations?: meter_configurationsUncheckedUpdateOneWithoutMetersNestedInput
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutMetersNestedInput
    potential_transformers?: potential_transformersUncheckedUpdateManyWithoutMetersNestedInput
    tamper_events?: tamper_eventsUncheckedUpdateManyWithoutMetersNestedInput
  }

  export type metersUncheckedUpdateManyWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meterNumber?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    type?: EnumMeterTypeFieldUpdateOperationsInput | $Enums.MeterType
    phase?: IntFieldUpdateOperationsInput | number
    status?: EnumMeterStatusFieldUpdateOperationsInput | $Enums.MeterStatus
    isInUse?: BoolFieldUpdateOperationsInput | boolean
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMaintenanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    decommissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutLocationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateOneWithoutUsersNestedInput
    departments?: departmentsUpdateOneWithoutUsersNestedInput
    roles?: rolesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUncheckedUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type prepaid_transactionsCreateManyMeter_readingsInput = {
    id?: number
    accountId: number
    transactionId: string
    transactionType: $Enums.PrepaidTransactionType
    amount: number
    balanceBefore: number
    balanceAfter: number
    consumptionKWh?: number | null
    ratePerUnit?: number | null
    fixedCharges?: number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.PrepaidTransactionStatus
    failureReason?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_transactionsUpdateWithoutMeter_readingsInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumPrepaidTransactionTypeFieldUpdateOperationsInput | $Enums.PrepaidTransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    consumptionKWh?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerUnit?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedCharges?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPrepaidTransactionStatusFieldUpdateOperationsInput | $Enums.PrepaidTransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepaid_accounts?: prepaid_accountsUpdateOneRequiredWithoutPrepaid_transactionsNestedInput
  }

  export type prepaid_transactionsUncheckedUpdateWithoutMeter_readingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumPrepaidTransactionTypeFieldUpdateOperationsInput | $Enums.PrepaidTransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    consumptionKWh?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerUnit?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedCharges?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPrepaidTransactionStatusFieldUpdateOperationsInput | $Enums.PrepaidTransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_transactionsUncheckedUpdateManyWithoutMeter_readingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumPrepaidTransactionTypeFieldUpdateOperationsInput | $Enums.PrepaidTransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    consumptionKWh?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerUnit?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedCharges?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPrepaidTransactionStatusFieldUpdateOperationsInput | $Enums.PrepaidTransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type billsCreateManyMetersInput = {
    id?: number
    billNumber: string
    consumerId: number
    billMonth: number
    billYear: number
    fromDate: Date | string
    toDate: Date | string
    dueDate: Date | string
    previousReading: number
    currentReading: number
    unitsConsumed: number
    fixedCharge: number
    energyCharge: number
    powerFactorCharge?: number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal: number
    taxes: JsonNullValueInput | InputJsonValue
    totalAmount: number
    status?: $Enums.BillStatus
    isPaid?: boolean
    paidAmount?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type current_transformersCreateManyMetersInput = {
    id?: number
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type meter_readingsCreateManyMetersInput = {
    id?: number
    readingDate: Date | string
    readingType: $Enums.ReadingType
    readingSource: $Enums.ReadingSource
    currentReading: number
    previousReading: number
    consumption: number
    kWh: number
    kVAh?: number | null
    kVARh?: number | null
    powerFactor?: number | null
    averagePF?: number | null
    minimumPF?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    averageVoltage?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    averageCurrent?: number | null
    isValid?: boolean
    validatedBy?: string | null
    validatedAt?: Date | string | null
    billId?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    kVA?: number | null
    kW?: number | null
    bphPowerFactor?: number | null
    frequency?: number | null
    rphPowerFactor?: number | null
    yphPowerFactor?: number | null
  }

  export type potential_transformersCreateManyMetersInput = {
    id?: number
    serialNumber: string
    manufacturer: string
    model: string
    ratedPrimary: number
    ratedSecondary: number
    accuracyClass: string
    burden: number
    installationDate: Date | string
    lastTestedDate?: Date | string | null
    nextTestDue?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type tamper_eventsCreateManyMetersInput = {
    id?: number
    tamperDatetime?: Date | string
    tamperType: $Enums.TamperType
    tamperStatus: $Enums.TamperStatus
    avgCurrent?: number | null
    avgVoltage?: number | null
    avgPowerFactor?: number | null
    frequency?: number | null
    kwh?: number | null
    kwhExport?: number | null
    kwhImport?: number | null
    kwhNet?: number | null
    kwhTotal?: number | null
    kwExport?: number | null
    kwImport?: number | null
    kvaExport?: number | null
    kvaImport?: number | null
    voltageR?: number | null
    voltageY?: number | null
    voltageB?: number | null
    currentR?: number | null
    currentY?: number | null
    currentB?: number | null
    powerFactorR?: number | null
    powerFactorY?: number | null
    powerFactorB?: number | null
    tamperCount?: number | null
    param1?: number | null
    param2?: number | null
    param3?: number | null
    param4?: number | null
    param5?: number | null
    isProcessed?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type billsUpdateWithoutMetersInput = {
    billNumber?: StringFieldUpdateOperationsInput | string
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumers?: consumersUpdateOneRequiredWithoutBillsNestedInput
    meter_readings?: meter_readingsUpdateManyWithoutBillsNestedInput
    payments?: paymentsUpdateManyWithoutBillsNestedInput
  }

  export type billsUncheckedUpdateWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNumber?: StringFieldUpdateOperationsInput | string
    consumerId?: IntFieldUpdateOperationsInput | number
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meter_readings?: meter_readingsUncheckedUpdateManyWithoutBillsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBillsNestedInput
  }

  export type billsUncheckedUpdateManyWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNumber?: StringFieldUpdateOperationsInput | string
    consumerId?: IntFieldUpdateOperationsInput | number
    billMonth?: IntFieldUpdateOperationsInput | number
    billYear?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    previousReading?: FloatFieldUpdateOperationsInput | number
    currentReading?: FloatFieldUpdateOperationsInput | number
    unitsConsumed?: FloatFieldUpdateOperationsInput | number
    fixedCharge?: FloatFieldUpdateOperationsInput | number
    energyCharge?: FloatFieldUpdateOperationsInput | number
    powerFactorCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    otherCharges?: NullableJsonNullValueInput | InputJsonValue
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxes?: JsonNullValueInput | InputJsonValue
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type current_transformersUpdateWithoutMetersInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type current_transformersUncheckedUpdateWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type current_transformersUncheckedUpdateManyWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meter_readingsUpdateWithoutMetersInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    bills?: billsUpdateOneWithoutMeter_readingsNestedInput
    prepaid_transactions?: prepaid_transactionsUpdateManyWithoutMeter_readingsNestedInput
  }

  export type meter_readingsUncheckedUpdateWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    prepaid_transactions?: prepaid_transactionsUncheckedUpdateManyWithoutMeter_readingsNestedInput
  }

  export type meter_readingsUncheckedUpdateManyWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    readingSource?: EnumReadingSourceFieldUpdateOperationsInput | $Enums.ReadingSource
    currentReading?: FloatFieldUpdateOperationsInput | number
    previousReading?: FloatFieldUpdateOperationsInput | number
    consumption?: FloatFieldUpdateOperationsInput | number
    kWh?: FloatFieldUpdateOperationsInput | number
    kVAh?: NullableFloatFieldUpdateOperationsInput | number | null
    kVARh?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    averagePF?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumPF?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kVA?: NullableFloatFieldUpdateOperationsInput | number | null
    kW?: NullableFloatFieldUpdateOperationsInput | number | null
    bphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    rphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    yphPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type potential_transformersUpdateWithoutMetersInput = {
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type potential_transformersUncheckedUpdateWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type potential_transformersUncheckedUpdateManyWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    ratedPrimary?: FloatFieldUpdateOperationsInput | number
    ratedSecondary?: FloatFieldUpdateOperationsInput | number
    accuracyClass?: StringFieldUpdateOperationsInput | string
    burden?: FloatFieldUpdateOperationsInput | number
    installationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastTestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextTestDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tamper_eventsUpdateWithoutMetersInput = {
    tamperDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    tamperType?: EnumTamperTypeFieldUpdateOperationsInput | $Enums.TamperType
    tamperStatus?: EnumTamperStatusFieldUpdateOperationsInput | $Enums.TamperStatus
    avgCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    avgVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    avgPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    kwh?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhNet?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    kwExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaImport?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorR?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorY?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorB?: NullableFloatFieldUpdateOperationsInput | number | null
    tamperCount?: NullableIntFieldUpdateOperationsInput | number | null
    param1?: NullableFloatFieldUpdateOperationsInput | number | null
    param2?: NullableFloatFieldUpdateOperationsInput | number | null
    param3?: NullableFloatFieldUpdateOperationsInput | number | null
    param4?: NullableFloatFieldUpdateOperationsInput | number | null
    param5?: NullableFloatFieldUpdateOperationsInput | number | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tamper_eventsUncheckedUpdateWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    tamperDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    tamperType?: EnumTamperTypeFieldUpdateOperationsInput | $Enums.TamperType
    tamperStatus?: EnumTamperStatusFieldUpdateOperationsInput | $Enums.TamperStatus
    avgCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    avgVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    avgPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    kwh?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhNet?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    kwExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaImport?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorR?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorY?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorB?: NullableFloatFieldUpdateOperationsInput | number | null
    tamperCount?: NullableIntFieldUpdateOperationsInput | number | null
    param1?: NullableFloatFieldUpdateOperationsInput | number | null
    param2?: NullableFloatFieldUpdateOperationsInput | number | null
    param3?: NullableFloatFieldUpdateOperationsInput | number | null
    param4?: NullableFloatFieldUpdateOperationsInput | number | null
    param5?: NullableFloatFieldUpdateOperationsInput | number | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tamper_eventsUncheckedUpdateManyWithoutMetersInput = {
    id?: IntFieldUpdateOperationsInput | number
    tamperDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    tamperType?: EnumTamperTypeFieldUpdateOperationsInput | $Enums.TamperType
    tamperStatus?: EnumTamperStatusFieldUpdateOperationsInput | $Enums.TamperStatus
    avgCurrent?: NullableFloatFieldUpdateOperationsInput | number | null
    avgVoltage?: NullableFloatFieldUpdateOperationsInput | number | null
    avgPowerFactor?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    kwh?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhNet?: NullableFloatFieldUpdateOperationsInput | number | null
    kwhTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    kwExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kwImport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaExport?: NullableFloatFieldUpdateOperationsInput | number | null
    kvaImport?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageR?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageY?: NullableFloatFieldUpdateOperationsInput | number | null
    voltageB?: NullableFloatFieldUpdateOperationsInput | number | null
    currentR?: NullableFloatFieldUpdateOperationsInput | number | null
    currentY?: NullableFloatFieldUpdateOperationsInput | number | null
    currentB?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorR?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorY?: NullableFloatFieldUpdateOperationsInput | number | null
    powerFactorB?: NullableFloatFieldUpdateOperationsInput | number | null
    tamperCount?: NullableIntFieldUpdateOperationsInput | number | null
    param1?: NullableFloatFieldUpdateOperationsInput | number | null
    param2?: NullableFloatFieldUpdateOperationsInput | number | null
    param3?: NullableFloatFieldUpdateOperationsInput | number | null
    param4?: NullableFloatFieldUpdateOperationsInput | number | null
    param5?: NullableFloatFieldUpdateOperationsInput | number | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_permissionsCreateManyPermissionsInput = {
    id?: number
    userId: number
    isGranted?: boolean
    reason?: string | null
    validFrom?: Date | string
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_permissionsUpdateWithoutPermissionsInput = {
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_permissionsNestedInput
  }

  export type user_permissionsUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_permissionsUncheckedUpdateManyWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type role_permissionsCreateManyRolesInput = {
    id?: number
    permissionId: JsonNullValueInput | InputJsonValue
    isGranted?: boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type usersCreateManyRolesInput = {
    id?: number
    username: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    profileImage?: string | null
    isActive?: boolean
    isLocked?: boolean
    lastLoginAt?: Date | string | null
    passwordChangedAt?: Date | string | null
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    departmentId?: number | null
    locationId?: number | null
    accessLevel?: $Enums.AccessLevel
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: number | null
    updatedBy?: number | null
  }

  export type role_permissionsUpdateWithoutRolesInput = {
    permissionId?: JsonNullValueInput | InputJsonValue
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type role_permissionsUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: JsonNullValueInput | InputJsonValue
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type role_permissionsUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: JsonNullValueInput | InputJsonValue
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUpdateOneWithoutUsersNestedInput
    departments?: departmentsUpdateOneWithoutUsersNestedInput
    locations?: locationsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    login_history?: login_historyUncheckedUpdateManyWithoutUsersNestedInput
    tickets_tickets_assignedToIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersNestedInput
    tickets_tickets_raisedByIdTousers?: ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersNestedInput
    user_activity_logs?: user_activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUsersNestedInput
    user_sessions?: user_sessionsUncheckedUpdateManyWithoutUsersNestedInput
    refresh_tokens?: refresh_tokensUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type login_historyCreateManyUsersInput = {
    id?: number
    status: string
    ipAddress?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type ticketsCreateManyUsers_tickets_assignedToIdTousersInput = {
    id?: number
    ticketNumber: string
    dtrId?: number | null
    raisedById: number
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ticketsCreateManyUsers_tickets_raisedByIdTousersInput = {
    id?: number
    ticketNumber: string
    dtrId?: number | null
    assignedToId?: number | null
    type: $Enums.TicketType
    category: $Enums.TicketCategory
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    subject: string
    description: string
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_activity_logsCreateManyUsersInput = {
    id?: number
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type user_permissionsCreateManyUsersInput = {
    id?: number
    permissionId: number
    isGranted?: boolean
    reason?: string | null
    validFrom?: Date | string
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_sessionsCreateManyUsersInput = {
    id?: number
    sessionToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    location?: string | null
    isActive?: boolean
    lastActivityAt?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type login_historyUpdateWithoutUsersInput = {
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type login_historyUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type login_historyUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsUpdateWithoutUsers_tickets_assignedToIdTousersInput = {
    ticketNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dtrs?: dtrsUpdateOneWithoutTicketsNestedInput
    users_tickets_raisedByIdTousers?: usersUpdateOneRequiredWithoutTickets_tickets_raisedByIdTousersNestedInput
  }

  export type ticketsUncheckedUpdateWithoutUsers_tickets_assignedToIdTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketNumber?: StringFieldUpdateOperationsInput | string
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    raisedById?: IntFieldUpdateOperationsInput | number
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsUncheckedUpdateManyWithoutUsers_tickets_assignedToIdTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketNumber?: StringFieldUpdateOperationsInput | string
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    raisedById?: IntFieldUpdateOperationsInput | number
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsUpdateWithoutUsers_tickets_raisedByIdTousersInput = {
    ticketNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_tickets_assignedToIdTousers?: usersUpdateOneWithoutTickets_tickets_assignedToIdTousersNestedInput
    dtrs?: dtrsUpdateOneWithoutTicketsNestedInput
  }

  export type ticketsUncheckedUpdateWithoutUsers_tickets_raisedByIdTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketNumber?: StringFieldUpdateOperationsInput | string
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsUncheckedUpdateManyWithoutUsers_tickets_raisedByIdTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketNumber?: StringFieldUpdateOperationsInput | string
    dtrId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_activity_logsUpdateWithoutUsersInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_activity_logsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_activity_logsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_permissionsUpdateWithoutUsersInput = {
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: permissionsUpdateOneRequiredWithoutUser_permissionsNestedInput
  }

  export type user_permissionsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_permissionsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    isGranted?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_sessionsUpdateWithoutUsersInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_sessionsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_sessionsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_alertsCreateManyPrepaid_accountsInput = {
    id?: number
    alertType: $Enums.PrepaidAlertType
    alertLevel: $Enums.PrepaidAlertLevel
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    balanceAtAlert?: number | null
    consumptionAtAlert?: number | null
    thresholdValue?: number | null
    createdAt?: Date | string
  }

  export type prepaid_rechargesCreateManyPrepaid_accountsInput = {
    id?: number
    rechargeId: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayName?: string | null
    gatewayTransactionId?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: $Enums.PrepaidRechargeType
    rechargeSource?: $Enums.PrepaidRechargeSource
    isPromotional?: boolean
    promotionalCode?: string | null
    discountAmount?: number
    bonusAmount?: number
    receiptNumber?: string | null
    receiptUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_transactionsCreateManyPrepaid_accountsInput = {
    id?: number
    transactionId: string
    transactionType: $Enums.PrepaidTransactionType
    amount: number
    balanceBefore: number
    balanceAfter: number
    consumptionKWh?: number | null
    ratePerUnit?: number | null
    fixedCharges?: number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    readingId?: number | null
    status?: $Enums.PrepaidTransactionStatus
    failureReason?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type prepaid_alertsUpdateWithoutPrepaid_accountsInput = {
    alertType?: EnumPrepaidAlertTypeFieldUpdateOperationsInput | $Enums.PrepaidAlertType
    alertLevel?: EnumPrepaidAlertLevelFieldUpdateOperationsInput | $Enums.PrepaidAlertLevel
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balanceAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    consumptionAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_alertsUncheckedUpdateWithoutPrepaid_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    alertType?: EnumPrepaidAlertTypeFieldUpdateOperationsInput | $Enums.PrepaidAlertType
    alertLevel?: EnumPrepaidAlertLevelFieldUpdateOperationsInput | $Enums.PrepaidAlertLevel
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balanceAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    consumptionAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_alertsUncheckedUpdateManyWithoutPrepaid_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    alertType?: EnumPrepaidAlertTypeFieldUpdateOperationsInput | $Enums.PrepaidAlertType
    alertLevel?: EnumPrepaidAlertLevelFieldUpdateOperationsInput | $Enums.PrepaidAlertLevel
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balanceAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    consumptionAtAlert?: NullableFloatFieldUpdateOperationsInput | number | null
    thresholdValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_rechargesUpdateWithoutPrepaid_accountsInput = {
    rechargeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayName?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: EnumPrepaidRechargeTypeFieldUpdateOperationsInput | $Enums.PrepaidRechargeType
    rechargeSource?: EnumPrepaidRechargeSourceFieldUpdateOperationsInput | $Enums.PrepaidRechargeSource
    isPromotional?: BoolFieldUpdateOperationsInput | boolean
    promotionalCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: FloatFieldUpdateOperationsInput | number
    bonusAmount?: FloatFieldUpdateOperationsInput | number
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_rechargesUncheckedUpdateWithoutPrepaid_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rechargeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayName?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: EnumPrepaidRechargeTypeFieldUpdateOperationsInput | $Enums.PrepaidRechargeType
    rechargeSource?: EnumPrepaidRechargeSourceFieldUpdateOperationsInput | $Enums.PrepaidRechargeSource
    isPromotional?: BoolFieldUpdateOperationsInput | boolean
    promotionalCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: FloatFieldUpdateOperationsInput | number
    bonusAmount?: FloatFieldUpdateOperationsInput | number
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_rechargesUncheckedUpdateManyWithoutPrepaid_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rechargeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayName?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    rechargeType?: EnumPrepaidRechargeTypeFieldUpdateOperationsInput | $Enums.PrepaidRechargeType
    rechargeSource?: EnumPrepaidRechargeSourceFieldUpdateOperationsInput | $Enums.PrepaidRechargeSource
    isPromotional?: BoolFieldUpdateOperationsInput | boolean
    promotionalCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: FloatFieldUpdateOperationsInput | number
    bonusAmount?: FloatFieldUpdateOperationsInput | number
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_transactionsUpdateWithoutPrepaid_accountsInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumPrepaidTransactionTypeFieldUpdateOperationsInput | $Enums.PrepaidTransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    consumptionKWh?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerUnit?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedCharges?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumPrepaidTransactionStatusFieldUpdateOperationsInput | $Enums.PrepaidTransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meter_readings?: meter_readingsUpdateOneWithoutPrepaid_transactionsNestedInput
  }

  export type prepaid_transactionsUncheckedUpdateWithoutPrepaid_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumPrepaidTransactionTypeFieldUpdateOperationsInput | $Enums.PrepaidTransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    consumptionKWh?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerUnit?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedCharges?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    readingId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPrepaidTransactionStatusFieldUpdateOperationsInput | $Enums.PrepaidTransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prepaid_transactionsUncheckedUpdateManyWithoutPrepaid_accountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumPrepaidTransactionTypeFieldUpdateOperationsInput | $Enums.PrepaidTransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    balanceBefore?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    consumptionKWh?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerUnit?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedCharges?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableJsonNullValueInput | InputJsonValue
    readingId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumPrepaidTransactionStatusFieldUpdateOperationsInput | $Enums.PrepaidTransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tariff_slabsCreateManyTariffInput = {
    id?: number
    slab_order: number
    unit_limit: number
    unit_rate: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tariff_slabsUpdateWithoutTariffInput = {
    slab_order?: IntFieldUpdateOperationsInput | number
    unit_limit?: IntFieldUpdateOperationsInput | number
    unit_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tariff_slabsUncheckedUpdateWithoutTariffInput = {
    id?: IntFieldUpdateOperationsInput | number
    slab_order?: IntFieldUpdateOperationsInput | number
    unit_limit?: IntFieldUpdateOperationsInput | number
    unit_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tariff_slabsUncheckedUpdateManyWithoutTariffInput = {
    id?: IntFieldUpdateOperationsInput | number
    slab_order?: IntFieldUpdateOperationsInput | number
    unit_limit?: IntFieldUpdateOperationsInput | number
    unit_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BillsCountOutputTypeDefaultArgs instead
     */
    export type BillsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsumersCountOutputTypeDefaultArgs instead
     */
    export type ConsumersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsumersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentsCountOutputTypeDefaultArgs instead
     */
    export type DepartmentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DtrsCountOutputTypeDefaultArgs instead
     */
    export type DtrsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DtrsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Location_typesCountOutputTypeDefaultArgs instead
     */
    export type Location_typesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Location_typesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationsCountOutputTypeDefaultArgs instead
     */
    export type LocationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Meter_readingsCountOutputTypeDefaultArgs instead
     */
    export type Meter_readingsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Meter_readingsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MetersCountOutputTypeDefaultArgs instead
     */
    export type MetersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MetersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionsCountOutputTypeDefaultArgs instead
     */
    export type PermissionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Prepaid_accountsCountOutputTypeDefaultArgs instead
     */
    export type Prepaid_accountsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Prepaid_accountsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TariffCountOutputTypeDefaultArgs instead
     */
    export type TariffCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TariffCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use billsDefaultArgs instead
     */
    export type billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = billsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use consumer_documentsDefaultArgs instead
     */
    export type consumer_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = consumer_documentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use consumersDefaultArgs instead
     */
    export type consumersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = consumersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use current_transformersDefaultArgs instead
     */
    export type current_transformersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = current_transformersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use departmentsDefaultArgs instead
     */
    export type departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = departmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dtr_faultsDefaultArgs instead
     */
    export type dtr_faultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = dtr_faultsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dtr_maintenanceDefaultArgs instead
     */
    export type dtr_maintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = dtr_maintenanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dtr_readingsDefaultArgs instead
     */
    export type dtr_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = dtr_readingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dtrsDefaultArgs instead
     */
    export type dtrsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = dtrsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use location_typesDefaultArgs instead
     */
    export type location_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = location_typesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use locationsDefaultArgs instead
     */
    export type locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = locationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use login_historyDefaultArgs instead
     */
    export type login_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = login_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use meter_configurationsDefaultArgs instead
     */
    export type meter_configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = meter_configurationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use meter_readingsDefaultArgs instead
     */
    export type meter_readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = meter_readingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use metersDefaultArgs instead
     */
    export type metersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = metersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notificationsDefaultArgs instead
     */
    export type notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use paymentsDefaultArgs instead
     */
    export type paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = paymentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use permissionsDefaultArgs instead
     */
    export type permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = permissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use potential_transformersDefaultArgs instead
     */
    export type potential_transformersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = potential_transformersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use role_permissionsDefaultArgs instead
     */
    export type role_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = role_permissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolesDefaultArgs instead
     */
    export type rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ticketsDefaultArgs instead
     */
    export type ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ticketsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_activity_logsDefaultArgs instead
     */
    export type user_activity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_activity_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_permissionsDefaultArgs instead
     */
    export type user_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_permissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_sessionsDefaultArgs instead
     */
    export type user_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_sessionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use refresh_tokensDefaultArgs instead
     */
    export type refresh_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = refresh_tokensDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use raw_xml_importDefaultArgs instead
     */
    export type raw_xml_importArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = raw_xml_importDefaultArgs<ExtArgs>
    /**
     * @deprecated Use prepaid_accountsDefaultArgs instead
     */
    export type prepaid_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = prepaid_accountsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use prepaid_alertsDefaultArgs instead
     */
    export type prepaid_alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = prepaid_alertsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use prepaid_rechargesDefaultArgs instead
     */
    export type prepaid_rechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = prepaid_rechargesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use prepaid_transactionsDefaultArgs instead
     */
    export type prepaid_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = prepaid_transactionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tamper_code_descDefaultArgs instead
     */
    export type tamper_code_descArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tamper_code_descDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tamper_eventsDefaultArgs instead
     */
    export type tamper_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tamper_eventsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tariffDefaultArgs instead
     */
    export type tariffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tariffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tariff_slabsDefaultArgs instead
     */
    export type tariff_slabsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tariff_slabsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}